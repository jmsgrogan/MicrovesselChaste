// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "angiogenesis_headers.hpp"

namespace bp = boost::python;

struct AbstractMigrationRule_less__2__greater__wrapper : AbstractMigrationRule< 2 >, bp::wrapper< AbstractMigrationRule< 2 > > {

    AbstractMigrationRule_less__2__greater__wrapper(AbstractMigrationRule<2> const & arg )
    : AbstractMigrationRule<2>( arg )
      , bp::wrapper< AbstractMigrationRule< 2 > >(){
        // copy constructor
        
    }

    AbstractMigrationRule_less__2__greater__wrapper( )
    : AbstractMigrationRule<2>( )
      , bp::wrapper< AbstractMigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

};

struct AbstractMigrationRule_less__3__greater__wrapper : AbstractMigrationRule< 3 >, bp::wrapper< AbstractMigrationRule< 3 > > {

    AbstractMigrationRule_less__3__greater__wrapper(AbstractMigrationRule<3> const & arg )
    : AbstractMigrationRule<3>( arg )
      , bp::wrapper< AbstractMigrationRule< 3 > >(){
        // copy constructor
        
    }

    AbstractMigrationRule_less__3__greater__wrapper( )
    : AbstractMigrationRule<3>( )
      , bp::wrapper< AbstractMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

};

struct AbstractSproutingRule_less__2__greater__wrapper : AbstractSproutingRule< 2 >, bp::wrapper< AbstractSproutingRule< 2 > > {

    AbstractSproutingRule_less__2__greater__wrapper(AbstractSproutingRule<2> const & arg )
    : AbstractSproutingRule<2>( arg )
      , bp::wrapper< AbstractSproutingRule< 2 > >(){
        // copy constructor
        
    }

    AbstractSproutingRule_less__2__greater__wrapper( )
    : AbstractSproutingRule<2>( )
      , bp::wrapper< AbstractSproutingRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<2> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->AbstractSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<2> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 2 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        AbstractSproutingRule< 2 >::SetGrid( pGrid );
    }

};

struct AbstractSproutingRule_less__3__greater__wrapper : AbstractSproutingRule< 3 >, bp::wrapper< AbstractSproutingRule< 3 > > {

    AbstractSproutingRule_less__3__greater__wrapper(AbstractSproutingRule<3> const & arg )
    : AbstractSproutingRule<3>( arg )
      , bp::wrapper< AbstractSproutingRule< 3 > >(){
        // copy constructor
        
    }

    AbstractSproutingRule_less__3__greater__wrapper( )
    : AbstractSproutingRule<3>( )
      , bp::wrapper< AbstractSproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->AbstractSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        AbstractSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct AngiogenesisSolver_less__2__greater__wrapper : AngiogenesisSolver< 2 >, bp::wrapper< AngiogenesisSolver< 2 > > {

    AngiogenesisSolver_less__2__greater__wrapper(AngiogenesisSolver<2> const & arg )
    : AngiogenesisSolver<2>( arg )
      , bp::wrapper< AngiogenesisSolver< 2 > >(){
        // copy constructor
        
    }

    AngiogenesisSolver_less__2__greater__wrapper( )
    : AngiogenesisSolver<2>( )
      , bp::wrapper< AngiogenesisSolver< 2 > >(){
        // null constructor
    
    }

    virtual void DoAnastamosis(  ){
        if( bp::override func_DoAnastamosis = this->get_override( "DoAnastamosis" ) )
            func_DoAnastamosis(  );
        else{
            this->AngiogenesisSolver< 2 >::DoAnastamosis(  );
        }
    }
    
    virtual void default_DoAnastamosis(  ){
        AngiogenesisSolver< 2 >::DoAnastamosis( );
    }

    virtual void DoSprouting(  ){
        if( bp::override func_DoSprouting = this->get_override( "DoSprouting" ) )
            func_DoSprouting(  );
        else{
            this->AngiogenesisSolver< 2 >::DoSprouting(  );
        }
    }
    
    virtual void default_DoSprouting(  ){
        AngiogenesisSolver< 2 >::DoSprouting( );
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->AngiogenesisSolver< 2 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        AngiogenesisSolver< 2 >::Increment( );
    }

    virtual void UpdateNodalPositions( bool sprouting=false ){
        if( bp::override func_UpdateNodalPositions = this->get_override( "UpdateNodalPositions" ) )
            func_UpdateNodalPositions( sprouting );
        else{
            this->AngiogenesisSolver< 2 >::UpdateNodalPositions( sprouting );
        }
    }
    
    virtual void default_UpdateNodalPositions( bool sprouting=false ){
        AngiogenesisSolver< 2 >::UpdateNodalPositions( sprouting );
    }

};

struct AngiogenesisSolver_less__3__greater__wrapper : AngiogenesisSolver< 3 >, bp::wrapper< AngiogenesisSolver< 3 > > {

    AngiogenesisSolver_less__3__greater__wrapper(AngiogenesisSolver<3> const & arg )
    : AngiogenesisSolver<3>( arg )
      , bp::wrapper< AngiogenesisSolver< 3 > >(){
        // copy constructor
        
    }

    AngiogenesisSolver_less__3__greater__wrapper( )
    : AngiogenesisSolver<3>( )
      , bp::wrapper< AngiogenesisSolver< 3 > >(){
        // null constructor
    
    }

    virtual void DoAnastamosis(  ){
        if( bp::override func_DoAnastamosis = this->get_override( "DoAnastamosis" ) )
            func_DoAnastamosis(  );
        else{
            this->AngiogenesisSolver< 3 >::DoAnastamosis(  );
        }
    }
    
    virtual void default_DoAnastamosis(  ){
        AngiogenesisSolver< 3 >::DoAnastamosis( );
    }

    virtual void DoSprouting(  ){
        if( bp::override func_DoSprouting = this->get_override( "DoSprouting" ) )
            func_DoSprouting(  );
        else{
            this->AngiogenesisSolver< 3 >::DoSprouting(  );
        }
    }
    
    virtual void default_DoSprouting(  ){
        AngiogenesisSolver< 3 >::DoSprouting( );
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->AngiogenesisSolver< 3 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        AngiogenesisSolver< 3 >::Increment( );
    }

    virtual void UpdateNodalPositions( bool sprouting=false ){
        if( bp::override func_UpdateNodalPositions = this->get_override( "UpdateNodalPositions" ) )
            func_UpdateNodalPositions( sprouting );
        else{
            this->AngiogenesisSolver< 3 >::UpdateNodalPositions( sprouting );
        }
    }
    
    virtual void default_UpdateNodalPositions( bool sprouting=false ){
        AngiogenesisSolver< 3 >::UpdateNodalPositions( sprouting );
    }

};

struct LatticeBasedMigrationRule_less__2__greater__wrapper : LatticeBasedMigrationRule< 2 >, bp::wrapper< LatticeBasedMigrationRule< 2 > > {

    LatticeBasedMigrationRule_less__2__greater__wrapper(LatticeBasedMigrationRule<2> const & arg )
    : LatticeBasedMigrationRule<2>( arg )
      , bp::wrapper< LatticeBasedMigrationRule< 2 > >(){
        // copy constructor
        
    }

    LatticeBasedMigrationRule_less__2__greater__wrapper( )
    : LatticeBasedMigrationRule<2>( )
      , bp::wrapper< LatticeBasedMigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return LatticeBasedMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

    virtual ::std::vector< double > GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 2 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        if( bp::override func_GetNeighbourMovementProbabilities = this->get_override( "GetNeighbourMovementProbabilities" ) )
            return func_GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        }
    }
    
    virtual ::std::vector< double > default_GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 2 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        return LatticeBasedMigrationRule< 2 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

};

struct CellPopulationMigrationRule_less__2__greater__wrapper : CellPopulationMigrationRule< 2 >, bp::wrapper< CellPopulationMigrationRule< 2 > > {

    CellPopulationMigrationRule_less__2__greater__wrapper(CellPopulationMigrationRule<2> const & arg )
    : CellPopulationMigrationRule<2>( arg )
      , bp::wrapper< CellPopulationMigrationRule< 2 > >(){
        // copy constructor
        
    }

    CellPopulationMigrationRule_less__2__greater__wrapper( )
    : CellPopulationMigrationRule<2>( )
      , bp::wrapper< CellPopulationMigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->CellPopulationMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return CellPopulationMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< double > GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 2 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        if( bp::override func_GetNeighbourMovementProbabilities = this->get_override( "GetNeighbourMovementProbabilities" ) )
            return func_GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        else{
            return this->CellPopulationMigrationRule< 2 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        }
    }
    
    virtual ::std::vector< double > default_GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 2 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        return CellPopulationMigrationRule< 2 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct LatticeBasedMigrationRule_less__3__greater__wrapper : LatticeBasedMigrationRule< 3 >, bp::wrapper< LatticeBasedMigrationRule< 3 > > {

    LatticeBasedMigrationRule_less__3__greater__wrapper(LatticeBasedMigrationRule<3> const & arg )
    : LatticeBasedMigrationRule<3>( arg )
      , bp::wrapper< LatticeBasedMigrationRule< 3 > >(){
        // copy constructor
        
    }

    LatticeBasedMigrationRule_less__3__greater__wrapper( )
    : LatticeBasedMigrationRule<3>( )
      , bp::wrapper< LatticeBasedMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return LatticeBasedMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

    virtual ::std::vector< double > GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 3 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        if( bp::override func_GetNeighbourMovementProbabilities = this->get_override( "GetNeighbourMovementProbabilities" ) )
            return func_GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        }
    }
    
    virtual ::std::vector< double > default_GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 3 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        return LatticeBasedMigrationRule< 3 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

};

struct CellPopulationMigrationRule_less__3__greater__wrapper : CellPopulationMigrationRule< 3 >, bp::wrapper< CellPopulationMigrationRule< 3 > > {

    CellPopulationMigrationRule_less__3__greater__wrapper(CellPopulationMigrationRule<3> const & arg )
    : CellPopulationMigrationRule<3>( arg )
      , bp::wrapper< CellPopulationMigrationRule< 3 > >(){
        // copy constructor
        
    }

    CellPopulationMigrationRule_less__3__greater__wrapper( )
    : CellPopulationMigrationRule<3>( )
      , bp::wrapper< CellPopulationMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->CellPopulationMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return CellPopulationMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< double > GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 3 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        if( bp::override func_GetNeighbourMovementProbabilities = this->get_override( "GetNeighbourMovementProbabilities" ) )
            return func_GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        else{
            return this->CellPopulationMigrationRule< 3 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
        }
    }
    
    virtual ::std::vector< double > default_GetNeighbourMovementProbabilities( ::boost::shared_ptr< VesselNode< 3 > > pNode, ::std::vector< unsigned int > neighbourIndices, unsigned int gridIndex ){
        return CellPopulationMigrationRule< 3 >::GetNeighbourMovementProbabilities( pNode, neighbourIndices, gridIndex );
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct LatticeBasedSproutingRule_less__2__greater__wrapper : LatticeBasedSproutingRule< 2 >, bp::wrapper< LatticeBasedSproutingRule< 2 > > {

    LatticeBasedSproutingRule_less__2__greater__wrapper(LatticeBasedSproutingRule<2> const & arg )
    : LatticeBasedSproutingRule<2>( arg )
      , bp::wrapper< LatticeBasedSproutingRule< 2 > >(){
        // copy constructor
        
    }

    LatticeBasedSproutingRule_less__2__greater__wrapper( )
    : LatticeBasedSproutingRule<2>( )
      , bp::wrapper< LatticeBasedSproutingRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<2> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->LatticeBasedSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<2> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return LatticeBasedSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->LatticeBasedSproutingRule< 2 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        LatticeBasedSproutingRule< 2 >::SetGrid( pGrid );
    }

};

struct LatticeBasedSproutingRule_less__3__greater__wrapper : LatticeBasedSproutingRule< 3 >, bp::wrapper< LatticeBasedSproutingRule< 3 > > {

    LatticeBasedSproutingRule_less__3__greater__wrapper(LatticeBasedSproutingRule<3> const & arg )
    : LatticeBasedSproutingRule<3>( arg )
      , bp::wrapper< LatticeBasedSproutingRule< 3 > >(){
        // copy constructor
        
    }

    LatticeBasedSproutingRule_less__3__greater__wrapper( )
    : LatticeBasedSproutingRule<3>( )
      , bp::wrapper< LatticeBasedSproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->LatticeBasedSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return LatticeBasedSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->LatticeBasedSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        LatticeBasedSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct OffLatticeMigrationRule_less__2__greater__wrapper : OffLatticeMigrationRule< 2 >, bp::wrapper< OffLatticeMigrationRule< 2 > > {

    OffLatticeMigrationRule_less__2__greater__wrapper(OffLatticeMigrationRule<2> const & arg )
    : OffLatticeMigrationRule<2>( arg )
      , bp::wrapper< OffLatticeMigrationRule< 2 > >(){
        // copy constructor
        
    }

    OffLatticeMigrationRule_less__2__greater__wrapper( )
    : OffLatticeMigrationRule<2>( )
      , bp::wrapper< OffLatticeMigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->OffLatticeMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return OffLatticeMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

};

struct OffLatticeMigrationRule_less__3__greater__wrapper : OffLatticeMigrationRule< 3 >, bp::wrapper< OffLatticeMigrationRule< 3 > > {

    OffLatticeMigrationRule_less__3__greater__wrapper(OffLatticeMigrationRule<3> const & arg )
    : OffLatticeMigrationRule<3>( arg )
      , bp::wrapper< OffLatticeMigrationRule< 3 > >(){
        // copy constructor
        
    }

    OffLatticeMigrationRule_less__3__greater__wrapper( )
    : OffLatticeMigrationRule<3>( )
      , bp::wrapper< OffLatticeMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->OffLatticeMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return OffLatticeMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

};

struct OffLatticeSproutingRule_less__2__greater__wrapper : OffLatticeSproutingRule< 2 >, bp::wrapper< OffLatticeSproutingRule< 2 > > {

    OffLatticeSproutingRule_less__2__greater__wrapper(OffLatticeSproutingRule<2> const & arg )
    : OffLatticeSproutingRule<2>( arg )
      , bp::wrapper< OffLatticeSproutingRule< 2 > >(){
        // copy constructor
        
    }

    OffLatticeSproutingRule_less__2__greater__wrapper( )
    : OffLatticeSproutingRule<2>( )
      , bp::wrapper< OffLatticeSproutingRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<2> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->OffLatticeSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<2> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return OffLatticeSproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 2 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        AbstractSproutingRule< 2 >::SetGrid( pGrid );
    }

};

struct OffLatticeSproutingRule_less__3__greater__wrapper : OffLatticeSproutingRule< 3 >, bp::wrapper< OffLatticeSproutingRule< 3 > > {

    OffLatticeSproutingRule_less__3__greater__wrapper(OffLatticeSproutingRule<3> const & arg )
    : OffLatticeSproutingRule<3>( arg )
      , bp::wrapper< OffLatticeSproutingRule< 3 > >(){
        // copy constructor
        
    }

    OffLatticeSproutingRule_less__3__greater__wrapper( )
    : OffLatticeSproutingRule<3>( )
      , bp::wrapper< OffLatticeSproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->OffLatticeSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return OffLatticeSproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->AbstractSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        AbstractSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct Owen2011MigrationRule_less__2__greater__wrapper : Owen2011MigrationRule< 2 >, bp::wrapper< Owen2011MigrationRule< 2 > > {

    Owen2011MigrationRule_less__2__greater__wrapper(Owen2011MigrationRule<2> const & arg )
    : Owen2011MigrationRule<2>( arg )
      , bp::wrapper< Owen2011MigrationRule< 2 > >(){
        // copy constructor
        
    }

    Owen2011MigrationRule_less__2__greater__wrapper( )
    : Owen2011MigrationRule<2>( )
      , bp::wrapper< Owen2011MigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->Owen2011MigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return Owen2011MigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct Owen2011MigrationRule_less__3__greater__wrapper : Owen2011MigrationRule< 3 >, bp::wrapper< Owen2011MigrationRule< 3 > > {

    Owen2011MigrationRule_less__3__greater__wrapper(Owen2011MigrationRule<3> const & arg )
    : Owen2011MigrationRule<3>( arg )
      , bp::wrapper< Owen2011MigrationRule< 3 > >(){
        // copy constructor
        
    }

    Owen2011MigrationRule_less__3__greater__wrapper( )
    : Owen2011MigrationRule<3>( )
      , bp::wrapper< Owen2011MigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->Owen2011MigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return Owen2011MigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct Owen2011SproutingRule_less__2__greater__wrapper : Owen2011SproutingRule< 2 >, bp::wrapper< Owen2011SproutingRule< 2 > > {

    Owen2011SproutingRule_less__2__greater__wrapper(Owen2011SproutingRule<2> const & arg )
    : Owen2011SproutingRule<2>( arg )
      , bp::wrapper< Owen2011SproutingRule< 2 > >(){
        // copy constructor
        
    }

    Owen2011SproutingRule_less__2__greater__wrapper( )
    : Owen2011SproutingRule<2>( )
      , bp::wrapper< Owen2011SproutingRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<2> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->Owen2011SproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<2> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return Owen2011SproutingRule< 2 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->LatticeBasedSproutingRule< 2 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        LatticeBasedSproutingRule< 2 >::SetGrid( pGrid );
    }

};

struct Owen2011SproutingRule_less__3__greater__wrapper : Owen2011SproutingRule< 3 >, bp::wrapper< Owen2011SproutingRule< 3 > > {

    Owen2011SproutingRule_less__3__greater__wrapper(Owen2011SproutingRule<3> const & arg )
    : Owen2011SproutingRule<3>( arg )
      , bp::wrapper< Owen2011SproutingRule< 3 > >(){
        // copy constructor
        
    }

    Owen2011SproutingRule_less__3__greater__wrapper( )
    : Owen2011SproutingRule<3>( )
      , bp::wrapper< Owen2011SproutingRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::shared_ptr<VesselNode<3> > > GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetSprouts = this->get_override( "GetSprouts" ) )
            return func_GetSprouts( boost::ref(rNodes) );
        else{
            return this->Owen2011SproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< boost::shared_ptr<VesselNode<3> > > default_GetSprouts( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return Owen2011SproutingRule< 3 >::GetSprouts( boost::ref(rNodes) );
    }

    virtual void SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_SetGrid = this->get_override( "SetGrid" ) )
            func_SetGrid( pGrid );
        else{
            this->LatticeBasedSproutingRule< 3 >::SetGrid( pGrid );
        }
    }
    
    void default_SetGrid( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        LatticeBasedSproutingRule< 3 >::SetGrid( pGrid );
    }

};

struct RegressionSolver_less__2__greater__wrapper : RegressionSolver< 2 >, bp::wrapper< RegressionSolver< 2 > > {

    RegressionSolver_less__2__greater__wrapper(RegressionSolver<2> const & arg )
    : RegressionSolver<2>( arg )
      , bp::wrapper< RegressionSolver< 2 > >(){
        // copy constructor
        
    }

    RegressionSolver_less__2__greater__wrapper( )
    : RegressionSolver<2>( )
      , bp::wrapper< RegressionSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->RegressionSolver< 2 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        RegressionSolver< 2 >::Increment( );
    }

};

struct RegressionSolver_less__3__greater__wrapper : RegressionSolver< 3 >, bp::wrapper< RegressionSolver< 3 > > {

    RegressionSolver_less__3__greater__wrapper(RegressionSolver<3> const & arg )
    : RegressionSolver<3>( arg )
      , bp::wrapper< RegressionSolver< 3 > >(){
        // copy constructor
        
    }

    RegressionSolver_less__3__greater__wrapper( )
    : RegressionSolver<3>( )
      , bp::wrapper< RegressionSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->RegressionSolver< 3 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        RegressionSolver< 3 >::Increment( );
    }

};

struct TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper : TipAttractionLatticeBasedMigrationRule< 2 >, bp::wrapper< TipAttractionLatticeBasedMigrationRule< 2 > > {

    TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper(TipAttractionLatticeBasedMigrationRule<2> const & arg )
    : TipAttractionLatticeBasedMigrationRule<2>( arg )
      , bp::wrapper< TipAttractionLatticeBasedMigrationRule< 2 > >(){
        // copy constructor
        
    }

    TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper( )
    : TipAttractionLatticeBasedMigrationRule<2>( )
      , bp::wrapper< TipAttractionLatticeBasedMigrationRule< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->TipAttractionLatticeBasedMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return TipAttractionLatticeBasedMigrationRule< 2 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< DimensionalChastePoint<2> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<2> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & rNodes ) {
        return AbstractMigrationRule< 2 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper : TipAttractionLatticeBasedMigrationRule< 3 >, bp::wrapper< TipAttractionLatticeBasedMigrationRule< 3 > > {

    TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper(TipAttractionLatticeBasedMigrationRule<3> const & arg )
    : TipAttractionLatticeBasedMigrationRule<3>( arg )
      , bp::wrapper< TipAttractionLatticeBasedMigrationRule< 3 > >(){
        // copy constructor
        
    }

    TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper( )
    : TipAttractionLatticeBasedMigrationRule<3>( )
      , bp::wrapper< TipAttractionLatticeBasedMigrationRule< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< int > GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetIndices = this->get_override( "GetIndices" ) )
            return func_GetIndices( boost::ref(rNodes) );
        else{
            return this->TipAttractionLatticeBasedMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< int > default_GetIndices( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return TipAttractionLatticeBasedMigrationRule< 3 >::GetIndices( boost::ref(rNodes) );
    }

    virtual ::std::vector< DimensionalChastePoint<3> > GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        if( bp::override func_GetDirections = this->get_override( "GetDirections" ) )
            return func_GetDirections( boost::ref(rNodes) );
        else{
            return this->AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
        }
    }
    
    ::std::vector< DimensionalChastePoint<3> > default_GetDirections( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & rNodes ) {
        return AbstractMigrationRule< 3 >::GetDirections( boost::ref(rNodes) );
    }

    virtual int GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        if( bp::override func_GetNeighbourMovementIndex = this->get_override( "GetNeighbourMovementIndex" ) )
            return func_GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        else{
            return this->LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
        }
    }
    
    virtual int default_GetNeighbourMovementIndex( ::std::vector< double > movementProbabilities, ::std::vector< unsigned int > neighbourIndices ){
        return LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex( movementProbabilities, neighbourIndices );
    }

};

struct WallShearStressBasedRegressionSolver_less__2__greater__wrapper : WallShearStressBasedRegressionSolver< 2 >, bp::wrapper< WallShearStressBasedRegressionSolver< 2 > > {

    WallShearStressBasedRegressionSolver_less__2__greater__wrapper(WallShearStressBasedRegressionSolver<2> const & arg )
    : WallShearStressBasedRegressionSolver<2>( arg )
      , bp::wrapper< WallShearStressBasedRegressionSolver< 2 > >(){
        // copy constructor
        
    }

    WallShearStressBasedRegressionSolver_less__2__greater__wrapper( )
    : WallShearStressBasedRegressionSolver<2>( )
      , bp::wrapper< WallShearStressBasedRegressionSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->WallShearStressBasedRegressionSolver< 2 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        WallShearStressBasedRegressionSolver< 2 >::Increment( );
    }

};

struct WallShearStressBasedRegressionSolver_less__3__greater__wrapper : WallShearStressBasedRegressionSolver< 3 >, bp::wrapper< WallShearStressBasedRegressionSolver< 3 > > {

    WallShearStressBasedRegressionSolver_less__3__greater__wrapper(WallShearStressBasedRegressionSolver<3> const & arg )
    : WallShearStressBasedRegressionSolver<3>( arg )
      , bp::wrapper< WallShearStressBasedRegressionSolver< 3 > >(){
        // copy constructor
        
    }

    WallShearStressBasedRegressionSolver_less__3__greater__wrapper( )
    : WallShearStressBasedRegressionSolver<3>( )
      , bp::wrapper< WallShearStressBasedRegressionSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Increment(  ) {
        if( bp::override func_Increment = this->get_override( "Increment" ) )
            func_Increment(  );
        else{
            this->WallShearStressBasedRegressionSolver< 3 >::Increment(  );
        }
    }
    
    void default_Increment(  ) {
        WallShearStressBasedRegressionSolver< 3 >::Increment( );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 2 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_MicrovesselChaste_angiogenesis){
    { //::std::vector< unsigned int >
        typedef bp::class_< std::vector< unsigned int > > vector_less__unsigned_int__greater__exposer_t;
        vector_less__unsigned_int__greater__exposer_t vector_less__unsigned_int__greater__exposer = vector_less__unsigned_int__greater__exposer_t( "vector_less__unsigned_int__greater_" );
        bp::scope vector_less__unsigned_int__greater__scope( vector_less__unsigned_int__greater__exposer );
        vector_less__unsigned_int__greater__exposer.def( bp::indexing::vector_suite< std::vector< unsigned int > >() );
    }

    bp::class_< std::vector< int > >("vector_less__int__greater_")    
        .def( bp::indexing::vector_suite< std::vector< int > >() );

    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    bp::class_< std::vector< boost::shared_ptr<VesselNode<3> > > >("vector_less__boost_scope_shared_ptr_less_VesselNode_less_3_greater___greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<3> > > >() );

    bp::class_< std::vector< boost::shared_ptr<VesselNode<2> > > >("vector_less__boost_scope_shared_ptr_less_VesselNode_less_2_greater___greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<2> > > >() );

    bp::class_< std::vector< DimensionalChastePoint<3> > >("vector_less__DimensionalChastePoint_less_3_greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<3> > >() );

    bp::class_< std::vector< DimensionalChastePoint<2> > >("vector_less__DimensionalChastePoint_less_2_greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<2> > >() );

    { //::AbstractMigrationRule< 2 >
        typedef bp::class_< AbstractMigrationRule_less__2__greater__wrapper > AbstractMigrationRule2_exposer_t;
        AbstractMigrationRule2_exposer_t AbstractMigrationRule2_exposer = AbstractMigrationRule2_exposer_t( "AbstractMigrationRule2", bp::init< >() );
        bp::scope AbstractMigrationRule2_scope( AbstractMigrationRule2_exposer );
        { //::AbstractMigrationRule< 2 >::Create
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< AbstractMigrationRule< 2 > > ( *Create_function_type )(  );
            
            AbstractMigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::AbstractMigrationRule< 2 >::Create ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetDirections
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( AbstractMigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&AbstractMigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetIndices
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( AbstractMigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&AbstractMigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetBoundingDomain
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetBoundingDomain_function_type)( ::boost::shared_ptr< Part< 2 > > ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetBoundingDomain"
                , SetBoundingDomain_function_type( &::AbstractMigrationRule< 2 >::SetBoundingDomain )
                , ( bp::arg("pPart") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetCellPopulation
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 2, 2 > > ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AbstractMigrationRule< 2 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetDiscreteContinuumSolver
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractMigrationRule< 2 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetGrid
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetGrid"
                , SetGrid_function_type( &::AbstractMigrationRule< 2 >::SetGrid )
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetIsSprouting
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsSprouting_function_type)( bool ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetIsSprouting"
                , SetIsSprouting_function_type( &::AbstractMigrationRule< 2 >::SetIsSprouting )
                , ( bp::arg("isSprouting")=(bool)(true) ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetNetwork
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::AbstractMigrationRule< 2 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::SetUseMooreNeighbourhood
        
            typedef AbstractMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseMooreNeighbourhood_function_type)( bool ) ;
            
            AbstractMigrationRule2_exposer.def( 
                "SetUseMooreNeighbourhood"
                , SetUseMooreNeighbourhood_function_type( &::AbstractMigrationRule< 2 >::SetUseMooreNeighbourhood )
                , ( bp::arg("useMooreNeighbourhood") ) );
        
        }
        AbstractMigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AbstractMigrationRule<2> > >();
    }

    { //::AbstractMigrationRule< 3 >
        typedef bp::class_< AbstractMigrationRule_less__3__greater__wrapper > AbstractMigrationRule3_exposer_t;
        AbstractMigrationRule3_exposer_t AbstractMigrationRule3_exposer = AbstractMigrationRule3_exposer_t( "AbstractMigrationRule3", bp::init< >() );
        bp::scope AbstractMigrationRule3_scope( AbstractMigrationRule3_exposer );
        { //::AbstractMigrationRule< 3 >::Create
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< AbstractMigrationRule< 3 > > ( *Create_function_type )(  );
            
            AbstractMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::AbstractMigrationRule< 3 >::Create ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( AbstractMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&AbstractMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetIndices
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( AbstractMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&AbstractMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetBoundingDomain
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetBoundingDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetBoundingDomain"
                , SetBoundingDomain_function_type( &::AbstractMigrationRule< 3 >::SetBoundingDomain )
                , ( bp::arg("pPart") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetCellPopulation
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 3, 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AbstractMigrationRule< 3 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetDiscreteContinuumSolver
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractMigrationRule< 3 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetGrid
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type( &::AbstractMigrationRule< 3 >::SetGrid )
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetIsSprouting
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsSprouting_function_type)( bool ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetIsSprouting"
                , SetIsSprouting_function_type( &::AbstractMigrationRule< 3 >::SetIsSprouting )
                , ( bp::arg("isSprouting")=(bool)(true) ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetNetwork
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::AbstractMigrationRule< 3 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::SetUseMooreNeighbourhood
        
            typedef AbstractMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseMooreNeighbourhood_function_type)( bool ) ;
            
            AbstractMigrationRule3_exposer.def( 
                "SetUseMooreNeighbourhood"
                , SetUseMooreNeighbourhood_function_type( &::AbstractMigrationRule< 3 >::SetUseMooreNeighbourhood )
                , ( bp::arg("useMooreNeighbourhood") ) );
        
        }
        AbstractMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AbstractMigrationRule<3> > >();
    }

    { //::AbstractSproutingRule< 2 >
        typedef bp::class_< AbstractSproutingRule_less__2__greater__wrapper > AbstractSproutingRule2_exposer_t;
        AbstractSproutingRule2_exposer_t AbstractSproutingRule2_exposer = AbstractSproutingRule2_exposer_t( "AbstractSproutingRule2", bp::init< >() );
        bp::scope AbstractSproutingRule2_scope( AbstractSproutingRule2_exposer );
        { //::AbstractSproutingRule< 2 >::GetSprouts
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( AbstractSproutingRule_less__2__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::AbstractSproutingRule< 2 >::GetSprouts)
                , default_GetSprouts_function_type(&AbstractSproutingRule_less__2__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetDiscreteContinuumSolver
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractSproutingRule< 2 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetGrid
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef void ( AbstractSproutingRule_less__2__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 2 >::SetGrid)
                , default_SetGrid_function_type(&AbstractSproutingRule_less__2__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetSproutingProbability
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingProbability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "SetSproutingProbability"
                , SetSproutingProbability_function_type( &::AbstractSproutingRule< 2 >::SetSproutingProbability )
                , ( bp::arg("probability") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetVesselEndCutoff
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselEndCutoff_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "SetVesselEndCutoff"
                , SetVesselEndCutoff_function_type( &::AbstractSproutingRule< 2 >::SetVesselEndCutoff )
                , ( bp::arg("cutoff") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetVesselNetwork
        
            typedef AbstractSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            AbstractSproutingRule2_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AbstractSproutingRule< 2 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractSproutingRule<2> > >();
    }

    { //::AbstractSproutingRule< 3 >
        typedef bp::class_< AbstractSproutingRule_less__3__greater__wrapper > AbstractSproutingRule3_exposer_t;
        AbstractSproutingRule3_exposer_t AbstractSproutingRule3_exposer = AbstractSproutingRule3_exposer_t( "AbstractSproutingRule3", bp::init< >() );
        bp::scope AbstractSproutingRule3_scope( AbstractSproutingRule3_exposer );
        { //::AbstractSproutingRule< 3 >::GetSprouts
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( AbstractSproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::AbstractSproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&AbstractSproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetDiscreteContinuumSolver
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDiscreteContinuumSolver_function_type)( ::boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetDiscreteContinuumSolver"
                , SetDiscreteContinuumSolver_function_type( &::AbstractSproutingRule< 3 >::SetDiscreteContinuumSolver )
                , ( bp::arg("pSolver") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetGrid
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef void ( AbstractSproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&AbstractSproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetSproutingProbability
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingProbability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetSproutingProbability"
                , SetSproutingProbability_function_type( &::AbstractSproutingRule< 3 >::SetSproutingProbability )
                , ( bp::arg("probability") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetVesselEndCutoff
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselEndCutoff_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetVesselEndCutoff"
                , SetVesselEndCutoff_function_type( &::AbstractSproutingRule< 3 >::SetVesselEndCutoff )
                , ( bp::arg("cutoff") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetVesselNetwork
        
            typedef AbstractSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AbstractSproutingRule3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AbstractSproutingRule< 3 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractSproutingRule<3> > >();
    }

    { //::AngiogenesisSolver< 2 >
        typedef bp::class_< AngiogenesisSolver_less__2__greater__wrapper > AngiogenesisSolver2_exposer_t;
        AngiogenesisSolver2_exposer_t AngiogenesisSolver2_exposer = AngiogenesisSolver2_exposer_t( "AngiogenesisSolver2", bp::init< >() );
        bp::scope AngiogenesisSolver2_scope( AngiogenesisSolver2_exposer );
        { //::AngiogenesisSolver< 2 >::Create
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< AngiogenesisSolver< 2 > > ( *Create_function_type )(  );
            
            AngiogenesisSolver2_exposer.def( 
                "Create"
                , Create_function_type( &::AngiogenesisSolver< 2 >::Create ) );
        
        }
        { //::AngiogenesisSolver< 2 >::DoAnastamosis
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__2__greater__wrapper::*DoAnastamosis_function_type)(  ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "DoAnastamosis"
                , DoAnastamosis_function_type( &AngiogenesisSolver_less__2__greater__wrapper::default_DoAnastamosis ) );
        
        }
        { //::AngiogenesisSolver< 2 >::DoSprouting
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__2__greater__wrapper::*DoSprouting_function_type)(  ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "DoSprouting"
                , DoSprouting_function_type( &AngiogenesisSolver_less__2__greater__wrapper::default_DoSprouting ) );
        
        }
        { //::AngiogenesisSolver< 2 >::Increment
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Increment_function_type)(  ) ;
            typedef void ( AngiogenesisSolver_less__2__greater__wrapper::*default_Increment_function_type)(  ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "Increment"
                , Increment_function_type(&::AngiogenesisSolver< 2 >::Increment)
                , default_Increment_function_type(&AngiogenesisSolver_less__2__greater__wrapper::default_Increment) );
        
        }
        { //::AngiogenesisSolver< 2 >::IsSproutingRuleSet
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsSproutingRuleSet_function_type)(  ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "IsSproutingRuleSet"
                , IsSproutingRuleSet_function_type( &::AngiogenesisSolver< 2 >::IsSproutingRuleSet ) );
        
        }
        { //::AngiogenesisSolver< 2 >::Run
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Run_function_type)( bool ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "Run"
                , Run_function_type( &::AngiogenesisSolver< 2 >::Run )
                , ( bp::arg("writeOutput")=(bool)(false) ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetAnastamosisRadius
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetAnastamosisRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetAnastamosisRadius"
                , SetAnastamosisRadius_function_type( &::AngiogenesisSolver< 2 >::SetAnastamosisRadius )
                , ( bp::arg("radius") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetBoundingDomain
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetBoundingDomain_function_type)( ::boost::shared_ptr< Part< 2 > > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetBoundingDomain"
                , SetBoundingDomain_function_type( &::AngiogenesisSolver< 2 >::SetBoundingDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetCellPopulation
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 2, 2 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AngiogenesisSolver< 2 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation"), bp::arg("cellPopulationReferenceLength") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetMigrationRule
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMigrationRule_function_type)( ::boost::shared_ptr< AbstractMigrationRule< 2 > > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetMigrationRule"
                , SetMigrationRule_function_type( &::AngiogenesisSolver< 2 >::SetMigrationRule )
                , ( bp::arg("pMigrationRule") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetOutputFileHandler
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputFileHandler_function_type)( ::boost::shared_ptr< OutputFileHandler > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetOutputFileHandler"
                , SetOutputFileHandler_function_type( &::AngiogenesisSolver< 2 >::SetOutputFileHandler )
                , ( bp::arg("pHandler") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetSproutingRule
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingRule_function_type)( ::boost::shared_ptr< AbstractSproutingRule< 2 > > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetSproutingRule"
                , SetSproutingRule_function_type( &::AngiogenesisSolver< 2 >::SetSproutingRule )
                , ( bp::arg("pSproutingRule") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetVesselGrid
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetVesselGrid"
                , SetVesselGrid_function_type( &::AngiogenesisSolver< 2 >::SetVesselGrid )
                , ( bp::arg("pVesselGrid") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::SetVesselNetwork
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AngiogenesisSolver< 2 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::AngiogenesisSolver< 2 >::UpdateNodalPositions
        
            typedef AngiogenesisSolver< 2 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__2__greater__wrapper::*UpdateNodalPositions_function_type)( bool ) ;
            
            AngiogenesisSolver2_exposer.def( 
                "UpdateNodalPositions"
                , UpdateNodalPositions_function_type( &AngiogenesisSolver_less__2__greater__wrapper::default_UpdateNodalPositions )
                , ( bp::arg("sprouting")=(bool)(false) ) );
        
        }
        AngiogenesisSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AngiogenesisSolver<2> > >();
    }

    { //::AngiogenesisSolver< 3 >
        typedef bp::class_< AngiogenesisSolver_less__3__greater__wrapper > AngiogenesisSolver3_exposer_t;
        AngiogenesisSolver3_exposer_t AngiogenesisSolver3_exposer = AngiogenesisSolver3_exposer_t( "AngiogenesisSolver3", bp::init< >() );
        bp::scope AngiogenesisSolver3_scope( AngiogenesisSolver3_exposer );
        { //::AngiogenesisSolver< 3 >::Create
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< AngiogenesisSolver< 3 > > ( *Create_function_type )(  );
            
            AngiogenesisSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::AngiogenesisSolver< 3 >::Create ) );
        
        }
        { //::AngiogenesisSolver< 3 >::DoAnastamosis
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*DoAnastamosis_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "DoAnastamosis"
                , DoAnastamosis_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_DoAnastamosis ) );
        
        }
        { //::AngiogenesisSolver< 3 >::DoSprouting
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*DoSprouting_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "DoSprouting"
                , DoSprouting_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_DoSprouting ) );
        
        }
        { //::AngiogenesisSolver< 3 >::Increment
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Increment_function_type)(  ) ;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*default_Increment_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "Increment"
                , Increment_function_type(&::AngiogenesisSolver< 3 >::Increment)
                , default_Increment_function_type(&AngiogenesisSolver_less__3__greater__wrapper::default_Increment) );
        
        }
        { //::AngiogenesisSolver< 3 >::IsSproutingRuleSet
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsSproutingRuleSet_function_type)(  ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "IsSproutingRuleSet"
                , IsSproutingRuleSet_function_type( &::AngiogenesisSolver< 3 >::IsSproutingRuleSet ) );
        
        }
        { //::AngiogenesisSolver< 3 >::Run
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Run_function_type)( bool ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "Run"
                , Run_function_type( &::AngiogenesisSolver< 3 >::Run )
                , ( bp::arg("writeOutput")=(bool)(false) ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetAnastamosisRadius
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetAnastamosisRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetAnastamosisRadius"
                , SetAnastamosisRadius_function_type( &::AngiogenesisSolver< 3 >::SetAnastamosisRadius )
                , ( bp::arg("radius") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetBoundingDomain
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetBoundingDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetBoundingDomain"
                , SetBoundingDomain_function_type( &::AngiogenesisSolver< 3 >::SetBoundingDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetCellPopulation
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellPopulation_function_type)( ::boost::shared_ptr< AbstractCellPopulation< 3, 3 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetCellPopulation"
                , SetCellPopulation_function_type( &::AngiogenesisSolver< 3 >::SetCellPopulation )
                , ( bp::arg("pCellPopulation"), bp::arg("cellPopulationReferenceLength") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetMigrationRule
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMigrationRule_function_type)( ::boost::shared_ptr< AbstractMigrationRule< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetMigrationRule"
                , SetMigrationRule_function_type( &::AngiogenesisSolver< 3 >::SetMigrationRule )
                , ( bp::arg("pMigrationRule") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetOutputFileHandler
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputFileHandler_function_type)( ::boost::shared_ptr< OutputFileHandler > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetOutputFileHandler"
                , SetOutputFileHandler_function_type( &::AngiogenesisSolver< 3 >::SetOutputFileHandler )
                , ( bp::arg("pHandler") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetSproutingRule
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingRule_function_type)( ::boost::shared_ptr< AbstractSproutingRule< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetSproutingRule"
                , SetSproutingRule_function_type( &::AngiogenesisSolver< 3 >::SetSproutingRule )
                , ( bp::arg("pSproutingRule") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetVesselGrid
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetVesselGrid"
                , SetVesselGrid_function_type( &::AngiogenesisSolver< 3 >::SetVesselGrid )
                , ( bp::arg("pVesselGrid") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::SetVesselNetwork
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::AngiogenesisSolver< 3 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::AngiogenesisSolver< 3 >::UpdateNodalPositions
        
            typedef AngiogenesisSolver< 3 > exported_class_t;
            typedef void ( AngiogenesisSolver_less__3__greater__wrapper::*UpdateNodalPositions_function_type)( bool ) ;
            
            AngiogenesisSolver3_exposer.def( 
                "UpdateNodalPositions"
                , UpdateNodalPositions_function_type( &AngiogenesisSolver_less__3__greater__wrapper::default_UpdateNodalPositions )
                , ( bp::arg("sprouting")=(bool)(false) ) );
        
        }
        AngiogenesisSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< AngiogenesisSolver<3> > >();
    }

    { //::LatticeBasedMigrationRule< 2 >
        typedef bp::class_< LatticeBasedMigrationRule_less__2__greater__wrapper, bp::bases< AbstractMigrationRule< 2 > > > LatticeBasedMigrationRule2_exposer_t;
        LatticeBasedMigrationRule2_exposer_t LatticeBasedMigrationRule2_exposer = LatticeBasedMigrationRule2_exposer_t( "LatticeBasedMigrationRule2", bp::init< >() );
        bp::scope LatticeBasedMigrationRule2_scope( LatticeBasedMigrationRule2_exposer );
        { //::LatticeBasedMigrationRule< 2 >::Create
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< LatticeBasedMigrationRule< 2 > > ( *Create_function_type )(  );
            
            LatticeBasedMigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::LatticeBasedMigrationRule< 2 >::Create ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetIndices
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( LatticeBasedMigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            LatticeBasedMigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::LatticeBasedMigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&LatticeBasedMigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef int ( LatticeBasedMigrationRule_less__2__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            LatticeBasedMigrationRule2_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &LatticeBasedMigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetNeighbourMovementProbabilities
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< double > ( LatticeBasedMigrationRule_less__2__greater__wrapper::*GetNeighbourMovementProbabilities_function_type)( ::boost::shared_ptr< VesselNode< 2 > >,::std::vector< unsigned int >,unsigned int ) ;
            
            LatticeBasedMigrationRule2_exposer.def( 
                "GetNeighbourMovementProbabilities"
                , GetNeighbourMovementProbabilities_function_type( &LatticeBasedMigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementProbabilities )
                , ( bp::arg("pNode"), bp::arg("neighbourIndices"), bp::arg("gridIndex") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::SetMovementProbability
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMovementProbability_function_type)( double ) ;
            
            LatticeBasedMigrationRule2_exposer.def( 
                "SetMovementProbability"
                , SetMovementProbability_function_type( &::LatticeBasedMigrationRule< 2 >::SetMovementProbability )
                , ( bp::arg("movementProbability") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetDirections
        
            typedef LatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( LatticeBasedMigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            LatticeBasedMigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&LatticeBasedMigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        LatticeBasedMigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LatticeBasedMigrationRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< LatticeBasedMigrationRule< 2 > >, boost::shared_ptr< AbstractMigrationRule< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 2 > >, boost::shared_ptr< LatticeBasedMigrationRule< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< CellPopulationMigrationRule< 2 > >, boost::shared_ptr< LatticeBasedMigrationRule< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 2 > >, boost::shared_ptr< LatticeBasedMigrationRule< 2 > > >();
    }

    { //::CellPopulationMigrationRule< 2 >
        typedef bp::class_< CellPopulationMigrationRule_less__2__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 2 > > > CellPopulationMigrationRule2_exposer_t;
        CellPopulationMigrationRule2_exposer_t CellPopulationMigrationRule2_exposer = CellPopulationMigrationRule2_exposer_t( "CellPopulationMigrationRule2", bp::init< >() );
        bp::scope CellPopulationMigrationRule2_scope( CellPopulationMigrationRule2_exposer );
        { //::CellPopulationMigrationRule< 2 >::Create
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< CellPopulationMigrationRule< 2 > > ( *Create_function_type )(  );
            
            CellPopulationMigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::CellPopulationMigrationRule< 2 >::Create ) );
        
        }
        { //::CellPopulationMigrationRule< 2 >::GetIndices
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( CellPopulationMigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::CellPopulationMigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&CellPopulationMigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::CellPopulationMigrationRule< 2 >::GetNeighbourMovementProbabilities
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< double > ( CellPopulationMigrationRule_less__2__greater__wrapper::*GetNeighbourMovementProbabilities_function_type)( ::boost::shared_ptr< VesselNode< 2 > >,::std::vector< unsigned int >,unsigned int ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "GetNeighbourMovementProbabilities"
                , GetNeighbourMovementProbabilities_function_type( &CellPopulationMigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementProbabilities )
                , ( bp::arg("pNode"), bp::arg("neighbourIndices"), bp::arg("gridIndex") ) );
        
        }
        { //::CellPopulationMigrationRule< 2 >::GetOccupyingVolumeFraction
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetOccupyingVolumeFraction_function_type)( ::boost::shared_ptr< AbstractCellMutationState > ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "GetOccupyingVolumeFraction"
                , GetOccupyingVolumeFraction_function_type( &::CellPopulationMigrationRule< 2 >::GetOccupyingVolumeFraction )
                , ( bp::arg("mutation_state") ) );
        
        }
        { //::CellPopulationMigrationRule< 2 >::SetVolumeFraction
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVolumeFraction_function_type)( ::boost::shared_ptr< AbstractCellMutationState >,double ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "SetVolumeFraction"
                , SetVolumeFraction_function_type( &::CellPopulationMigrationRule< 2 >::SetVolumeFraction )
                , ( bp::arg("mutation_state"), bp::arg("volume_fraction") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetDirections
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( CellPopulationMigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&CellPopulationMigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex
        
            typedef CellPopulationMigrationRule< 2 > exported_class_t;
            typedef int ( CellPopulationMigrationRule_less__2__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            CellPopulationMigrationRule2_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &CellPopulationMigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        CellPopulationMigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellPopulationMigrationRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellPopulationMigrationRule< 2 > >, boost::shared_ptr< AbstractMigrationRule< 2 > > >();
    }

    { //::LatticeBasedMigrationRule< 3 >
        typedef bp::class_< LatticeBasedMigrationRule_less__3__greater__wrapper, bp::bases< AbstractMigrationRule< 3 > > > LatticeBasedMigrationRule3_exposer_t;
        LatticeBasedMigrationRule3_exposer_t LatticeBasedMigrationRule3_exposer = LatticeBasedMigrationRule3_exposer_t( "LatticeBasedMigrationRule3", bp::init< >() );
        bp::scope LatticeBasedMigrationRule3_scope( LatticeBasedMigrationRule3_exposer );
        { //::LatticeBasedMigrationRule< 3 >::Create
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< LatticeBasedMigrationRule< 3 > > ( *Create_function_type )(  );
            
            LatticeBasedMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::LatticeBasedMigrationRule< 3 >::Create ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetIndices
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( LatticeBasedMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            LatticeBasedMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::LatticeBasedMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&LatticeBasedMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef int ( LatticeBasedMigrationRule_less__3__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            LatticeBasedMigrationRule3_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &LatticeBasedMigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetNeighbourMovementProbabilities
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< double > ( LatticeBasedMigrationRule_less__3__greater__wrapper::*GetNeighbourMovementProbabilities_function_type)( ::boost::shared_ptr< VesselNode< 3 > >,::std::vector< unsigned int >,unsigned int ) ;
            
            LatticeBasedMigrationRule3_exposer.def( 
                "GetNeighbourMovementProbabilities"
                , GetNeighbourMovementProbabilities_function_type( &LatticeBasedMigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementProbabilities )
                , ( bp::arg("pNode"), bp::arg("neighbourIndices"), bp::arg("gridIndex") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::SetMovementProbability
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMovementProbability_function_type)( double ) ;
            
            LatticeBasedMigrationRule3_exposer.def( 
                "SetMovementProbability"
                , SetMovementProbability_function_type( &::LatticeBasedMigrationRule< 3 >::SetMovementProbability )
                , ( bp::arg("movementProbability") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef LatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( LatticeBasedMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            LatticeBasedMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&LatticeBasedMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        LatticeBasedMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LatticeBasedMigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< LatticeBasedMigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 3 > >, boost::shared_ptr< LatticeBasedMigrationRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< CellPopulationMigrationRule< 3 > >, boost::shared_ptr< LatticeBasedMigrationRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 3 > >, boost::shared_ptr< LatticeBasedMigrationRule< 3 > > >();
    }

    { //::CellPopulationMigrationRule< 3 >
        typedef bp::class_< CellPopulationMigrationRule_less__3__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 3 > > > CellPopulationMigrationRule3_exposer_t;
        CellPopulationMigrationRule3_exposer_t CellPopulationMigrationRule3_exposer = CellPopulationMigrationRule3_exposer_t( "CellPopulationMigrationRule3", bp::init< >() );
        bp::scope CellPopulationMigrationRule3_scope( CellPopulationMigrationRule3_exposer );
        { //::CellPopulationMigrationRule< 3 >::Create
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellPopulationMigrationRule< 3 > > ( *Create_function_type )(  );
            
            CellPopulationMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::CellPopulationMigrationRule< 3 >::Create ) );
        
        }
        { //::CellPopulationMigrationRule< 3 >::GetIndices
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( CellPopulationMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::CellPopulationMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&CellPopulationMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::CellPopulationMigrationRule< 3 >::GetNeighbourMovementProbabilities
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< double > ( CellPopulationMigrationRule_less__3__greater__wrapper::*GetNeighbourMovementProbabilities_function_type)( ::boost::shared_ptr< VesselNode< 3 > >,::std::vector< unsigned int >,unsigned int ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "GetNeighbourMovementProbabilities"
                , GetNeighbourMovementProbabilities_function_type( &CellPopulationMigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementProbabilities )
                , ( bp::arg("pNode"), bp::arg("neighbourIndices"), bp::arg("gridIndex") ) );
        
        }
        { //::CellPopulationMigrationRule< 3 >::GetOccupyingVolumeFraction
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOccupyingVolumeFraction_function_type)( ::boost::shared_ptr< AbstractCellMutationState > ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "GetOccupyingVolumeFraction"
                , GetOccupyingVolumeFraction_function_type( &::CellPopulationMigrationRule< 3 >::GetOccupyingVolumeFraction )
                , ( bp::arg("mutation_state") ) );
        
        }
        { //::CellPopulationMigrationRule< 3 >::SetVolumeFraction
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVolumeFraction_function_type)( ::boost::shared_ptr< AbstractCellMutationState >,double ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "SetVolumeFraction"
                , SetVolumeFraction_function_type( &::CellPopulationMigrationRule< 3 >::SetVolumeFraction )
                , ( bp::arg("mutation_state"), bp::arg("volume_fraction") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( CellPopulationMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&CellPopulationMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex
        
            typedef CellPopulationMigrationRule< 3 > exported_class_t;
            typedef int ( CellPopulationMigrationRule_less__3__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            CellPopulationMigrationRule3_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &CellPopulationMigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        CellPopulationMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellPopulationMigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellPopulationMigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::LatticeBasedSproutingRule< 2 >
        typedef bp::class_< LatticeBasedSproutingRule_less__2__greater__wrapper, bp::bases< AbstractSproutingRule< 2 > > > LatticeBasedSproutingRule2_exposer_t;
        LatticeBasedSproutingRule2_exposer_t LatticeBasedSproutingRule2_exposer = LatticeBasedSproutingRule2_exposer_t( "LatticeBasedSproutingRule2", bp::init< >() );
        bp::scope LatticeBasedSproutingRule2_scope( LatticeBasedSproutingRule2_exposer );
        { //::LatticeBasedSproutingRule< 2 >::Create
        
            typedef LatticeBasedSproutingRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< LatticeBasedSproutingRule< 2 > > ( *Create_function_type )(  );
            
            LatticeBasedSproutingRule2_exposer.def( 
                "Create"
                , Create_function_type( &::LatticeBasedSproutingRule< 2 >::Create ) );
        
        }
        { //::LatticeBasedSproutingRule< 2 >::GetSprouts
        
            typedef LatticeBasedSproutingRule< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( LatticeBasedSproutingRule_less__2__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            LatticeBasedSproutingRule2_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::LatticeBasedSproutingRule< 2 >::GetSprouts)
                , default_GetSprouts_function_type(&LatticeBasedSproutingRule_less__2__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedSproutingRule< 2 >::SetGrid
        
            typedef LatticeBasedSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef void ( LatticeBasedSproutingRule_less__2__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            LatticeBasedSproutingRule2_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::LatticeBasedSproutingRule< 2 >::SetGrid)
                , default_SetGrid_function_type(&LatticeBasedSproutingRule_less__2__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::LatticeBasedSproutingRule< 2 >::SetTipExclusionRadius
        
            typedef LatticeBasedSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetTipExclusionRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            LatticeBasedSproutingRule2_exposer.def( 
                "SetTipExclusionRadius"
                , SetTipExclusionRadius_function_type( &::LatticeBasedSproutingRule< 2 >::SetTipExclusionRadius )
                , ( bp::arg("tipExclusionRadius") ) );
        
        }
        LatticeBasedSproutingRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LatticeBasedSproutingRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< LatticeBasedSproutingRule< 2 > >, boost::shared_ptr< AbstractSproutingRule< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 2 > >, boost::shared_ptr< LatticeBasedSproutingRule< 2 > > >();
    }

    { //::LatticeBasedSproutingRule< 3 >
        typedef bp::class_< LatticeBasedSproutingRule_less__3__greater__wrapper, bp::bases< AbstractSproutingRule< 3 > > > LatticeBasedSproutingRule3_exposer_t;
        LatticeBasedSproutingRule3_exposer_t LatticeBasedSproutingRule3_exposer = LatticeBasedSproutingRule3_exposer_t( "LatticeBasedSproutingRule3", bp::init< >() );
        bp::scope LatticeBasedSproutingRule3_scope( LatticeBasedSproutingRule3_exposer );
        { //::LatticeBasedSproutingRule< 3 >::Create
        
            typedef LatticeBasedSproutingRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< LatticeBasedSproutingRule< 3 > > ( *Create_function_type )(  );
            
            LatticeBasedSproutingRule3_exposer.def( 
                "Create"
                , Create_function_type( &::LatticeBasedSproutingRule< 3 >::Create ) );
        
        }
        { //::LatticeBasedSproutingRule< 3 >::GetSprouts
        
            typedef LatticeBasedSproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( LatticeBasedSproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            LatticeBasedSproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::LatticeBasedSproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&LatticeBasedSproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedSproutingRule< 3 >::SetGrid
        
            typedef LatticeBasedSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef void ( LatticeBasedSproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            LatticeBasedSproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::LatticeBasedSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&LatticeBasedSproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::LatticeBasedSproutingRule< 3 >::SetTipExclusionRadius
        
            typedef LatticeBasedSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetTipExclusionRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            LatticeBasedSproutingRule3_exposer.def( 
                "SetTipExclusionRadius"
                , SetTipExclusionRadius_function_type( &::LatticeBasedSproutingRule< 3 >::SetTipExclusionRadius )
                , ( bp::arg("tipExclusionRadius") ) );
        
        }
        LatticeBasedSproutingRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LatticeBasedSproutingRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< LatticeBasedSproutingRule< 3 > >, boost::shared_ptr< AbstractSproutingRule< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 3 > >, boost::shared_ptr< LatticeBasedSproutingRule< 3 > > >();
    }

    { //::OffLatticeMigrationRule< 2 >
        typedef bp::class_< OffLatticeMigrationRule_less__2__greater__wrapper, bp::bases< AbstractMigrationRule< 2 > > > OffLatticeMigrationRule2_exposer_t;
        OffLatticeMigrationRule2_exposer_t OffLatticeMigrationRule2_exposer = OffLatticeMigrationRule2_exposer_t( "OffLatticeMigrationRule2", bp::init< >() );
        bp::scope OffLatticeMigrationRule2_scope( OffLatticeMigrationRule2_exposer );
        { //::OffLatticeMigrationRule< 2 >::Create
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeMigrationRule< 2 > > ( *Create_function_type )(  );
            
            OffLatticeMigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeMigrationRule< 2 >::Create ) );
        
        }
        { //::OffLatticeMigrationRule< 2 >::GetDirections
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( OffLatticeMigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::OffLatticeMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&OffLatticeMigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 2 >::GetDirectionsForSprouts
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirectionsForSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "GetDirectionsForSprouts"
                , GetDirectionsForSprouts_function_type( &::OffLatticeMigrationRule< 2 >::GetDirectionsForSprouts )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 2 >::SetAttractionStrength
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetAttractionStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "SetAttractionStrength"
                , SetAttractionStrength_function_type( &::OffLatticeMigrationRule< 2 >::SetAttractionStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 2 >::SetChemotacticStrength
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetChemotacticStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "SetChemotacticStrength"
                , SetChemotacticStrength_function_type( &::OffLatticeMigrationRule< 2 >::SetChemotacticStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 2 >::SetSproutingVelocity
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingVelocity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "SetSproutingVelocity"
                , SetSproutingVelocity_function_type( &::OffLatticeMigrationRule< 2 >::SetSproutingVelocity )
                , ( bp::arg("velocity") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetIndices
        
            typedef OffLatticeMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( OffLatticeMigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            OffLatticeMigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&OffLatticeMigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        OffLatticeMigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeMigrationRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeMigrationRule< 2 > >, boost::shared_ptr< AbstractMigrationRule< 2 > > >();
    }

    { //::OffLatticeMigrationRule< 3 >
        typedef bp::class_< OffLatticeMigrationRule_less__3__greater__wrapper, bp::bases< AbstractMigrationRule< 3 > > > OffLatticeMigrationRule3_exposer_t;
        OffLatticeMigrationRule3_exposer_t OffLatticeMigrationRule3_exposer = OffLatticeMigrationRule3_exposer_t( "OffLatticeMigrationRule3", bp::init< >() );
        bp::scope OffLatticeMigrationRule3_scope( OffLatticeMigrationRule3_exposer );
        { //::OffLatticeMigrationRule< 3 >::Create
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeMigrationRule< 3 > > ( *Create_function_type )(  );
            
            OffLatticeMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeMigrationRule< 3 >::Create ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::GetDirections
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( OffLatticeMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::OffLatticeMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&OffLatticeMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::GetDirectionsForSprouts
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirectionsForSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetDirectionsForSprouts"
                , GetDirectionsForSprouts_function_type( &::OffLatticeMigrationRule< 3 >::GetDirectionsForSprouts )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetAttractionStrength
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetAttractionStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetAttractionStrength"
                , SetAttractionStrength_function_type( &::OffLatticeMigrationRule< 3 >::SetAttractionStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetChemotacticStrength
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetChemotacticStrength_function_type)( double ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetChemotacticStrength"
                , SetChemotacticStrength_function_type( &::OffLatticeMigrationRule< 3 >::SetChemotacticStrength )
                , ( bp::arg("strength") ) );
        
        }
        { //::OffLatticeMigrationRule< 3 >::SetSproutingVelocity
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSproutingVelocity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "SetSproutingVelocity"
                , SetSproutingVelocity_function_type( &::OffLatticeMigrationRule< 3 >::SetSproutingVelocity )
                , ( bp::arg("velocity") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetIndices
        
            typedef OffLatticeMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( OffLatticeMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::AbstractMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&OffLatticeMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        OffLatticeMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeMigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeMigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::OffLatticeSproutingRule< 2 >
        typedef bp::class_< OffLatticeSproutingRule_less__2__greater__wrapper, bp::bases< AbstractSproutingRule< 2 > > > OffLatticeSproutingRule2_exposer_t;
        OffLatticeSproutingRule2_exposer_t OffLatticeSproutingRule2_exposer = OffLatticeSproutingRule2_exposer_t( "OffLatticeSproutingRule2", bp::init< >() );
        bp::scope OffLatticeSproutingRule2_scope( OffLatticeSproutingRule2_exposer );
        { //::OffLatticeSproutingRule< 2 >::Create
        
            typedef OffLatticeSproutingRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeSproutingRule< 2 > > ( *Create_function_type )(  );
            
            OffLatticeSproutingRule2_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeSproutingRule< 2 >::Create ) );
        
        }
        { //::OffLatticeSproutingRule< 2 >::GetSprouts
        
            typedef OffLatticeSproutingRule< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( OffLatticeSproutingRule_less__2__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            OffLatticeSproutingRule2_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::OffLatticeSproutingRule< 2 >::GetSprouts)
                , default_GetSprouts_function_type(&OffLatticeSproutingRule_less__2__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 2 >::SetGrid
        
            typedef OffLatticeSproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef void ( OffLatticeSproutingRule_less__2__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            OffLatticeSproutingRule2_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 2 >::SetGrid)
                , default_SetGrid_function_type(&OffLatticeSproutingRule_less__2__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        OffLatticeSproutingRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeSproutingRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeSproutingRule< 2 > >, boost::shared_ptr< AbstractSproutingRule< 2 > > >();
    }

    { //::OffLatticeSproutingRule< 3 >
        typedef bp::class_< OffLatticeSproutingRule_less__3__greater__wrapper, bp::bases< AbstractSproutingRule< 3 > > > OffLatticeSproutingRule3_exposer_t;
        OffLatticeSproutingRule3_exposer_t OffLatticeSproutingRule3_exposer = OffLatticeSproutingRule3_exposer_t( "OffLatticeSproutingRule3", bp::init< >() );
        bp::scope OffLatticeSproutingRule3_scope( OffLatticeSproutingRule3_exposer );
        { //::OffLatticeSproutingRule< 3 >::Create
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< OffLatticeSproutingRule< 3 > > ( *Create_function_type )(  );
            
            OffLatticeSproutingRule3_exposer.def( 
                "Create"
                , Create_function_type( &::OffLatticeSproutingRule< 3 >::Create ) );
        
        }
        { //::OffLatticeSproutingRule< 3 >::GetSprouts
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( OffLatticeSproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            OffLatticeSproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::OffLatticeSproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&OffLatticeSproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractSproutingRule< 3 >::SetGrid
        
            typedef OffLatticeSproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef void ( OffLatticeSproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            OffLatticeSproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::AbstractSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&OffLatticeSproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        OffLatticeSproutingRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< OffLatticeSproutingRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< OffLatticeSproutingRule< 3 > >, boost::shared_ptr< AbstractSproutingRule< 3 > > >();
    }

    { //::Owen2011MigrationRule< 2 >
        typedef bp::class_< Owen2011MigrationRule_less__2__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 2 > > > Owen2011MigrationRule2_exposer_t;
        Owen2011MigrationRule2_exposer_t Owen2011MigrationRule2_exposer = Owen2011MigrationRule2_exposer_t( "Owen2011MigrationRule2", bp::init< >() );
        bp::scope Owen2011MigrationRule2_scope( Owen2011MigrationRule2_exposer );
        { //::Owen2011MigrationRule< 2 >::Create
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011MigrationRule< 2 > > ( *Create_function_type )(  );
            
            Owen2011MigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011MigrationRule< 2 >::Create ) );
        
        }
        { //::Owen2011MigrationRule< 2 >::GetIndices
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( Owen2011MigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            Owen2011MigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::Owen2011MigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&Owen2011MigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011MigrationRule< 2 >::SetCellChemotacticParameter
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellChemotacticParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 5, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011MigrationRule2_exposer.def( 
                "SetCellChemotacticParameter"
                , SetCellChemotacticParameter_function_type( &::Owen2011MigrationRule< 2 >::SetCellChemotacticParameter )
                , ( bp::arg("cellChemotacticParameter") ) );
        
        }
        { //::Owen2011MigrationRule< 2 >::SetCellMotilityParameter
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellMotilityParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011MigrationRule2_exposer.def( 
                "SetCellMotilityParameter"
                , SetCellMotilityParameter_function_type( &::Owen2011MigrationRule< 2 >::SetCellMotilityParameter )
                , ( bp::arg("cellMotility") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetDirections
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( Owen2011MigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            Owen2011MigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&Owen2011MigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex
        
            typedef Owen2011MigrationRule< 2 > exported_class_t;
            typedef int ( Owen2011MigrationRule_less__2__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            Owen2011MigrationRule2_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &Owen2011MigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        Owen2011MigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011MigrationRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 2 > >, boost::shared_ptr< AbstractMigrationRule< 2 > > >();
    }

    { //::Owen2011MigrationRule< 3 >
        typedef bp::class_< Owen2011MigrationRule_less__3__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 3 > > > Owen2011MigrationRule3_exposer_t;
        Owen2011MigrationRule3_exposer_t Owen2011MigrationRule3_exposer = Owen2011MigrationRule3_exposer_t( "Owen2011MigrationRule3", bp::init< >() );
        bp::scope Owen2011MigrationRule3_scope( Owen2011MigrationRule3_exposer );
        { //::Owen2011MigrationRule< 3 >::Create
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011MigrationRule< 3 > > ( *Create_function_type )(  );
            
            Owen2011MigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011MigrationRule< 3 >::Create ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::GetIndices
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( Owen2011MigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::Owen2011MigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&Owen2011MigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::SetCellChemotacticParameter
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellChemotacticParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 5, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "SetCellChemotacticParameter"
                , SetCellChemotacticParameter_function_type( &::Owen2011MigrationRule< 3 >::SetCellChemotacticParameter )
                , ( bp::arg("cellChemotacticParameter") ) );
        
        }
        { //::Owen2011MigrationRule< 3 >::SetCellMotilityParameter
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellMotilityParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "SetCellMotilityParameter"
                , SetCellMotilityParameter_function_type( &::Owen2011MigrationRule< 3 >::SetCellMotilityParameter )
                , ( bp::arg("cellMotility") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( Owen2011MigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&Owen2011MigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex
        
            typedef Owen2011MigrationRule< 3 > exported_class_t;
            typedef int ( Owen2011MigrationRule_less__3__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            Owen2011MigrationRule3_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &Owen2011MigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        Owen2011MigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011MigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011MigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::Owen2011SproutingRule< 2 >
        typedef bp::class_< Owen2011SproutingRule_less__2__greater__wrapper, bp::bases< LatticeBasedSproutingRule< 2 > > > Owen2011SproutingRule2_exposer_t;
        Owen2011SproutingRule2_exposer_t Owen2011SproutingRule2_exposer = Owen2011SproutingRule2_exposer_t( "Owen2011SproutingRule2", bp::init< >() );
        bp::scope Owen2011SproutingRule2_scope( Owen2011SproutingRule2_exposer );
        { //::Owen2011SproutingRule< 2 >::Create
        
            typedef Owen2011SproutingRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011SproutingRule< 2 > > ( *Create_function_type )(  );
            
            Owen2011SproutingRule2_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011SproutingRule< 2 >::Create ) );
        
        }
        { //::Owen2011SproutingRule< 2 >::GetSprouts
        
            typedef Owen2011SproutingRule< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( Owen2011SproutingRule_less__2__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            Owen2011SproutingRule2_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::Owen2011SproutingRule< 2 >::GetSprouts)
                , default_GetSprouts_function_type(&Owen2011SproutingRule_less__2__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011SproutingRule< 2 >::SetHalfMaxVegf
        
            typedef Owen2011SproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetHalfMaxVegf_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011SproutingRule2_exposer.def( 
                "SetHalfMaxVegf"
                , SetHalfMaxVegf_function_type( &::Owen2011SproutingRule< 2 >::SetHalfMaxVegf )
                , ( bp::arg("halfMaxVegf") ) );
        
        }
        { //::LatticeBasedSproutingRule< 2 >::SetGrid
        
            typedef Owen2011SproutingRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef void ( Owen2011SproutingRule_less__2__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            Owen2011SproutingRule2_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::LatticeBasedSproutingRule< 2 >::SetGrid)
                , default_SetGrid_function_type(&Owen2011SproutingRule_less__2__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        Owen2011SproutingRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011SproutingRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 2 > >, boost::shared_ptr< AbstractSproutingRule< 2 > > >();
    }

    { //::Owen2011SproutingRule< 3 >
        typedef bp::class_< Owen2011SproutingRule_less__3__greater__wrapper, bp::bases< LatticeBasedSproutingRule< 3 > > > Owen2011SproutingRule3_exposer_t;
        Owen2011SproutingRule3_exposer_t Owen2011SproutingRule3_exposer = Owen2011SproutingRule3_exposer_t( "Owen2011SproutingRule3", bp::init< >() );
        bp::scope Owen2011SproutingRule3_scope( Owen2011SproutingRule3_exposer );
        { //::Owen2011SproutingRule< 3 >::Create
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Owen2011SproutingRule< 3 > > ( *Create_function_type )(  );
            
            Owen2011SproutingRule3_exposer.def( 
                "Create"
                , Create_function_type( &::Owen2011SproutingRule< 3 >::Create ) );
        
        }
        { //::Owen2011SproutingRule< 3 >::GetSprouts
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( Owen2011SproutingRule_less__3__greater__wrapper::*default_GetSprouts_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            Owen2011SproutingRule3_exposer.def( 
                "GetSprouts"
                , GetSprouts_function_type(&::Owen2011SproutingRule< 3 >::GetSprouts)
                , default_GetSprouts_function_type(&Owen2011SproutingRule_less__3__greater__wrapper::default_GetSprouts)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::Owen2011SproutingRule< 3 >::SetHalfMaxVegf
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHalfMaxVegf_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Owen2011SproutingRule3_exposer.def( 
                "SetHalfMaxVegf"
                , SetHalfMaxVegf_function_type( &::Owen2011SproutingRule< 3 >::SetHalfMaxVegf )
                , ( bp::arg("halfMaxVegf") ) );
        
        }
        { //::LatticeBasedSproutingRule< 3 >::SetGrid
        
            typedef Owen2011SproutingRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef void ( Owen2011SproutingRule_less__3__greater__wrapper::*default_SetGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            Owen2011SproutingRule3_exposer.def( 
                "SetGrid"
                , SetGrid_function_type(&::LatticeBasedSproutingRule< 3 >::SetGrid)
                , default_SetGrid_function_type(&Owen2011SproutingRule_less__3__greater__wrapper::default_SetGrid)
                , ( bp::arg("pGrid") ) );
        
        }
        Owen2011SproutingRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Owen2011SproutingRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Owen2011SproutingRule< 3 > >, boost::shared_ptr< AbstractSproutingRule< 3 > > >();
    }

    bp::class_< RegressionSolver_less__2__greater__wrapper >( "RegressionSolver2", bp::init< >() )    
        .def( 
            "Increment"
            , (void ( ::RegressionSolver<2>::* )(  ))(&::RegressionSolver< 2 >::Increment)
            , (void ( RegressionSolver_less__2__greater__wrapper::* )(  ))(&RegressionSolver_less__2__greater__wrapper::default_Increment) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::RegressionSolver<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > > ))( &::RegressionSolver< 2 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) );

    bp::class_< RegressionSolver_less__3__greater__wrapper >( "RegressionSolver3", bp::init< >() )    
        .def( 
            "Increment"
            , (void ( ::RegressionSolver<3>::* )(  ))(&::RegressionSolver< 3 >::Increment)
            , (void ( RegressionSolver_less__3__greater__wrapper::* )(  ))(&RegressionSolver_less__3__greater__wrapper::default_Increment) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::RegressionSolver<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > > ))( &::RegressionSolver< 3 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) );

    { //::TipAttractionLatticeBasedMigrationRule< 2 >
        typedef bp::class_< TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 2 > > > TipAttractionLatticeBasedMigrationRule2_exposer_t;
        TipAttractionLatticeBasedMigrationRule2_exposer_t TipAttractionLatticeBasedMigrationRule2_exposer = TipAttractionLatticeBasedMigrationRule2_exposer_t( "TipAttractionLatticeBasedMigrationRule2", bp::init< >() );
        bp::scope TipAttractionLatticeBasedMigrationRule2_scope( TipAttractionLatticeBasedMigrationRule2_exposer );
        { //::TipAttractionLatticeBasedMigrationRule< 2 >::Create
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 2 > > ( *Create_function_type )(  );
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "Create"
                , Create_function_type( &::TipAttractionLatticeBasedMigrationRule< 2 >::Create ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 2 >::GetIndices
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< int > ( TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::TipAttractionLatticeBasedMigrationRule< 2 >::GetIndices)
                , default_GetIndices_function_type(&TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 2 >::SetCellChemotacticParameter
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellChemotacticParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 5, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "SetCellChemotacticParameter"
                , SetCellChemotacticParameter_function_type( &::TipAttractionLatticeBasedMigrationRule< 2 >::SetCellChemotacticParameter )
                , ( bp::arg("cellChemotacticParameter") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 2 >::SetCellMotilityParameter
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellMotilityParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "SetCellMotilityParameter"
                , SetCellMotilityParameter_function_type( &::TipAttractionLatticeBasedMigrationRule< 2 >::SetCellMotilityParameter )
                , ( bp::arg("cellMotility") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 2 >::SetUseTipAttraction
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseTipAttraction_function_type)( bool ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "SetUseTipAttraction"
                , SetUseTipAttraction_function_type( &::TipAttractionLatticeBasedMigrationRule< 2 >::SetUseTipAttraction )
                , ( bp::arg("useTipAttraction") ) );
        
        }
        { //::AbstractMigrationRule< 2 >::GetDirections
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<2> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<2> > ( TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 2 >::GetDirections)
                , default_GetDirections_function_type(&TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 2 >::GetNeighbourMovementIndex
        
            typedef TipAttractionLatticeBasedMigrationRule< 2 > exported_class_t;
            typedef int ( TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            TipAttractionLatticeBasedMigrationRule2_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &TipAttractionLatticeBasedMigrationRule_less__2__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        TipAttractionLatticeBasedMigrationRule2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 2 > >, boost::shared_ptr< AbstractMigrationRule< 2 > > >();
    }

    { //::TipAttractionLatticeBasedMigrationRule< 3 >
        typedef bp::class_< TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper, bp::bases< LatticeBasedMigrationRule< 3 > > > TipAttractionLatticeBasedMigrationRule3_exposer_t;
        TipAttractionLatticeBasedMigrationRule3_exposer_t TipAttractionLatticeBasedMigrationRule3_exposer = TipAttractionLatticeBasedMigrationRule3_exposer_t( "TipAttractionLatticeBasedMigrationRule3", bp::init< >() );
        bp::scope TipAttractionLatticeBasedMigrationRule3_scope( TipAttractionLatticeBasedMigrationRule3_exposer );
        { //::TipAttractionLatticeBasedMigrationRule< 3 >::Create
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 3 > > ( *Create_function_type )(  );
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "Create"
                , Create_function_type( &::TipAttractionLatticeBasedMigrationRule< 3 >::Create ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 3 >::GetIndices
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< int > ( exported_class_t::*GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< int > ( TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::*default_GetIndices_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "GetIndices"
                , GetIndices_function_type(&::TipAttractionLatticeBasedMigrationRule< 3 >::GetIndices)
                , default_GetIndices_function_type(&TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::default_GetIndices)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 3 >::SetCellChemotacticParameter
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellChemotacticParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 5, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "SetCellChemotacticParameter"
                , SetCellChemotacticParameter_function_type( &::TipAttractionLatticeBasedMigrationRule< 3 >::SetCellChemotacticParameter )
                , ( bp::arg("cellChemotacticParameter") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 3 >::SetCellMotilityParameter
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCellMotilityParameter_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "SetCellMotilityParameter"
                , SetCellMotilityParameter_function_type( &::TipAttractionLatticeBasedMigrationRule< 3 >::SetCellMotilityParameter )
                , ( bp::arg("cellMotility") ) );
        
        }
        { //::TipAttractionLatticeBasedMigrationRule< 3 >::SetUseTipAttraction
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseTipAttraction_function_type)( bool ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "SetUseTipAttraction"
                , SetUseTipAttraction_function_type( &::TipAttractionLatticeBasedMigrationRule< 3 >::SetUseTipAttraction )
                , ( bp::arg("useTipAttraction") ) );
        
        }
        { //::AbstractMigrationRule< 3 >::GetDirections
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef ::std::vector< DimensionalChastePoint<3> > ( exported_class_t::*GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            typedef ::std::vector< DimensionalChastePoint<3> > ( TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::*default_GetDirections_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "GetDirections"
                , GetDirections_function_type(&::AbstractMigrationRule< 3 >::GetDirections)
                , default_GetDirections_function_type(&TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::default_GetDirections)
                , ( bp::arg("rNodes") ) );
        
        }
        { //::LatticeBasedMigrationRule< 3 >::GetNeighbourMovementIndex
        
            typedef TipAttractionLatticeBasedMigrationRule< 3 > exported_class_t;
            typedef int ( TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::*GetNeighbourMovementIndex_function_type)( ::std::vector< double >,::std::vector< unsigned int > ) ;
            
            TipAttractionLatticeBasedMigrationRule3_exposer.def( 
                "GetNeighbourMovementIndex"
                , GetNeighbourMovementIndex_function_type( &TipAttractionLatticeBasedMigrationRule_less__3__greater__wrapper::default_GetNeighbourMovementIndex )
                , ( bp::arg("movementProbabilities"), bp::arg("neighbourIndices") ) );
        
        }
        TipAttractionLatticeBasedMigrationRule3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< TipAttractionLatticeBasedMigrationRule< 3 > >, boost::shared_ptr< AbstractMigrationRule< 3 > > >();
    }

    { //::WallShearStressBasedRegressionSolver< 2 >
        typedef bp::class_< WallShearStressBasedRegressionSolver_less__2__greater__wrapper, bp::bases< RegressionSolver< 2 > > > WallShearStressBasedRegressionSolver2_exposer_t;
        WallShearStressBasedRegressionSolver2_exposer_t WallShearStressBasedRegressionSolver2_exposer = WallShearStressBasedRegressionSolver2_exposer_t( "WallShearStressBasedRegressionSolver2", bp::init< >() );
        bp::scope WallShearStressBasedRegressionSolver2_scope( WallShearStressBasedRegressionSolver2_exposer );
        { //::WallShearStressBasedRegressionSolver< 2 >::Create
        
            typedef WallShearStressBasedRegressionSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< WallShearStressBasedRegressionSolver< 2 > > ( *Create_function_type )(  );
            
            WallShearStressBasedRegressionSolver2_exposer.def( 
                "Create"
                , Create_function_type( &::WallShearStressBasedRegressionSolver< 2 >::Create ) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 2 >::Increment
        
            typedef WallShearStressBasedRegressionSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Increment_function_type)(  ) ;
            typedef void ( WallShearStressBasedRegressionSolver_less__2__greater__wrapper::*default_Increment_function_type)(  ) ;
            
            WallShearStressBasedRegressionSolver2_exposer.def( 
                "Increment"
                , Increment_function_type(&::WallShearStressBasedRegressionSolver< 2 >::Increment)
                , default_Increment_function_type(&WallShearStressBasedRegressionSolver_less__2__greater__wrapper::default_Increment) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 2 >::SetLowWallShearStressThreshold
        
            typedef WallShearStressBasedRegressionSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLowWallShearStressThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            WallShearStressBasedRegressionSolver2_exposer.def( 
                "SetLowWallShearStressThreshold"
                , SetLowWallShearStressThreshold_function_type( &::WallShearStressBasedRegressionSolver< 2 >::SetLowWallShearStressThreshold )
                , ( bp::arg("threshold") ) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 2 >::SetMaximumTimeWithLowWallShearStress
        
            typedef WallShearStressBasedRegressionSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMaximumTimeWithLowWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            WallShearStressBasedRegressionSolver2_exposer.def( 
                "SetMaximumTimeWithLowWallShearStress"
                , SetMaximumTimeWithLowWallShearStress_function_type( &::WallShearStressBasedRegressionSolver< 2 >::SetMaximumTimeWithLowWallShearStress )
                , ( bp::arg("time") ) );
        
        }
        WallShearStressBasedRegressionSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< WallShearStressBasedRegressionSolver<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< WallShearStressBasedRegressionSolver< 2 > >, boost::shared_ptr< RegressionSolver< 2 > > >();
    }

    { //::WallShearStressBasedRegressionSolver< 3 >
        typedef bp::class_< WallShearStressBasedRegressionSolver_less__3__greater__wrapper, bp::bases< RegressionSolver< 3 > > > WallShearStressBasedRegressionSolver3_exposer_t;
        WallShearStressBasedRegressionSolver3_exposer_t WallShearStressBasedRegressionSolver3_exposer = WallShearStressBasedRegressionSolver3_exposer_t( "WallShearStressBasedRegressionSolver3", bp::init< >() );
        bp::scope WallShearStressBasedRegressionSolver3_scope( WallShearStressBasedRegressionSolver3_exposer );
        { //::WallShearStressBasedRegressionSolver< 3 >::Create
        
            typedef WallShearStressBasedRegressionSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< WallShearStressBasedRegressionSolver< 3 > > ( *Create_function_type )(  );
            
            WallShearStressBasedRegressionSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::WallShearStressBasedRegressionSolver< 3 >::Create ) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 3 >::Increment
        
            typedef WallShearStressBasedRegressionSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Increment_function_type)(  ) ;
            typedef void ( WallShearStressBasedRegressionSolver_less__3__greater__wrapper::*default_Increment_function_type)(  ) ;
            
            WallShearStressBasedRegressionSolver3_exposer.def( 
                "Increment"
                , Increment_function_type(&::WallShearStressBasedRegressionSolver< 3 >::Increment)
                , default_Increment_function_type(&WallShearStressBasedRegressionSolver_less__3__greater__wrapper::default_Increment) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 3 >::SetLowWallShearStressThreshold
        
            typedef WallShearStressBasedRegressionSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLowWallShearStressThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            WallShearStressBasedRegressionSolver3_exposer.def( 
                "SetLowWallShearStressThreshold"
                , SetLowWallShearStressThreshold_function_type( &::WallShearStressBasedRegressionSolver< 3 >::SetLowWallShearStressThreshold )
                , ( bp::arg("threshold") ) );
        
        }
        { //::WallShearStressBasedRegressionSolver< 3 >::SetMaximumTimeWithLowWallShearStress
        
            typedef WallShearStressBasedRegressionSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMaximumTimeWithLowWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            WallShearStressBasedRegressionSolver3_exposer.def( 
                "SetMaximumTimeWithLowWallShearStress"
                , SetMaximumTimeWithLowWallShearStress_function_type( &::WallShearStressBasedRegressionSolver< 3 >::SetMaximumTimeWithLowWallShearStress )
                , ( bp::arg("time") ) );
        
        }
        WallShearStressBasedRegressionSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< WallShearStressBasedRegressionSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< WallShearStressBasedRegressionSolver< 3 > >, boost::shared_ptr< RegressionSolver< 3 > > >();
    }
}
