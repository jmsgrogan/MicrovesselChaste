// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/map.hpp"

#include "pde_headers.hpp"

namespace bp = boost::python;

struct AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper : AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >, bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > {

    AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper( )
    : AbstractDiscreteContinuumLinearEllipticPde<2, 2>( )
      , bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

};

struct AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper : AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >, bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > {

    AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : AbstractDiscreteContinuumLinearEllipticPde<3, 3>( )
      , bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

};

struct AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper : AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >, bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > {

    AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper( )
    : AbstractDiscreteContinuumNonLinearEllipticPde<2, 2>( )
      , bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" );
        return func_ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" );
        return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ){
        bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" );
        return func_ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

};

struct AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper : AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >, bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > {

    AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : AbstractDiscreteContinuumNonLinearEllipticPde<3, 3>( )
      , bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" );
        return func_ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" );
        return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ){
        bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" );
        return func_ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

};

struct AbstractDiscreteContinuumSolver_less__2__greater__wrapper : AbstractDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractDiscreteContinuumSolver< 2 > > {

    AbstractDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pMesh );
    }

    virtual void Setup(  ){
        bp::override func_Setup = this->get_override( "Setup" );
        func_Setup(  );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ){
        bp::override func_Update = this->get_override( "Update" );
        func_Update(  );
    }

    virtual void UpdateCellData(  ){
        bp::override func_UpdateCellData = this->get_override( "UpdateCellData" );
        func_UpdateCellData(  );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ){
        bp::override func_Write = this->get_override( "Write" );
        func_Write(  );
    }

};

struct AbstractDiscreteContinuumSolver_less__3__greater__wrapper : AbstractDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractDiscreteContinuumSolver< 3 > > {

    AbstractDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pMesh );
    }

    virtual void Setup(  ){
        bp::override func_Setup = this->get_override( "Setup" );
        func_Setup(  );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ){
        bp::override func_Update = this->get_override( "Update" );
        func_Update(  );
    }

    virtual void UpdateCellData(  ){
        bp::override func_UpdateCellData = this->get_override( "UpdateCellData" );
        func_UpdateCellData(  );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ){
        bp::override func_Write = this->get_override( "Write" );
        func_Write(  );
    }

};

struct AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper : AbstractRegularGridDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 2 > > {

    AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractRegularGridDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

};

struct AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper : AbstractRegularGridDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > > {

    AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractRegularGridDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

};

struct AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper : AbstractUnstructuredGridDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > {

    AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractUnstructuredGridDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

};

struct AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper : AbstractUnstructuredGridDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > {

    AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractUnstructuredGridDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

};

struct DiscreteSource_less__2__greater__wrapper : DiscreteSource< 2 >, bp::wrapper< DiscreteSource< 2 > > {

    DiscreteSource_less__2__greater__wrapper(DiscreteSource<2> const & arg )
    : DiscreteSource<2>( arg )
      , bp::wrapper< DiscreteSource< 2 > >(){
        // copy constructor
        
    }

    DiscreteSource_less__2__greater__wrapper( )
    : DiscreteSource<2>( )
      , bp::wrapper< DiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->DiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return DiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return DiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->DiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return DiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return DiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

};

struct CellBasedDiscreteSource_less__2__greater__wrapper : CellBasedDiscreteSource< 2 >, bp::wrapper< CellBasedDiscreteSource< 2 > > {

    CellBasedDiscreteSource_less__2__greater__wrapper(CellBasedDiscreteSource<2> const & arg )
    : CellBasedDiscreteSource<2>( arg )
      , bp::wrapper< CellBasedDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    CellBasedDiscreteSource_less__2__greater__wrapper( )
    : CellBasedDiscreteSource<2>( )
      , bp::wrapper< CellBasedDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

};

struct DiscreteSource_less__3__greater__wrapper : DiscreteSource< 3 >, bp::wrapper< DiscreteSource< 3 > > {

    DiscreteSource_less__3__greater__wrapper(DiscreteSource<3> const & arg )
    : DiscreteSource<3>( arg )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // copy constructor
        
    }

    DiscreteSource_less__3__greater__wrapper( )
    : DiscreteSource<3>( )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->DiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return DiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return DiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->DiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return DiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return DiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

};

struct CellBasedDiscreteSource_less__3__greater__wrapper : CellBasedDiscreteSource< 3 >, bp::wrapper< CellBasedDiscreteSource< 3 > > {

    CellBasedDiscreteSource_less__3__greater__wrapper(CellBasedDiscreteSource<3> const & arg )
    : CellBasedDiscreteSource<3>( arg )
      , bp::wrapper< CellBasedDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    CellBasedDiscreteSource_less__3__greater__wrapper( )
    : CellBasedDiscreteSource<3>( )
      , bp::wrapper< CellBasedDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

};

struct CellStateDependentDiscreteSource_less__2__greater__wrapper : CellStateDependentDiscreteSource< 2 >, bp::wrapper< CellStateDependentDiscreteSource< 2 > > {

    CellStateDependentDiscreteSource_less__2__greater__wrapper(CellStateDependentDiscreteSource<2> const & arg )
    : CellStateDependentDiscreteSource<2>( arg )
      , bp::wrapper< CellStateDependentDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    CellStateDependentDiscreteSource_less__2__greater__wrapper( )
    : CellStateDependentDiscreteSource<2>( )
      , bp::wrapper< CellStateDependentDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

};

struct CellStateDependentDiscreteSource_less__3__greater__wrapper : CellStateDependentDiscreteSource< 3 >, bp::wrapper< CellStateDependentDiscreteSource< 3 > > {

    CellStateDependentDiscreteSource_less__3__greater__wrapper(CellStateDependentDiscreteSource<3> const & arg )
    : CellStateDependentDiscreteSource<3>( arg )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    CellStateDependentDiscreteSource_less__3__greater__wrapper( )
    : CellStateDependentDiscreteSource<3>( )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

};

struct FiniteDifferenceSolver_less__2__greater__wrapper : FiniteDifferenceSolver< 2 >, bp::wrapper< FiniteDifferenceSolver< 2 > > {

    FiniteDifferenceSolver_less__2__greater__wrapper(FiniteDifferenceSolver<2> const & arg )
    : FiniteDifferenceSolver<2>( arg )
      , bp::wrapper< FiniteDifferenceSolver< 2 > >(){
        // copy constructor
        
    }

    FiniteDifferenceSolver_less__2__greater__wrapper( )
    : FiniteDifferenceSolver<2>( )
      , bp::wrapper< FiniteDifferenceSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteDifferenceSolver< 2 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteDifferenceSolver< 2 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteDifferenceSolver< 2 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FiniteDifferenceSolver_less__3__greater__wrapper : FiniteDifferenceSolver< 3 >, bp::wrapper< FiniteDifferenceSolver< 3 > > {

    FiniteDifferenceSolver_less__3__greater__wrapper(FiniteDifferenceSolver<3> const & arg )
    : FiniteDifferenceSolver<3>( arg )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteDifferenceSolver_less__3__greater__wrapper( )
    : FiniteDifferenceSolver<3>( )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteDifferenceSolver< 3 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteDifferenceSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteDifferenceSolver< 3 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct FiniteElementSolver_less__2__greater__wrapper : FiniteElementSolver< 2 >, bp::wrapper< FiniteElementSolver< 2 > > {

    FiniteElementSolver_less__2__greater__wrapper(FiniteElementSolver<2> const & arg )
    : FiniteElementSolver<2>( arg )
      , bp::wrapper< FiniteElementSolver< 2 > >(){
        // copy constructor
        
    }

    FiniteElementSolver_less__2__greater__wrapper( )
    : FiniteElementSolver<2>( )
      , bp::wrapper< FiniteElementSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteElementSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteElementSolver< 2 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteElementSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteElementSolver< 2 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FiniteElementSolver_less__3__greater__wrapper : FiniteElementSolver< 3 >, bp::wrapper< FiniteElementSolver< 3 > > {

    FiniteElementSolver_less__3__greater__wrapper(FiniteElementSolver<3> const & arg )
    : FiniteElementSolver<3>( arg )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteElementSolver_less__3__greater__wrapper( )
    : FiniteElementSolver<3>( )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteElementSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteElementSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteElementSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteElementSolver< 3 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct FunctionMap_less__2__greater__wrapper : FunctionMap< 2 >, bp::wrapper< FunctionMap< 2 > > {

    FunctionMap_less__2__greater__wrapper(FunctionMap<2> const & arg )
    : FunctionMap<2>( arg )
      , bp::wrapper< FunctionMap< 2 > >(){
        // copy constructor
        
    }

    FunctionMap_less__2__greater__wrapper( )
    : FunctionMap<2>( )
      , bp::wrapper< FunctionMap< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FunctionMap< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FunctionMap< 2 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FunctionMap_less__3__greater__wrapper : FunctionMap< 3 >, bp::wrapper< FunctionMap< 3 > > {

    FunctionMap_less__3__greater__wrapper(FunctionMap<3> const & arg )
    : FunctionMap<3>( arg )
      , bp::wrapper< FunctionMap< 3 > >(){
        // copy constructor
        
    }

    FunctionMap_less__3__greater__wrapper( )
    : FunctionMap<3>( )
      , bp::wrapper< FunctionMap< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FunctionMap< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FunctionMap< 3 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct GreensFunctionSolver_less__2__greater__wrapper : GreensFunctionSolver< 2 >, bp::wrapper< GreensFunctionSolver< 2 > > {

    GreensFunctionSolver_less__2__greater__wrapper(GreensFunctionSolver<2> const & arg )
    : GreensFunctionSolver<2>( arg )
      , bp::wrapper< GreensFunctionSolver< 2 > >(){
        // copy constructor
        
    }

    GreensFunctionSolver_less__2__greater__wrapper( )
    : GreensFunctionSolver<2>( )
      , bp::wrapper< GreensFunctionSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->GreensFunctionSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        GreensFunctionSolver< 2 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct GreensFunctionSolver_less__3__greater__wrapper : GreensFunctionSolver< 3 >, bp::wrapper< GreensFunctionSolver< 3 > > {

    GreensFunctionSolver_less__3__greater__wrapper(GreensFunctionSolver<3> const & arg )
    : GreensFunctionSolver<3>( arg )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // copy constructor
        
    }

    GreensFunctionSolver_less__3__greater__wrapper( )
    : GreensFunctionSolver<3>( )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->GreensFunctionSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        GreensFunctionSolver< 3 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper : LinearSteadyStateDiffusionReactionPde< 2, 2 >, bp::wrapper< LinearSteadyStateDiffusionReactionPde< 2, 2 > > {

    LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper(LinearSteadyStateDiffusionReactionPde<2, 2> const & arg )
    : LinearSteadyStateDiffusionReactionPde<2, 2>( arg )
      , bp::wrapper< LinearSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // copy constructor
        
    }

    LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper( )
    : LinearSteadyStateDiffusionReactionPde<2, 2>( )
      , bp::wrapper< LinearSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->LinearSteadyStateDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        LinearSteadyStateDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

};

struct LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper : LinearSteadyStateDiffusionReactionPde< 3, 3 >, bp::wrapper< LinearSteadyStateDiffusionReactionPde< 3, 3 > > {

    LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper(LinearSteadyStateDiffusionReactionPde<3, 3> const & arg )
    : LinearSteadyStateDiffusionReactionPde<3, 3>( arg )
      , bp::wrapper< LinearSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // copy constructor
        
    }

    LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper( )
    : LinearSteadyStateDiffusionReactionPde<3, 3>( )
      , bp::wrapper< LinearSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->LinearSteadyStateDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        LinearSteadyStateDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

};

struct MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper : MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >, bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > > {

    MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper(MichaelisMentenSteadyStateDiffusionReactionPde<2, 2> const & arg )
    : MichaelisMentenSteadyStateDiffusionReactionPde<2, 2>( arg )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // copy constructor
        
    }

    MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper( )
    : MichaelisMentenSteadyStateDiffusionReactionPde<2, 2>( )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" ) )
            return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ) {
        if( bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" ) )
            return func_ComputeLinearSourceTerm( boost::ref(rX) );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm( boost::ref(rX) );
        }
    }
    
    double default_ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

};

struct MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper : MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >, bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > > {

    MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper(MichaelisMentenSteadyStateDiffusionReactionPde<3, 3> const & arg )
    : MichaelisMentenSteadyStateDiffusionReactionPde<3, 3>( arg )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // copy constructor
        
    }

    MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper( )
    : MichaelisMentenSteadyStateDiffusionReactionPde<3, 3>( )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" ) )
            return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        if( bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" ) )
            return func_ComputeLinearSourceTerm( boost::ref(rX) );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
        }
    }
    
    double default_ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

};

struct SolutionDependentDiscreteSource_less__2__greater__wrapper : SolutionDependentDiscreteSource< 2 >, bp::wrapper< SolutionDependentDiscreteSource< 2 > > {

    SolutionDependentDiscreteSource_less__2__greater__wrapper(SolutionDependentDiscreteSource<2> const & arg )
    : SolutionDependentDiscreteSource<2>( arg )
      , bp::wrapper< SolutionDependentDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    SolutionDependentDiscreteSource_less__2__greater__wrapper( )
    : SolutionDependentDiscreteSource<2>( )
      , bp::wrapper< SolutionDependentDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

};

struct SolutionDependentDiscreteSource_less__3__greater__wrapper : SolutionDependentDiscreteSource< 3 >, bp::wrapper< SolutionDependentDiscreteSource< 3 > > {

    SolutionDependentDiscreteSource_less__3__greater__wrapper(SolutionDependentDiscreteSource<3> const & arg )
    : SolutionDependentDiscreteSource<3>( arg )
      , bp::wrapper< SolutionDependentDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    SolutionDependentDiscreteSource_less__3__greater__wrapper( )
    : SolutionDependentDiscreteSource<3>( )
      , bp::wrapper< SolutionDependentDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

};

struct VesselBasedDiscreteSource_less__2__greater__wrapper : VesselBasedDiscreteSource< 2 >, bp::wrapper< VesselBasedDiscreteSource< 2 > > {

    VesselBasedDiscreteSource_less__2__greater__wrapper(VesselBasedDiscreteSource<2> const & arg )
    : VesselBasedDiscreteSource<2>( arg )
      , bp::wrapper< VesselBasedDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    VesselBasedDiscreteSource_less__2__greater__wrapper( )
    : VesselBasedDiscreteSource<2>( )
      , bp::wrapper< VesselBasedDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

};

struct VesselBasedDiscreteSource_less__3__greater__wrapper : VesselBasedDiscreteSource< 3 >, bp::wrapper< VesselBasedDiscreteSource< 3 > > {

    VesselBasedDiscreteSource_less__3__greater__wrapper(VesselBasedDiscreteSource<3> const & arg )
    : VesselBasedDiscreteSource<3>( arg )
      , bp::wrapper< VesselBasedDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    VesselBasedDiscreteSource_less__3__greater__wrapper( )
    : VesselBasedDiscreteSource<3>( )
      , bp::wrapper< VesselBasedDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 2 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< DiscreteSource< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< DiscreteSource< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_MicrovesselChaste_pde){
    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
<<<<<<< HEAD
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_", "" );
=======
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::shared_ptr<DiscreteSource<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<DiscreteSource<3> > > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<DiscreteSource<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<DiscreteSource<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<DiscreteSource<2> > > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<DiscreteSource<2> > > >() );
    }

    { //::std::vector< DimensionalChastePoint<3> >
        typedef bp::class_< std::vector< DimensionalChastePoint<3> > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<3> > >() );
    }

    { //::std::vector< DimensionalChastePoint<2> >
        typedef bp::class_< std::vector< DimensionalChastePoint<2> > > __type_exposer_t;
<<<<<<< HEAD
        __type_exposer_t __type_exposer = __type_exposer_t( "__type", "" );
=======
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<2> > >() );
    }

<<<<<<< HEAD
    { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t;
        AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde2_2", "", bp::init< >("Constructor\n/") );
=======
    { //::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > MapUnsigned_ConcentrationFlowRate_exposer_t;
        MapUnsigned_ConcentrationFlowRate_exposer_t MapUnsigned_ConcentrationFlowRate_exposer = MapUnsigned_ConcentrationFlowRate_exposer_t( "MapUnsigned_ConcentrationFlowRate" );
        bp::scope MapUnsigned_ConcentrationFlowRate_scope( MapUnsigned_ConcentrationFlowRate_exposer );
        MapUnsigned_ConcentrationFlowRate_exposer.def( bp::indexing::map_suite< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > MapUnsigned_Concentration_exposer_t;
        MapUnsigned_Concentration_exposer_t MapUnsigned_Concentration_exposer = MapUnsigned_Concentration_exposer_t( "MapUnsigned_Concentration" );
        bp::scope MapUnsigned_Concentration_scope( MapUnsigned_Concentration_exposer );
        MapUnsigned_Concentration_exposer.def( bp::indexing::map_suite< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t;
        AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde2_2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope AbstractDiscreteContinuumLinearEllipticPde2_2_scope( AbstractDiscreteContinuumLinearEllipticPde2_2_exposer );
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::AddDiscreteSource )
<<<<<<< HEAD
                , ( bp::arg("pDiscreteSource") )
                , "Add a discrete source to the pde\n@param pDiscreteSource a pointer the discrete source\n/" );
=======
                , ( bp::arg("pDiscreteSource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Overwritten method to return the constant in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
<<<<<<< HEAD
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm )
                , "Return the diffusion constant for isotropic diffusion\n@return the diffusion constant\n/" );
=======
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Abstract method to return the linear in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<2> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "GetDiscreteSources"
<<<<<<< HEAD
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::GetDiscreteSources )
                , "Return the collection of discrete sources\n@return vector of pointers to the discrete sources\n/" );
=======
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::GetDiscreteSources ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm )
<<<<<<< HEAD
                , ( bp::arg("constantInUTerm") )
                , "Set the continuum constant in U term\n@param constantInUTerm the continuum constant in U term\n/" );
=======
                , ( bp::arg("constantInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant )
<<<<<<< HEAD
                , ( bp::arg("diffusivity") )
                , "Set the isotropic diffusion constant\n@param diffusivity the isotropic diffusion constant\n/" );
=======
                , ( bp::arg("diffusivity") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetMesh
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetReferenceConcentration )
<<<<<<< HEAD
                , ( bp::arg("referenceConcentration") )
                , "Set the reference concentration\n@param referenceConcentration the reference concentration\n/" );
=======
                , ( bp::arg("referenceConcentration") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetUseRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("useRegularGrid") )
                , "Set whether to use a regular grid\n@param useRegularGrid whether to use a regular grid\n/" );
=======
                , ( bp::arg("useRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint<2> const &,::Element<2, 2> * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "@return computed coefficient of u in the linear part of the source term, i.e f(x) in\nDiv(D Grad u)  +  f(x)u + g(x) = 0, at a given point in space.\n@param rX The point in space\n@param pElement\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearEllipticPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > >();
    }

    { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >
        typedef bp::class_< AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t;
<<<<<<< HEAD
        AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde3_3", "", bp::init< >("Constructor\n/") );
=======
        AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde3_3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope AbstractDiscreteContinuumLinearEllipticPde3_3_scope( AbstractDiscreteContinuumLinearEllipticPde3_3_exposer );
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource )
<<<<<<< HEAD
                , ( bp::arg("pDiscreteSource") )
                , "Add a discrete source to the pde\n@param pDiscreteSource a pointer the discrete source\n/" );
=======
                , ( bp::arg("pDiscreteSource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Overwritten method to return the constant in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
<<<<<<< HEAD
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm )
                , "Return the diffusion constant for isotropic diffusion\n@return the diffusion constant\n/" );
=======
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Abstract method to return the linear in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
<<<<<<< HEAD
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources )
                , "Return the collection of discrete sources\n@return vector of pointers to the discrete sources\n/" );
=======
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
<<<<<<< HEAD
                , ( bp::arg("constantInUTerm") )
                , "Set the continuum constant in U term\n@param constantInUTerm the continuum constant in U term\n/" );
=======
                , ( bp::arg("constantInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
<<<<<<< HEAD
                , ( bp::arg("diffusivity") )
                , "Set the isotropic diffusion constant\n@param diffusivity the isotropic diffusion constant\n/" );
=======
                , ( bp::arg("diffusivity") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetReferenceConcentration )
<<<<<<< HEAD
                , ( bp::arg("referenceConcentration") )
                , "Set the reference concentration\n@param referenceConcentration the reference concentration\n/" );
=======
                , ( bp::arg("referenceConcentration") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("useRegularGrid") )
                , "Set whether to use a regular grid\n@param useRegularGrid whether to use a regular grid\n/" );
=======
                , ( bp::arg("useRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint<3> const &,::Element<3, 3> * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "@return computed coefficient of u in the linear part of the source term, i.e f(x) in\nDiv(D Grad u)  +  f(x)u + g(x) = 0, at a given point in space.\n@param rX The point in space\n@param pElement\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearEllipticPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > >();
    }

    { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t;
<<<<<<< HEAD
        AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde2_2", "", bp::init< >("Constructor\n/") );
=======
        AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde2_2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope AbstractDiscreteContinuumNonLinearEllipticPde2_2_scope( AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer );
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::AddDiscreteSource )
<<<<<<< HEAD
                , ( bp::arg("pDiscreteSource") )
                , "Add a discrete source to the pde\n@param pDiscreteSource a pointer the discrete source\n/" );
=======
                , ( bp::arg("pDiscreteSource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
<<<<<<< HEAD
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm )
                , "Return the diffusion constant for isotropic diffusion\n@return the diffusion constant\n/" );
=======
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex"), bp::arg("u") )
                , "Abstract method to return the non linear contribution to the regular grid solvers\n@param gridIndex grid index\n@param u the concentration\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex"), bp::arg("u") )
                , "Abstract method to return the non linear prime contribution to the regular grid solvers\n@param gridIndex grid index\n@param u the concentration\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<2> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "GetDiscreteSources"
<<<<<<< HEAD
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::GetDiscreteSources )
                , "Return the collection of discrete sources\n@return vector of pointers to the discrete sources\n/" );
=======
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::GetDiscreteSources ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm )
<<<<<<< HEAD
                , ( bp::arg("constantInUTerm") )
                , "Set the continuum constant in U term\n@param constantInUTerm the continuum constant in U term\n/" );
=======
                , ( bp::arg("constantInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm )
<<<<<<< HEAD
                , ( bp::arg("linearInUTerm") )
                , "Set the linear constant in U term\n@param linearInUTerm the linear constant in U term\n/" );
=======
                , ( bp::arg("linearInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant )
<<<<<<< HEAD
                , ( bp::arg("diffusivity") )
                , "Set the isotropic diffusion constant\n@param diffusivity the isotropic diffusion constant\n/" );
=======
                , ( bp::arg("diffusivity") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetMesh
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 2, 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetUseRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("useRegularGrid") )
                , "Set whether to use a regular grid\n@param useRegularGrid whether to use a regular grid\n/" );
=======
                , ( bp::arg("useRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 2, 2> ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , bp::pure_virtual( ComputeDiffusionTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed diffusion term. The diffusion tensor should be symmetric and positive definite.\n@param rX the point in space at which the diffusion term is computed.\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 2, 2> ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTermPrime"
                , bp::pure_virtual( ComputeDiffusionTermPrime_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed derivative of diffusion term.\n@param rX the point in space at which the diffusion term is computed.\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeLinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint<2> const & ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearSourceTerm"
                , bp::pure_virtual( ComputeLinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeLinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX") )
                , "@return computed linear source term.\n@param rX the point in space at which the linear source term is computed\n/" );
=======
                , ( bp::arg("rX") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed nonlinear source term.\n@param rX the point in space at which the nonlinear source term is computed\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed derivative of nonlinear source term.\n@param rX the point in space at which the nonlinear source term is computed\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > >();
    }

    { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >
        typedef bp::class_< AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t;
<<<<<<< HEAD
        AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde3_3", "", bp::init< >("Constructor\n/") );
=======
        AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde3_3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope AbstractDiscreteContinuumNonLinearEllipticPde3_3_scope( AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer );
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource )
<<<<<<< HEAD
                , ( bp::arg("pDiscreteSource") )
                , "Add a discrete source to the pde\n@param pDiscreteSource a pointer the discrete source\n/" );
=======
                , ( bp::arg("pDiscreteSource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
<<<<<<< HEAD
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm )
                , "Return the diffusion constant for isotropic diffusion\n@return the diffusion constant\n/" );
=======
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex"), bp::arg("u") )
                , "Abstract method to return the non linear contribution to the regular grid solvers\n@param gridIndex grid index\n@param u the concentration\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("gridIndex"), bp::arg("u") )
                , "Abstract method to return the non linear prime contribution to the regular grid solvers\n@param gridIndex grid index\n@param u the concentration\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
<<<<<<< HEAD
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources )
                , "Return the collection of discrete sources\n@return vector of pointers to the discrete sources\n/" );
=======
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
<<<<<<< HEAD
                , ( bp::arg("constantInUTerm") )
                , "Set the continuum constant in U term\n@param constantInUTerm the continuum constant in U term\n/" );
=======
                , ( bp::arg("constantInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm )
<<<<<<< HEAD
                , ( bp::arg("linearInUTerm") )
                , "Set the linear constant in U term\n@param linearInUTerm the linear constant in U term\n/" );
=======
                , ( bp::arg("linearInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
<<<<<<< HEAD
                , ( bp::arg("diffusivity") )
                , "Set the isotropic diffusion constant\n@param diffusivity the isotropic diffusion constant\n/" );
=======
                , ( bp::arg("diffusivity") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 3, 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("useRegularGrid") )
                , "Set whether to use a regular grid\n@param useRegularGrid whether to use a regular grid\n/" );
=======
                , ( bp::arg("useRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 3, 3> ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , bp::pure_virtual( ComputeDiffusionTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed diffusion term. The diffusion tensor should be symmetric and positive definite.\n@param rX the point in space at which the diffusion term is computed.\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 3, 3> ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTermPrime"
                , bp::pure_virtual( ComputeDiffusionTermPrime_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed derivative of diffusion term.\n@param rX the point in space at which the diffusion term is computed.\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeLinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint<3> const & ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearSourceTerm"
                , bp::pure_virtual( ComputeLinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeLinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX") )
                , "@return computed linear source term.\n@param rX the point in space at which the linear source term is computed\n/" );
=======
                , ( bp::arg("rX") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTerm) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed nonlinear source term.\n@param rX the point in space at which the nonlinear source term is computed\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTermPrime) )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("u") )
                , "@return computed derivative of nonlinear source term.\n@param rX the point in space at which the nonlinear source term is computed\n@param u the value of the dependent variable at the point\n/" );
=======
                , ( bp::arg("rX"), bp::arg("u") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > >();
    }

<<<<<<< HEAD
    bp::class_< AbstractDiscreteContinuumSolver_less__2__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver2", "", bp::init< >("Constructor\n/") )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") )
            , "Add a DiscreteContinuum boundary condition for the domain\n@param pBoundaryCondition the boundary condition\n/" )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::CellPopulationIsSet )
            , "Has a cell population been set?\n@return whether a cell population been set.\n/" )    
=======
    bp::class_< AbstractDiscreteContinuumSolver_less__2__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver2", bp::init< >() )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") ) )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::CellPopulationIsSet ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
<<<<<<< HEAD
            , ( bp::arg("pGrid") )
            , "Return the value of the field at all points on the supplied grid\n@param pGrid the sampling grid\n@return the value of the field ordered according to grid order\n/" )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") )
            , "Return the value of the field at the requested points\n@param rSamplePoints a vector of sample points\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("pMesh") )
            , "Return the value of the field on the nodes of the input mesh\n@param pMesh the mesh from which nodes are sampled\n@return the value of the field ordered according to mesh node ordering\n/" )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >()
            , "Return the name of the field being solved for\n@return a reference to the field name\n/" )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetNonLinearPde )
            , "Return the nonlinear PDE\n@return the DiscreteContinuum nonlinear elliptic pde\n/" )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetPde )
            , "Return the PDE\n@return the DiscreteContinuum linear elliptic pde\n/" )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetReferenceConcentration )
            , "Return the reference concentration value.\n@return the reference concentration value\n/" )    
=======
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetNonLinearPde ) )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetPde ) )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetReferenceConcentration ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
<<<<<<< HEAD
            , ( bp::arg("rSamplePoints") )
            , "Return the value of the field at the requested points\n@param rSamplePoints the points for sampling\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pGrid") )
            , "Return the value of the field at all points on the supplied grid\n@param pGrid the grid to be sampled\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pMesh") )
            , "Return the value of the field at all points on the supplied mesh nodes\n@param pMesh the mesh for point sampling\n@return the value of the field ordered according to mesh node order\n/" )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasRegularGrid )
            , "Return true if the solver uses a regular grid to store solutions\n@return true if the solver uses a regular grid to store solutions\n/" )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasUnstructuredGrid )
            , "Return true if the solver uses a unstructured grid to store solutions\n@return true if the solver uses a unstructured grid to store solutions\n/" )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") )
            , "Set the cell population\n@param rCellPopulation a reference to the cell population\n@param cellPopulationReferenceLength the length scale for the cell population\n@param cellPopulationReferenceConcentration the concentration scale for the cell population\n/" )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") )
            , "Set the file handler containing the working directory\n@param pOutputFileHandler the file handler containing the working directory\n/" )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileName )
            , ( bp::arg("rFilename") )
            , "Set the file name for output\n@param rFilename the file name\n/" )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetLabel )
            , ( bp::arg("rLabel") )
            , "Set the name of the field being solved for\n@param rLabel a reference to the field name\n/" )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetNonLinearPde )
            , ( bp::arg("pPde") )
            , "Set the nonlinear PDE to be solved\n@param pPde the pde to be solved\n/" )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetPde )
            , ( bp::arg("pPde") )
            , "Set the PDE to be solved\n@param pPde the pde to be solved\n/" )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") )
            , "Set the reference concentration\n@param referenceConcentration the reference concentration\n/" )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") )
            , "Set the vessel network\n@param pNetwork the vessel network\n/" )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 2 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) )
            , "Set whether to write the solution to file on next solve\n@param write write the solution\n/" )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Setup) )
            , "Operations to be performed prior to the first solve\n/" )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Solve) )
            , "Do the solve\n/" )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Update) )
            , "Operations to be performed prior to every solve\n/" )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateCellData) )
            , "Set the cell data to the values in the field\n/" )    
=======
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasRegularGrid ) )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasUnstructuredGrid ) )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") ) )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") ) )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileName )
            , ( bp::arg("rFilename") ) )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetLabel )
            , ( bp::arg("rLabel") ) )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetNonLinearPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 2 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) ) )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Setup) ) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Solve) ) )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Update) ) )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateCellData) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Write) )
            , "Write the solution to file\n/" );

    bp::class_< AbstractDiscreteContinuumSolver_less__3__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver3", "", bp::init< >("Constructor\n/") )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") )
            , "Add a DiscreteContinuum boundary condition for the domain\n@param pBoundaryCondition the boundary condition\n/" )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::CellPopulationIsSet )
            , "Has a cell population been set?\n@return whether a cell population been set.\n/" )    
=======
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Write) ) );

    bp::class_< AbstractDiscreteContinuumSolver_less__3__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver3", bp::init< >() )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") ) )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::CellPopulationIsSet ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
<<<<<<< HEAD
            , ( bp::arg("pGrid") )
            , "Return the value of the field at all points on the supplied grid\n@param pGrid the sampling grid\n@return the value of the field ordered according to grid order\n/" )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") )
            , "Return the value of the field at the requested points\n@param rSamplePoints a vector of sample points\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("pMesh") )
            , "Return the value of the field on the nodes of the input mesh\n@param pMesh the mesh from which nodes are sampled\n@return the value of the field ordered according to mesh node ordering\n/" )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >()
            , "Return the name of the field being solved for\n@return a reference to the field name\n/" )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetNonLinearPde )
            , "Return the nonlinear PDE\n@return the DiscreteContinuum nonlinear elliptic pde\n/" )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetPde )
            , "Return the PDE\n@return the DiscreteContinuum linear elliptic pde\n/" )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetReferenceConcentration )
            , "Return the reference concentration value.\n@return the reference concentration value\n/" )    
=======
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetNonLinearPde ) )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetPde ) )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetReferenceConcentration ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
<<<<<<< HEAD
            , ( bp::arg("rSamplePoints") )
            , "Return the value of the field at the requested points\n@param rSamplePoints the points for sampling\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pGrid") )
            , "Return the value of the field at all points on the supplied grid\n@param pGrid the grid to be sampled\n@return the value of the field ordered according to input point order\n/" )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pMesh") )
            , "Return the value of the field at all points on the supplied mesh nodes\n@param pMesh the mesh for point sampling\n@return the value of the field ordered according to mesh node order\n/" )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasRegularGrid )
            , "Return true if the solver uses a regular grid to store solutions\n@return true if the solver uses a regular grid to store solutions\n/" )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasUnstructuredGrid )
            , "Return true if the solver uses a unstructured grid to store solutions\n@return true if the solver uses a unstructured grid to store solutions\n/" )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") )
            , "Set the cell population\n@param rCellPopulation a reference to the cell population\n@param cellPopulationReferenceLength the length scale for the cell population\n@param cellPopulationReferenceConcentration the concentration scale for the cell population\n/" )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") )
            , "Set the file handler containing the working directory\n@param pOutputFileHandler the file handler containing the working directory\n/" )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileName )
            , ( bp::arg("rFilename") )
            , "Set the file name for output\n@param rFilename the file name\n/" )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetLabel )
            , ( bp::arg("rLabel") )
            , "Set the name of the field being solved for\n@param rLabel a reference to the field name\n/" )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetNonLinearPde )
            , ( bp::arg("pPde") )
            , "Set the nonlinear PDE to be solved\n@param pPde the pde to be solved\n/" )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetPde )
            , ( bp::arg("pPde") )
            , "Set the PDE to be solved\n@param pPde the pde to be solved\n/" )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") )
            , "Set the reference concentration\n@param referenceConcentration the reference concentration\n/" )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") )
            , "Set the vessel network\n@param pNetwork the vessel network\n/" )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 3 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) )
            , "Set whether to write the solution to file on next solve\n@param write write the solution\n/" )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Setup) )
            , "Operations to be performed prior to the first solve\n/" )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Solve) )
            , "Do the solve\n/" )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Update) )
            , "Operations to be performed prior to every solve\n/" )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateCellData) )
            , "Set the cell data to the values in the field\n/" )    
=======
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasRegularGrid ) )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasUnstructuredGrid ) )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") ) )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") ) )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileName )
            , ( bp::arg("rFilename") ) )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetLabel )
            , ( bp::arg("rLabel") ) )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetNonLinearPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 3 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) ) )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Setup) ) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Solve) ) )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Update) ) )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateCellData) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Write) )
            , "Write the solution to file\n/" );

    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver2", "", bp::init< >("Constructor\n/") )    
=======
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Write) ) );

    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver2", bp::init< >() )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetGrid"
<<<<<<< HEAD
            , (::boost::shared_ptr< RegularGrid< 2 > > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetGrid )
            , "Return the grid\n@return a pointer to the structured grid\n/" )    
=======
            , (::boost::shared_ptr< RegularGrid< 2 > > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetGrid ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetGrid"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))( &::AbstractRegularGridDiscreteContinuumSolver< 2 >::SetGrid )
<<<<<<< HEAD
            , ( bp::arg("pRegularGrid") )
            , "Set the structured grid\n@param pRegularGrid the structured grid\n/" )    
=======
            , ( bp::arg("pRegularGrid") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Solve) )
            , "Overridden Update method.\n/" )    
=======
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Solve) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) );

<<<<<<< HEAD
    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver3", "", bp::init< >("Constructor\n/") )    
=======
    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver3", bp::init< >() )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetGrid"
<<<<<<< HEAD
            , (::boost::shared_ptr< RegularGrid< 3 > > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetGrid )
            , "Return the grid\n@return a pointer to the structured grid\n/" )    
=======
            , (::boost::shared_ptr< RegularGrid< 3 > > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetGrid ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetGrid"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::SetGrid )
<<<<<<< HEAD
            , ( bp::arg("pRegularGrid") )
            , "Set the structured grid\n@param pRegularGrid the structured grid\n/" )    
=======
            , ( bp::arg("pRegularGrid") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Solve) )
            , "Overridden Update method.\n/" )    
=======
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Solve) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) );

<<<<<<< HEAD
    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver2", "", bp::init< >("Constructor\n/") )    
=======
    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver2", bp::init< >() )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetConcentrationsAtCentroids"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrationsAtCentroids) )    
        .def( 
            "GetMesh"
<<<<<<< HEAD
            , (::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetMesh )
            , "Return the mesh\n@return a pointer to the mesh\n/" )    
=======
            , (::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetMesh ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetMesh"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::SetMesh )
<<<<<<< HEAD
            , ( bp::arg("pMesh") )
            , "Set the mesh\n@param pMesh the finite element mesh\n/" )    
=======
            , ( bp::arg("pMesh") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Setup"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Solve) )
            , "Overridden Update method.\n/" )    
=======
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Solve) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Update"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateElementSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateElementSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) );

<<<<<<< HEAD
    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver3", "", bp::init< >("Constructor\n/") )    
=======
    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver3", bp::init< >() )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetConcentrationsAtCentroids"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrationsAtCentroids) )    
        .def( 
            "GetMesh"
<<<<<<< HEAD
            , (::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetMesh )
            , "Return the mesh\n@return a pointer to the mesh\n/" )    
=======
            , (::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetMesh ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetMesh"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::SetMesh )
<<<<<<< HEAD
            , ( bp::arg("pMesh") )
            , "Set the mesh\n@param pMesh the finite element mesh\n/" )    
=======
            , ( bp::arg("pMesh") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Setup"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
<<<<<<< HEAD
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Solve) )
            , "Overridden Update method.\n/" )    
=======
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Solve) ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Update"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateElementSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateElementSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) );

    { //::BoundaryConditionSource
        typedef bp::class_< BoundaryConditionSource > BoundaryConditionSource_exposer_t;
<<<<<<< HEAD
        BoundaryConditionSource_exposer_t BoundaryConditionSource_exposer = BoundaryConditionSource_exposer_t( "BoundaryConditionSource", "/\nHelper struct for defining the source of the boundary condition value.\nIt can be from a data array or a single prescribed value.\n/" );
=======
        BoundaryConditionSource_exposer_t BoundaryConditionSource_exposer = BoundaryConditionSource_exposer_t( "BoundaryConditionSource" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope BoundaryConditionSource_scope( BoundaryConditionSource_exposer );
        bp::enum_< BoundaryConditionSource::Value>("Value")
            .value("LABEL_BASED", BoundaryConditionSource::LABEL_BASED)
            .value("PRESCRIBED", BoundaryConditionSource::PRESCRIBED)
            .export_values()
            ;
    }

    { //::BoundaryConditionType
        typedef bp::class_< BoundaryConditionType > BoundaryConditionType_exposer_t;
<<<<<<< HEAD
        BoundaryConditionType_exposer_t BoundaryConditionType_exposer = BoundaryConditionType_exposer_t( "BoundaryConditionType", "Helper struct for defining the type of boundary condition.\n/" );
=======
        BoundaryConditionType_exposer_t BoundaryConditionType_exposer = BoundaryConditionType_exposer_t( "BoundaryConditionType" );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope BoundaryConditionType_scope( BoundaryConditionType_exposer );
        bp::enum_< BoundaryConditionType::Value>("Value")
            .value("POINT", BoundaryConditionType::POINT)
            .value("FACET", BoundaryConditionType::FACET)
            .value("OUTER", BoundaryConditionType::OUTER)
            .value("VESSEL_LINE", BoundaryConditionType::VESSEL_LINE)
            .value("VESSEL_VOLUME", BoundaryConditionType::VESSEL_VOLUME)
            .value("CELL", BoundaryConditionType::CELL)
            .value("IN_PART", BoundaryConditionType::IN_PART)
            .export_values()
            ;
    }

    { //::DiscreteSource< 2 >
        typedef bp::class_< DiscreteSource_less__2__greater__wrapper > DiscreteSource2_exposer_t;
<<<<<<< HEAD
        DiscreteSource2_exposer_t DiscreteSource2_exposer = DiscreteSource2_exposer_t( "DiscreteSource2", "", bp::init< >("Constructor\n/") );
=======
        DiscreteSource2_exposer_t DiscreteSource2_exposer = DiscreteSource2_exposer_t( "DiscreteSource2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope DiscreteSource2_scope( DiscreteSource2_exposer );
        { //::DiscreteSource< 2 >::Create
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteSource< 2 > > ( *Create_function_type )(  );
            
            DiscreteSource2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::DiscreteSource< 2 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::DiscreteSource< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::DiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::DiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::DiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::DiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::DiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::DiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::DiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::DiscreteSource< 2 >::SetConstantInUValue
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetConstantInUValue"
                , SetConstantInUValue_function_type( &::DiscreteSource< 2 >::SetConstantInUValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::SetLabelName
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteSource2_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteSource< 2 >::SetLabelName )
<<<<<<< HEAD
                , ( bp::arg("rLabel") )
                , "Set the name of the label used in LABEL type sources\n@param rLabel the label for the source strength value\n/" );
=======
                , ( bp::arg("rLabel") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::SetLinearInUValue
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetLinearInUValue"
                , SetLinearInUValue_function_type( &::DiscreteSource< 2 >::SetLinearInUValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::SetMesh
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteSource< 2 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::SetPoints
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<2> > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteSource< 2 >::SetPoints )
<<<<<<< HEAD
                , ( bp::arg("points") )
                , "Set the points for POINT type sources\n@param points the point locations for POINT type sources\n/" );
=======
                , ( bp::arg("points") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 2 >::SetRegularGrid
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteSource< 2 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        DiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteSource<2> > >();
    }

    { //::CellBasedDiscreteSource< 2 >
        typedef bp::class_< CellBasedDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > CellBasedDiscreteSource2_exposer_t;
<<<<<<< HEAD
        CellBasedDiscreteSource2_exposer_t CellBasedDiscreteSource2_exposer = CellBasedDiscreteSource2_exposer_t( "CellBasedDiscreteSource2", "", bp::init< >("Constructor\n/") );
=======
        CellBasedDiscreteSource2_exposer_t CellBasedDiscreteSource2_exposer = CellBasedDiscreteSource2_exposer_t( "CellBasedDiscreteSource2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope CellBasedDiscreteSource2_scope( CellBasedDiscreteSource2_exposer );
        { //::CellBasedDiscreteSource< 2 >::Create
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< CellBasedDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            CellBasedDiscreteSource2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::CellBasedDiscreteSource< 2 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::CellBasedDiscreteSource< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::SetConstantInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "SetConstantInUConsumptionRatePerCell"
                , SetConstantInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 2 >::SetConstantInUConsumptionRatePerCell )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellBasedDiscreteSource< 2 >::SetLinearInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "SetLinearInUConsumptionRatePerCell"
                , SetLinearInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 2 >::SetLinearInUConsumptionRatePerCell )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        CellBasedDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellBasedDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellBasedDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::DiscreteSource< 3 >
        typedef bp::class_< DiscreteSource_less__3__greater__wrapper > DiscreteSource3_exposer_t;
<<<<<<< HEAD
        DiscreteSource3_exposer_t DiscreteSource3_exposer = DiscreteSource3_exposer_t( "DiscreteSource3", "", bp::init< >("Constructor\n/") );
=======
        DiscreteSource3_exposer_t DiscreteSource3_exposer = DiscreteSource3_exposer_t( "DiscreteSource3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope DiscreteSource3_scope( DiscreteSource3_exposer );
        { //::DiscreteSource< 3 >::Create
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteSource< 3 > > ( *Create_function_type )(  );
            
            DiscreteSource3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::DiscreteSource< 3 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::DiscreteSource< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::DiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::DiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::DiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::DiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::DiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::DiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::SetConstantInUValue
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetConstantInUValue"
                , SetConstantInUValue_function_type( &::DiscreteSource< 3 >::SetConstantInUValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::SetLabelName
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteSource3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteSource< 3 >::SetLabelName )
<<<<<<< HEAD
                , ( bp::arg("rLabel") )
                , "Set the name of the label used in LABEL type sources\n@param rLabel the label for the source strength value\n/" );
=======
                , ( bp::arg("rLabel") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::SetLinearInUValue
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetLinearInUValue"
                , SetLinearInUValue_function_type( &::DiscreteSource< 3 >::SetLinearInUValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::SetMesh
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteSource< 3 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::SetPoints
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<3> > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteSource< 3 >::SetPoints )
<<<<<<< HEAD
                , ( bp::arg("points") )
                , "Set the points for POINT type sources\n@param points the point locations for POINT type sources\n/" );
=======
                , ( bp::arg("points") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteSource< 3 >::SetRegularGrid
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteSource< 3 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        DiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteSource<3> > >();
    }

    { //::CellBasedDiscreteSource< 3 >
        typedef bp::class_< CellBasedDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > CellBasedDiscreteSource3_exposer_t;
<<<<<<< HEAD
        CellBasedDiscreteSource3_exposer_t CellBasedDiscreteSource3_exposer = CellBasedDiscreteSource3_exposer_t( "CellBasedDiscreteSource3", "", bp::init< >("Constructor\n/") );
=======
        CellBasedDiscreteSource3_exposer_t CellBasedDiscreteSource3_exposer = CellBasedDiscreteSource3_exposer_t( "CellBasedDiscreteSource3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope CellBasedDiscreteSource3_scope( CellBasedDiscreteSource3_exposer );
        { //::CellBasedDiscreteSource< 3 >::Create
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellBasedDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            CellBasedDiscreteSource3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::CellBasedDiscreteSource< 3 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::CellBasedDiscreteSource< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::SetConstantInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "SetConstantInUConsumptionRatePerCell"
                , SetConstantInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 3 >::SetConstantInUConsumptionRatePerCell )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellBasedDiscreteSource< 3 >::SetLinearInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "SetLinearInUConsumptionRatePerCell"
                , SetLinearInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 3 >::SetLinearInUConsumptionRatePerCell )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        CellBasedDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellBasedDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellBasedDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::CellStateDependentDiscreteSource< 2 >
        typedef bp::class_< CellStateDependentDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > CellStateDependentDiscreteSource2_exposer_t;
<<<<<<< HEAD
        CellStateDependentDiscreteSource2_exposer_t CellStateDependentDiscreteSource2_exposer = CellStateDependentDiscreteSource2_exposer_t( "CellStateDependentDiscreteSource2", "", bp::init< >("Constructor\n/") );
=======
        CellStateDependentDiscreteSource2_exposer_t CellStateDependentDiscreteSource2_exposer = CellStateDependentDiscreteSource2_exposer_t( "CellStateDependentDiscreteSource2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope CellStateDependentDiscreteSource2_scope( CellStateDependentDiscreteSource2_exposer );
        { //::CellStateDependentDiscreteSource< 2 >::Create
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< CellStateDependentDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::CellStateDependentDiscreteSource< 2 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::CellStateDependentDiscreteSource< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::SetStateRateMap
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "SetStateRateMap"
                , SetStateRateMap_function_type( &::CellStateDependentDiscreteSource< 2 >::SetStateRateMap )
<<<<<<< HEAD
                , ( bp::arg("stateRateMap") )
                , "Set cell 'color' specific consumption rates. 'Color' is a property of the cell mutation state set in its constructor.\nIt is up to the user to ensure that different mutation states of interest have different 'color' values assigned.\nIf a cell 'color' key is requested from the map that does not have a value assigned then its consumption rate will\nbe 0.0.\n@param stateRateMap the label for the source strength value\n/" );
=======
                , ( bp::arg("stateRateMap") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::SetStateRateThresholdMap
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateThresholdMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "SetStateRateThresholdMap"
                , SetStateRateThresholdMap_function_type( &::CellStateDependentDiscreteSource< 2 >::SetStateRateThresholdMap )
<<<<<<< HEAD
                , ( bp::arg("stateThresholdMap") )
                , "Set cell 'color' specific consumption rate thresholds.\nIf a cell 'color' key is requested from the map that does not have a value assigned then its consumption rate threshold will\nbe 0.0.\n@param stateThresholdMap the label for the source strength value\n/" );
=======
                , ( bp::arg("stateThresholdMap") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        CellStateDependentDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellStateDependentDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellStateDependentDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::CellStateDependentDiscreteSource< 3 >
        typedef bp::class_< CellStateDependentDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > CellStateDependentDiscreteSource3_exposer_t;
<<<<<<< HEAD
        CellStateDependentDiscreteSource3_exposer_t CellStateDependentDiscreteSource3_exposer = CellStateDependentDiscreteSource3_exposer_t( "CellStateDependentDiscreteSource3", "", bp::init< >("Constructor\n/") );
=======
        CellStateDependentDiscreteSource3_exposer_t CellStateDependentDiscreteSource3_exposer = CellStateDependentDiscreteSource3_exposer_t( "CellStateDependentDiscreteSource3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope CellStateDependentDiscreteSource3_scope( CellStateDependentDiscreteSource3_exposer );
        { //::CellStateDependentDiscreteSource< 3 >::Create
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellStateDependentDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::CellStateDependentDiscreteSource< 3 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::CellStateDependentDiscreteSource< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateMap"
                , SetStateRateMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateMap )
<<<<<<< HEAD
                , ( bp::arg("stateRateMap") )
                , "Set cell 'color' specific consumption rates. 'Color' is a property of the cell mutation state set in its constructor.\nIt is up to the user to ensure that different mutation states of interest have different 'color' values assigned.\nIf a cell 'color' key is requested from the map that does not have a value assigned then its consumption rate will\nbe 0.0.\n@param stateRateMap the label for the source strength value\n/" );
=======
                , ( bp::arg("stateRateMap") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateThresholdMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateThresholdMap"
                , SetStateRateThresholdMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap )
<<<<<<< HEAD
                , ( bp::arg("stateThresholdMap") )
                , "Set cell 'color' specific consumption rate thresholds.\nIf a cell 'color' key is requested from the map that does not have a value assigned then its consumption rate threshold will\nbe 0.0.\n@param stateThresholdMap the label for the source strength value\n/" );
=======
                , ( bp::arg("stateThresholdMap") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        CellStateDependentDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellStateDependentDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellStateDependentDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::DiscreteContinuumBoundaryCondition< 2 >
        typedef bp::class_< DiscreteContinuumBoundaryCondition< 2 > > DiscreteContinuumBoundaryCondition2_exposer_t;
<<<<<<< HEAD
        DiscreteContinuumBoundaryCondition2_exposer_t DiscreteContinuumBoundaryCondition2_exposer = DiscreteContinuumBoundaryCondition2_exposer_t( "DiscreteContinuumBoundaryCondition2", "", bp::init< >("Constructor\n/") );
=======
        DiscreteContinuumBoundaryCondition2_exposer_t DiscreteContinuumBoundaryCondition2_exposer = DiscreteContinuumBoundaryCondition2_exposer_t( "DiscreteContinuumBoundaryCondition2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope DiscreteContinuumBoundaryCondition2_scope( DiscreteContinuumBoundaryCondition2_exposer );
        { //::DiscreteContinuumBoundaryCondition< 2 >::Create
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 2 > > ( *Create_function_type )(  );
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::Create )
                , "Factory constructor method\n/" );
=======
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetType
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::BoundaryConditionType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetType"
<<<<<<< HEAD
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetType )
                , "Return the type of boundary condition, POINT, FACET, OUTER etc.\n@return the type of boundary condition\n/" );
=======
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetType ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetValue_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetValue"
<<<<<<< HEAD
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetValue )
                , "Return the default value of the boundary condition\n@return the default value of the boundary condition\n/" );
=======
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetValue ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::std::pair< bool, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetValue_function_type)( ::DimensionalChastePoint< 2 >,double ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetValue )
<<<<<<< HEAD
                , ( bp::arg("location"), bp::arg("tolerance") )
                , "Return the value of the boundary condition evaluated at a point and whether the point is on a boundary\n@param location the location of the point\n@param tolerance the tolerance for evaluating if a point is on a boundary\n@return a bool specifying if the point is on a boundary and the value of the point on the boundary\n/" );
=======
                , ( bp::arg("location"), bp::arg("tolerance") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetDomain
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDomain_function_type)( ::boost::shared_ptr< Part< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetDomain"
                , SetDomain_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetDomain )
<<<<<<< HEAD
                , ( bp::arg("pDomain") )
                , "Set a domain for use in the calculation of FACET type boundary conditions\n@param pDomain the part containing labelled facets for the boundary condition\n/" );
=======
                , ( bp::arg("pDomain") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetLabelName
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetLabelName )
<<<<<<< HEAD
                , ( bp::arg("label") )
                , "Set the name of the label used in LABEL type sources\n@param rLabel the label for the source strength value\n/" );
=======
                , ( bp::arg("label") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetMesh
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetNetwork
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetNetwork )
<<<<<<< HEAD
                , ( bp::arg("pNetwork") )
                , "" );
=======
                , ( bp::arg("pNetwork") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetPoints
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<2> > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetPoints )
<<<<<<< HEAD
                , ( bp::arg("points") )
                , "Set the points for POINT type boundary conditions\n@param points the point locations for POINT type boundary conditions\n/" );
=======
                , ( bp::arg("points") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetRegularGrid
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetSource
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::BoundaryConditionSource::Value ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetSource )
<<<<<<< HEAD
                , ( bp::arg("boundarySource") )
                , "Set where the value of the boundary condition is obtained, e.g. LABEL, PRESCRIBED\n@param boundarySource enum specifying where the value of the boundary condition is obtained\n/" );
=======
                , ( bp::arg("boundarySource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetType
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::BoundaryConditionType::Value ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetType )
<<<<<<< HEAD
                , ( bp::arg("boundaryType") )
                , "Set the type of boundary condition, e.g. POINT, FACET\n@param boundaryType enum specifying the type of boundary condition\n/" );
=======
                , ( bp::arg("boundaryType") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the default value of the boundary condition for any points on the boundary\n@param value the default value of the boundary condition for any points on the boundary\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateBoundaryConditionContainer
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionContainer_function_type)( ::boost::shared_ptr< BoundaryConditionsContainer< 2, 2, 1 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateBoundaryConditionContainer"
                , UpdateBoundaryConditionContainer_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateBoundaryConditionContainer )
<<<<<<< HEAD
                , ( bp::arg("pContainer") )
                , "Update the boundary conditions container for use with the finite element solver\n@param pContainer the boundary condition container\n/" );
=======
                , ( bp::arg("pContainer") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridBoundaryConditions"
                , UpdateRegularGridBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "Update the boundary conditions on the regular grid\n@param pBoundaryConditions the boundary condition container\n@param tolerance the tolerance for evaluating if a point is on a boundary\n/" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridCellBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridCellBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridCellBoundaryConditions"
                , UpdateRegularGridCellBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridCellBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridFacetBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridFacetBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridFacetBoundaryConditions"
                , UpdateRegularGridFacetBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridFacetBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPartBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPartBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridPartBoundaryConditions"
                , UpdateRegularGridPartBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPartBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPointBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPointBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridPointBoundaryConditions"
                , UpdateRegularGridPointBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPointBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridSegmentBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridSegmentBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridSegmentBoundaryConditions"
                , UpdateRegularGridSegmentBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridSegmentBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        DiscreteContinuumBoundaryCondition2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumBoundaryCondition<2> > >();
    }

    { //::DiscreteContinuumBoundaryCondition< 3 >
        typedef bp::class_< DiscreteContinuumBoundaryCondition< 3 > > DiscreteContinuumBoundaryCondition3_exposer_t;
<<<<<<< HEAD
        DiscreteContinuumBoundaryCondition3_exposer_t DiscreteContinuumBoundaryCondition3_exposer = DiscreteContinuumBoundaryCondition3_exposer_t( "DiscreteContinuumBoundaryCondition3", "", bp::init< >("Constructor\n/") );
=======
        DiscreteContinuumBoundaryCondition3_exposer_t DiscreteContinuumBoundaryCondition3_exposer = DiscreteContinuumBoundaryCondition3_exposer_t( "DiscreteContinuumBoundaryCondition3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope DiscreteContinuumBoundaryCondition3_scope( DiscreteContinuumBoundaryCondition3_exposer );
        { //::DiscreteContinuumBoundaryCondition< 3 >::Create
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::Create )
                , "Factory constructor method\n/" );
=======
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::BoundaryConditionType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetType"
<<<<<<< HEAD
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetType )
                , "Return the type of boundary condition, POINT, FACET, OUTER etc.\n@return the type of boundary condition\n/" );
=======
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetType ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetValue_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
<<<<<<< HEAD
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue )
                , "Return the default value of the boundary condition\n@return the default value of the boundary condition\n/" );
=======
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::std::pair< bool, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetValue_function_type)( ::DimensionalChastePoint< 3 >,double ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue )
<<<<<<< HEAD
                , ( bp::arg("location"), bp::arg("tolerance") )
                , "Return the value of the boundary condition evaluated at a point and whether the point is on a boundary\n@param location the location of the point\n@param tolerance the tolerance for evaluating if a point is on a boundary\n@return a bool specifying if the point is on a boundary and the value of the point on the boundary\n/" );
=======
                , ( bp::arg("location"), bp::arg("tolerance") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetDomain
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetDomain"
                , SetDomain_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetDomain )
<<<<<<< HEAD
                , ( bp::arg("pDomain") )
                , "Set a domain for use in the calculation of FACET type boundary conditions\n@param pDomain the part containing labelled facets for the boundary condition\n/" );
=======
                , ( bp::arg("pDomain") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName )
<<<<<<< HEAD
                , ( bp::arg("label") )
                , "Set the name of the label used in LABEL type sources\n@param rLabel the label for the source strength value\n/" );
=======
                , ( bp::arg("label") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetMesh
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetMesh )
<<<<<<< HEAD
                , ( bp::arg("pMesh") )
                , "Set the finite element mesh\n@param pMesh the finite element mesh\n/" );
=======
                , ( bp::arg("pMesh") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork )
<<<<<<< HEAD
                , ( bp::arg("pNetwork") )
                , "" );
=======
                , ( bp::arg("pNetwork") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetPoints
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<3> > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetPoints )
<<<<<<< HEAD
                , ( bp::arg("points") )
                , "Set the points for POINT type boundary conditions\n@param points the point locations for POINT type boundary conditions\n/" );
=======
                , ( bp::arg("points") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid )
<<<<<<< HEAD
                , ( bp::arg("pRegularGrid") )
                , "Set the regular grid\n@param pRegularGrid the regular grid\n/" );
=======
                , ( bp::arg("pRegularGrid") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetSource
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::BoundaryConditionSource::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetSource )
<<<<<<< HEAD
                , ( bp::arg("boundarySource") )
                , "Set where the value of the boundary condition is obtained, e.g. LABEL, PRESCRIBED\n@param boundarySource enum specifying where the value of the boundary condition is obtained\n/" );
=======
                , ( bp::arg("boundarySource") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::BoundaryConditionType::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetType )
<<<<<<< HEAD
                , ( bp::arg("boundaryType") )
                , "Set the type of boundary condition, e.g. POINT, FACET\n@param boundaryType enum specifying the type of boundary condition\n/" );
=======
                , ( bp::arg("boundaryType") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetValue )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the default value of the boundary condition for any points on the boundary\n@param value the default value of the boundary condition for any points on the boundary\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionContainer_function_type)( ::boost::shared_ptr< BoundaryConditionsContainer< 3, 3, 1 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateBoundaryConditionContainer"
                , UpdateBoundaryConditionContainer_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer )
<<<<<<< HEAD
                , ( bp::arg("pContainer") )
                , "Update the boundary conditions container for use with the finite element solver\n@param pContainer the boundary condition container\n/" );
=======
                , ( bp::arg("pContainer") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridBoundaryConditions"
                , UpdateRegularGridBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "Update the boundary conditions on the regular grid\n@param pBoundaryConditions the boundary condition container\n@param tolerance the tolerance for evaluating if a point is on a boundary\n/" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridCellBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridCellBoundaryConditions"
                , UpdateRegularGridCellBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridFacetBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridFacetBoundaryConditions"
                , UpdateRegularGridFacetBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPartBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPartBoundaryConditions"
                , UpdateRegularGridPartBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPointBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPointBoundaryConditions"
                , UpdateRegularGridPointBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridSegmentBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridSegmentBoundaryConditions"
                , UpdateRegularGridSegmentBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions )
<<<<<<< HEAD
                , ( bp::arg("pBoundaryConditions") )
                , "" );
=======
                , ( bp::arg("pBoundaryConditions") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        DiscreteContinuumBoundaryCondition3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumBoundaryCondition<3> > >();
    }

    { //::FiniteDifferenceSolver< 2 >
        typedef bp::class_< FiniteDifferenceSolver_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > > FiniteDifferenceSolver2_exposer_t;
<<<<<<< HEAD
        FiniteDifferenceSolver2_exposer_t FiniteDifferenceSolver2_exposer = FiniteDifferenceSolver2_exposer_t( "FiniteDifferenceSolver2", "", bp::init< >("Constructor\n/") );
=======
        FiniteDifferenceSolver2_exposer_t FiniteDifferenceSolver2_exposer = FiniteDifferenceSolver2_exposer_t( "FiniteDifferenceSolver2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FiniteDifferenceSolver2_scope( FiniteDifferenceSolver2_exposer );
        { //::FiniteDifferenceSolver< 2 >::Create
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteDifferenceSolver< 2 > > ( *Create_function_type )(  );
            
            FiniteDifferenceSolver2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FiniteDifferenceSolver< 2 >::Create )
                , "Factory constructor method\n@return a shared pointer to a new solver\n/" );
=======
                , Create_function_type( &::FiniteDifferenceSolver< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteDifferenceSolver< 2 >::GetRGBoundaryConditions
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ( exported_class_t::*GetRGBoundaryConditions_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetRGBoundaryConditions"
<<<<<<< HEAD
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 2 >::GetRGBoundaryConditions )
                , "Get the boundary conditions in the finite difference representation\n@return pointer to the vector of boundary conditions, which is pairs of whether to apply-concentration values ordered by grid index.\n/" );
=======
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 2 >::GetRGBoundaryConditions ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteDifferenceSolver< 2 >::Setup
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteDifferenceSolver< 2 >::Setup)
                , default_Setup_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::Solve
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteDifferenceSolver< 2 >::Solve)
                , default_Solve_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::Update
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteDifferenceSolver< 2 >::Update)
                , default_Update_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Update) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::UpdateBoundaryConditionsEachSolve
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionsEachSolve_function_type)( bool ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateBoundaryConditionsEachSolve"
                , UpdateBoundaryConditionsEachSolve_function_type( &::FiniteDifferenceSolver< 2 >::UpdateBoundaryConditionsEachSolve )
<<<<<<< HEAD
                , ( bp::arg("doUpdate") )
                , "Whether to update the boundary conditions on each solve\n@param doUpdate update the boundary conditions on each solve\n/" );
=======
                , ( bp::arg("doUpdate") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Write) );
        
        }
        FiniteDifferenceSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteDifferenceSolver<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FiniteDifferenceSolver< 3 >
        typedef bp::class_< FiniteDifferenceSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FiniteDifferenceSolver3_exposer_t;
<<<<<<< HEAD
        FiniteDifferenceSolver3_exposer_t FiniteDifferenceSolver3_exposer = FiniteDifferenceSolver3_exposer_t( "FiniteDifferenceSolver3", "", bp::init< >("Constructor\n/") );
=======
        FiniteDifferenceSolver3_exposer_t FiniteDifferenceSolver3_exposer = FiniteDifferenceSolver3_exposer_t( "FiniteDifferenceSolver3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FiniteDifferenceSolver3_scope( FiniteDifferenceSolver3_exposer );
        { //::FiniteDifferenceSolver< 3 >::Create
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteDifferenceSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteDifferenceSolver3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FiniteDifferenceSolver< 3 >::Create )
                , "Factory constructor method\n@return a shared pointer to a new solver\n/" );
=======
                , Create_function_type( &::FiniteDifferenceSolver< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ( exported_class_t::*GetRGBoundaryConditions_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetRGBoundaryConditions"
<<<<<<< HEAD
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions )
                , "Get the boundary conditions in the finite difference representation\n@return pointer to the vector of boundary conditions, which is pairs of whether to apply-concentration values ordered by grid index.\n/" );
=======
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteDifferenceSolver< 3 >::Setup
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteDifferenceSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Solve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteDifferenceSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Update
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteDifferenceSolver< 3 >::Update)
                , default_Update_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionsEachSolve_function_type)( bool ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateBoundaryConditionsEachSolve"
                , UpdateBoundaryConditionsEachSolve_function_type( &::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve )
<<<<<<< HEAD
                , ( bp::arg("doUpdate") )
                , "Whether to update the boundary conditions on each solve\n@param doUpdate update the boundary conditions on each solve\n/" );
=======
                , ( bp::arg("doUpdate") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Write) );
        
        }
        FiniteDifferenceSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteDifferenceSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FiniteElementSolver< 2 >
        typedef bp::class_< FiniteElementSolver_less__2__greater__wrapper, bp::bases< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > > FiniteElementSolver2_exposer_t;
<<<<<<< HEAD
        FiniteElementSolver2_exposer_t FiniteElementSolver2_exposer = FiniteElementSolver2_exposer_t( "FiniteElementSolver2", "", bp::init< >("Constructor\n/") );
=======
        FiniteElementSolver2_exposer_t FiniteElementSolver2_exposer = FiniteElementSolver2_exposer_t( "FiniteElementSolver2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FiniteElementSolver2_scope( FiniteElementSolver2_exposer );
        { //::FiniteElementSolver< 2 >::Create
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteElementSolver< 2 > > ( *Create_function_type )(  );
            
            FiniteElementSolver2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FiniteElementSolver< 2 >::Create )
                , "Construct a new instance of the class and return a shared pointer to it.\n@return a shared pointer to a class instance.\n/" );
=======
                , Create_function_type( &::FiniteElementSolver< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 2 >::SetGuess
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGuess_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetGuess"
                , SetGuess_function_type( &::FiniteElementSolver< 2 >::SetGuess )
<<<<<<< HEAD
                , ( bp::arg("guess") )
                , "Set the initial dimensionless guess\n@param guess the guess.\n/" );
=======
                , ( bp::arg("guess") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 2 >::SetUseLinearSolveForGuess
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseLinearSolveForGuess_function_type)( bool ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetUseLinearSolveForGuess"
                , SetUseLinearSolveForGuess_function_type( &::FiniteElementSolver< 2 >::SetUseLinearSolveForGuess )
<<<<<<< HEAD
                , ( bp::arg("useLinearSolve") )
                , "Use the solution from a linear solver as the initial guess\n@param useLinearSolve use the solution from a linear solver as the initial guess\n/" );
=======
                , ( bp::arg("useLinearSolve") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 2 >::SetUseSimpleNetonSolver
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSimpleNetonSolver_function_type)( bool ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetUseSimpleNetonSolver"
                , SetUseSimpleNetonSolver_function_type( &::FiniteElementSolver< 2 >::SetUseSimpleNetonSolver )
<<<<<<< HEAD
                , ( bp::arg("useNewton") )
                , "Use Chaste's simple newton solve\n@param useNewton use Chaste's simple newton solve\n/" );
=======
                , ( bp::arg("useNewton") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 2 >::Solve
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteElementSolver< 2 >::Solve)
                , default_Solve_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteElementSolver< 2 >::Update
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteElementSolver< 2 >::Update)
                , default_Update_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Update) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrationsAtCentroids_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrationsAtCentroids_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrationsAtCentroids"
                , GetConcentrationsAtCentroids_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids)
                , default_GetConcentrationsAtCentroids_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrationsAtCentroids) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup)
                , default_Setup_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateElementSolution"
                , UpdateElementSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution)
                , default_UpdateElementSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateElementSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Write) );
        
        }
        FiniteElementSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteElementSolver<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 2 > >, boost::shared_ptr< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FiniteElementSolver< 3 >
        typedef bp::class_< FiniteElementSolver_less__3__greater__wrapper, bp::bases< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > > FiniteElementSolver3_exposer_t;
<<<<<<< HEAD
        FiniteElementSolver3_exposer_t FiniteElementSolver3_exposer = FiniteElementSolver3_exposer_t( "FiniteElementSolver3", "", bp::init< >("Constructor\n/") );
=======
        FiniteElementSolver3_exposer_t FiniteElementSolver3_exposer = FiniteElementSolver3_exposer_t( "FiniteElementSolver3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FiniteElementSolver3_scope( FiniteElementSolver3_exposer );
        { //::FiniteElementSolver< 3 >::Create
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteElementSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteElementSolver3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FiniteElementSolver< 3 >::Create )
                , "Construct a new instance of the class and return a shared pointer to it.\n@return a shared pointer to a class instance.\n/" );
=======
                , Create_function_type( &::FiniteElementSolver< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 3 >::SetGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGuess_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetGuess"
                , SetGuess_function_type( &::FiniteElementSolver< 3 >::SetGuess )
<<<<<<< HEAD
                , ( bp::arg("guess") )
                , "Set the initial dimensionless guess\n@param guess the guess.\n/" );
=======
                , ( bp::arg("guess") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseLinearSolveForGuess_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseLinearSolveForGuess"
                , SetUseLinearSolveForGuess_function_type( &::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess )
<<<<<<< HEAD
                , ( bp::arg("useLinearSolve") )
                , "Use the solution from a linear solver as the initial guess\n@param useLinearSolve use the solution from a linear solver as the initial guess\n/" );
=======
                , ( bp::arg("useLinearSolve") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSimpleNetonSolver_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseSimpleNetonSolver"
                , SetUseSimpleNetonSolver_function_type( &::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver )
<<<<<<< HEAD
                , ( bp::arg("useNewton") )
                , "Use Chaste's simple newton solve\n@param useNewton use Chaste's simple newton solve\n/" );
=======
                , ( bp::arg("useNewton") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FiniteElementSolver< 3 >::Solve
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteElementSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteElementSolver< 3 >::Update
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteElementSolver< 3 >::Update)
                , default_Update_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrationsAtCentroids_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrationsAtCentroids_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrationsAtCentroids"
                , GetConcentrationsAtCentroids_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids)
                , default_GetConcentrationsAtCentroids_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrationsAtCentroids) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateElementSolution"
                , UpdateElementSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution)
                , default_UpdateElementSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateElementSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Write) );
        
        }
        FiniteElementSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteElementSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 3 > >, boost::shared_ptr< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FunctionMap< 2 >
        typedef bp::class_< FunctionMap_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > > FunctionMap2_exposer_t;
<<<<<<< HEAD
        FunctionMap2_exposer_t FunctionMap2_exposer = FunctionMap2_exposer_t( "FunctionMap2", "", bp::init< >("") );
=======
        FunctionMap2_exposer_t FunctionMap2_exposer = FunctionMap2_exposer_t( "FunctionMap2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FunctionMap2_scope( FunctionMap2_exposer );
        { //::FunctionMap< 2 >::Create
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FunctionMap< 2 > > ( *Create_function_type )(  );
            
            FunctionMap2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FunctionMap< 2 >::Create )
                , "/ Factory constructor method\n@return a shared pointer to a new solver\n/" );
=======
                , Create_function_type( &::FunctionMap< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FunctionMap< 2 >::Solve
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FunctionMap< 2 >::Solve)
                , default_Solve_function_type(&FunctionMap_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FunctionMap_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
                , default_Setup_function_type(&FunctionMap_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Update"
                , Update_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
                , default_Update_function_type(&FunctionMap_less__2__greater__wrapper::default_Update) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FunctionMap_less__2__greater__wrapper::default_Write) );
        
        }
        FunctionMap2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FunctionMap<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FunctionMap< 3 >
        typedef bp::class_< FunctionMap_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FunctionMap3_exposer_t;
<<<<<<< HEAD
        FunctionMap3_exposer_t FunctionMap3_exposer = FunctionMap3_exposer_t( "FunctionMap3", "", bp::init< >("") );
=======
        FunctionMap3_exposer_t FunctionMap3_exposer = FunctionMap3_exposer_t( "FunctionMap3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope FunctionMap3_scope( FunctionMap3_exposer );
        { //::FunctionMap< 3 >::Create
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FunctionMap< 3 > > ( *Create_function_type )(  );
            
            FunctionMap3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::FunctionMap< 3 >::Create )
                , "/ Factory constructor method\n@return a shared pointer to a new solver\n/" );
=======
                , Create_function_type( &::FunctionMap< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::FunctionMap< 3 >::Solve
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FunctionMap< 3 >::Solve)
                , default_Solve_function_type(&FunctionMap_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FunctionMap_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
                , default_Setup_function_type(&FunctionMap_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Update"
                , Update_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
                , default_Update_function_type(&FunctionMap_less__3__greater__wrapper::default_Update) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FunctionMap_less__3__greater__wrapper::default_Write) );
        
        }
        FunctionMap3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FunctionMap<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

<<<<<<< HEAD
    bp::class_< GreensFunctionSolver_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > >( "GreensFunctionSolver2", "", bp::init< >("Constructor\n/") )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 2 >::SetSubSegmentCutoff )
            , ( bp::arg("value") )
            , "Set the minimum subsegment length\n@param value the minimum subsegment length\n/" )    
=======
    bp::class_< GreensFunctionSolver_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > >( "GreensFunctionSolver2", bp::init< >() )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 2 >::SetSubSegmentCutoff )
            , ( bp::arg("value") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Solve"
            , (void ( ::GreensFunctionSolver<2>::* )(  ))(&::GreensFunctionSolver< 2 >::Solve)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Solve) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< double > & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Write) );

<<<<<<< HEAD
    bp::class_< GreensFunctionSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > >( "GreensFunctionSolver3", "", bp::init< >("Constructor\n/") )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 3 >::SetSubSegmentCutoff )
            , ( bp::arg("value") )
            , "Set the minimum subsegment length\n@param value the minimum subsegment length\n/" )    
=======
    bp::class_< GreensFunctionSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > >( "GreensFunctionSolver3", bp::init< >() )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 3 >::SetSubSegmentCutoff )
            , ( bp::arg("value") ) )    
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        .def( 
            "Solve"
            , (void ( ::GreensFunctionSolver<3>::* )(  ))(&::GreensFunctionSolver< 3 >::Solve)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Solve) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< double > & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Write) );

    { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >
        typedef bp::class_< LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > > LinearSteadyStateDiffusionReactionPde2_2_exposer_t;
<<<<<<< HEAD
        LinearSteadyStateDiffusionReactionPde2_2_exposer_t LinearSteadyStateDiffusionReactionPde2_2_exposer = LinearSteadyStateDiffusionReactionPde2_2_exposer_t( "LinearSteadyStateDiffusionReactionPde2_2", "", bp::init< >("Constructor\n/") );
=======
        LinearSteadyStateDiffusionReactionPde2_2_exposer_t LinearSteadyStateDiffusionReactionPde2_2_exposer = LinearSteadyStateDiffusionReactionPde2_2_exposer_t( "LinearSteadyStateDiffusionReactionPde2_2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope LinearSteadyStateDiffusionReactionPde2_2_scope( LinearSteadyStateDiffusionReactionPde2_2_exposer );
        { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::LinearSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >::Create
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 2, 2 > > ( *Create_function_type )(  );
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::LinearSteadyStateDiffusionReactionPde< 2, 2 >::Create )
                , "Factory Constructor\n@return a pointer to an instance of the pde\n/" );
=======
                , Create_function_type( &::LinearSteadyStateDiffusionReactionPde< 2, 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >::SetContinuumLinearInUTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::LinearSteadyStateDiffusionReactionPde< 2, 2 >::SetContinuumLinearInUTerm )
<<<<<<< HEAD
                , ( bp::arg("linearInUTerm") )
                , "Set the linear constant in U term\n@param linearInUTerm the linear constant in U term\n/" );
=======
                , ( bp::arg("linearInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::LinearSteadyStateDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Overwritten method to return the constant in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            LinearSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        LinearSteadyStateDiffusionReactionPde2_2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractLinearEllipticPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractLinearPde< 2, 2 > > >();
    }

    { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >
        typedef bp::class_< LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > > LinearSteadyStateDiffusionReactionPde3_3_exposer_t;
<<<<<<< HEAD
        LinearSteadyStateDiffusionReactionPde3_3_exposer_t LinearSteadyStateDiffusionReactionPde3_3_exposer = LinearSteadyStateDiffusionReactionPde3_3_exposer_t( "LinearSteadyStateDiffusionReactionPde3_3", "", bp::init< >("Constructor\n/") );
=======
        LinearSteadyStateDiffusionReactionPde3_3_exposer_t LinearSteadyStateDiffusionReactionPde3_3_exposer = LinearSteadyStateDiffusionReactionPde3_3_exposer_t( "LinearSteadyStateDiffusionReactionPde3_3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope LinearSteadyStateDiffusionReactionPde3_3_scope( LinearSteadyStateDiffusionReactionPde3_3_exposer );
        { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::LinearSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >::Create
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 3, 3 > > ( *Create_function_type )(  );
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::LinearSteadyStateDiffusionReactionPde< 3, 3 >::Create )
                , "Factory Constructor\n@return a pointer to an instance of the pde\n/" );
=======
                , Create_function_type( &::LinearSteadyStateDiffusionReactionPde< 3, 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::LinearSteadyStateDiffusionReactionPde< 3, 3 >::SetContinuumLinearInUTerm )
<<<<<<< HEAD
                , ( bp::arg("linearInUTerm") )
                , "Set the linear constant in U term\n@param linearInUTerm the linear constant in U term\n/" );
=======
                , ( bp::arg("linearInUTerm") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::LinearSteadyStateDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::LinearSteadyStateDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("gridIndex")=(unsigned int)(0) )
                , "Overwritten method to return the constant in U contribution to the regular grid solvers\n@param gridIndex grid index\n@return source strength\n/" );
=======
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef LinearSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            LinearSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&LinearSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        LinearSteadyStateDiffusionReactionPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractLinearEllipticPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< LinearSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractLinearPde< 3, 3 > > >();
    }

    { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >
        typedef bp::class_< MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > > MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t;
<<<<<<< HEAD
        MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer = MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde2_2", "", bp::init< >("Constructor\n/") );
=======
        MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer = MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde2_2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope MichaelisMentenSteadyStateDiffusionReactionPde2_2_scope( MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer );
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "Over-ridden method to return the constant in U contribution to the Chaste FE solver\n@param rX grid location\n@param pElement pointer to containing element\n@return source strength\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeDiffusionTermPrime"
                , ComputeDiffusionTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime)
                , default_ComputeDiffusionTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "Over-ridden method to return the linear in U contribution to the Chaste FE solver\n@param rX grid location\n@param pElement pointer to containing element\n@return source strength\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearSourceTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearSourceTerm"
                , ComputeLinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm)
                , default_ComputeLinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearSourceTerm)
                , ( bp::arg("rX") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::Create
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > > ( *Create_function_type )(  );
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::Create )
                , "Factory Constructor\n@return a pointer to an instance of the pde\n/" );
=======
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::GetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMichaelisMentenThreshold_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "GetMichaelisMentenThreshold"
<<<<<<< HEAD
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::GetMichaelisMentenThreshold )
                , "Get the concentration at half max consumption in the michaelis menten model\n@return threshold the concentration at half max consumption in the michaelis menten model\n/" );
=======
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::GetMichaelisMentenThreshold ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::SetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMichaelisMentenThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "SetMichaelisMentenThreshold"
                , SetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::SetMichaelisMentenThreshold )
<<<<<<< HEAD
                , ( bp::arg("threshold") )
                , "Set the concentration at half max consumption in the michaelis menten model\n@param threshold the concentration at half max consumption in the michaelis menten model\n/" );
=======
                , ( bp::arg("threshold") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 2 > > >();
    }

    { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >
        typedef bp::class_< MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > > MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t;
<<<<<<< HEAD
        MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer = MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde3_3", "", bp::init< >("Constructor\n/") );
=======
        MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer = MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde3_3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope MichaelisMentenSteadyStateDiffusionReactionPde3_3_scope( MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer );
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "Over-ridden method to return the constant in U contribution to the Chaste FE solver\n@param rX grid location\n@param pElement pointer to containing element\n@return source strength\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeDiffusionTermPrime"
                , ComputeDiffusionTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime)
                , default_ComputeDiffusionTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
<<<<<<< HEAD
                , ( bp::arg("rX"), bp::arg("pElement") )
                , "Over-ridden method to return the linear in U contribution to the Chaste FE solver\n@param rX grid location\n@param pElement pointer to containing element\n@return source strength\n/" );
=======
                , ( bp::arg("rX"), bp::arg("pElement") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearSourceTerm"
                , ComputeLinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm)
                , default_ComputeLinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearSourceTerm)
                , ( bp::arg("rX") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::Create
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > > ( *Create_function_type )(  );
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::Create )
                , "Factory Constructor\n@return a pointer to an instance of the pde\n/" );
=======
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::GetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMichaelisMentenThreshold_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "GetMichaelisMentenThreshold"
<<<<<<< HEAD
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::GetMichaelisMentenThreshold )
                , "Get the concentration at half max consumption in the michaelis menten model\n@return threshold the concentration at half max consumption in the michaelis menten model\n/" );
=======
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::GetMichaelisMentenThreshold ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::SetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMichaelisMentenThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "SetMichaelisMentenThreshold"
                , SetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::SetMichaelisMentenThreshold )
<<<<<<< HEAD
                , ( bp::arg("threshold") )
                , "Set the concentration at half max consumption in the michaelis menten model\n@param threshold the concentration at half max consumption in the michaelis menten model\n/" );
=======
                , ( bp::arg("threshold") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 3 > > >();
    }

    { //::SolutionDependentDiscreteSource< 2 >
        typedef bp::class_< SolutionDependentDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > SolutionDependentDiscreteSource2_exposer_t;
<<<<<<< HEAD
        SolutionDependentDiscreteSource2_exposer_t SolutionDependentDiscreteSource2_exposer = SolutionDependentDiscreteSource2_exposer_t( "SolutionDependentDiscreteSource2", "", bp::init< >("Constructor\n/") );
=======
        SolutionDependentDiscreteSource2_exposer_t SolutionDependentDiscreteSource2_exposer = SolutionDependentDiscreteSource2_exposer_t( "SolutionDependentDiscreteSource2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope SolutionDependentDiscreteSource2_scope( SolutionDependentDiscreteSource2_exposer );
        { //::SolutionDependentDiscreteSource< 2 >::Create
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< SolutionDependentDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::SolutionDependentDiscreteSource< 2 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::SolutionDependentDiscreteSource< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetConstantInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetConstantInUSinkRatePerSolutionQuantity"
                , SetConstantInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 2 >::SetConstantInUSinkRatePerSolutionQuantity )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetLinearInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetLinearInUSinkRatePerSolutionQuantity"
                , SetLinearInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 2 >::SetLinearInUSinkRatePerSolutionQuantity )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetSolution
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetSolution"
                , SetSolution_function_type( &::SolutionDependentDiscreteSource< 2 >::SetSolution )
<<<<<<< HEAD
                , ( bp::arg("solution") )
                , "Set the sampled field from which to obtain a solution for SOLUTION type sources\n@param solution the field from which to use solution values\n/" );
=======
                , ( bp::arg("solution") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        SolutionDependentDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< SolutionDependentDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< SolutionDependentDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::SolutionDependentDiscreteSource< 3 >
        typedef bp::class_< SolutionDependentDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > SolutionDependentDiscreteSource3_exposer_t;
<<<<<<< HEAD
        SolutionDependentDiscreteSource3_exposer_t SolutionDependentDiscreteSource3_exposer = SolutionDependentDiscreteSource3_exposer_t( "SolutionDependentDiscreteSource3", "", bp::init< >("Constructor\n/") );
=======
        SolutionDependentDiscreteSource3_exposer_t SolutionDependentDiscreteSource3_exposer = SolutionDependentDiscreteSource3_exposer_t( "SolutionDependentDiscreteSource3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope SolutionDependentDiscreteSource3_scope( SolutionDependentDiscreteSource3_exposer );
        { //::SolutionDependentDiscreteSource< 3 >::Create
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< SolutionDependentDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::SolutionDependentDiscreteSource< 3 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::SolutionDependentDiscreteSource< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetConstantInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetConstantInUSinkRatePerSolutionQuantity"
                , SetConstantInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 3 >::SetConstantInUSinkRatePerSolutionQuantity )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetLinearInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetLinearInUSinkRatePerSolutionQuantity"
                , SetLinearInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 3 >::SetLinearInUSinkRatePerSolutionQuantity )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetSolution
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetSolution"
                , SetSolution_function_type( &::SolutionDependentDiscreteSource< 3 >::SetSolution )
<<<<<<< HEAD
                , ( bp::arg("solution") )
                , "Set the sampled field from which to obtain a solution for SOLUTION type sources\n@param solution the field from which to use solution values\n/" );
=======
                , ( bp::arg("solution") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        SolutionDependentDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< SolutionDependentDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< SolutionDependentDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::VesselBasedDiscreteSource< 2 >
        typedef bp::class_< VesselBasedDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > VesselBasedDiscreteSource2_exposer_t;
<<<<<<< HEAD
        VesselBasedDiscreteSource2_exposer_t VesselBasedDiscreteSource2_exposer = VesselBasedDiscreteSource2_exposer_t( "VesselBasedDiscreteSource2", "", bp::init< >("Constructor\n/") );
=======
        VesselBasedDiscreteSource2_exposer_t VesselBasedDiscreteSource2_exposer = VesselBasedDiscreteSource2_exposer_t( "VesselBasedDiscreteSource2", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope VesselBasedDiscreteSource2_scope( VesselBasedDiscreteSource2_exposer );
        { //::VesselBasedDiscreteSource< 2 >::Create
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselBasedDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            VesselBasedDiscreteSource2_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::VesselBasedDiscreteSource< 2 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::VesselBasedDiscreteSource< 2 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetReferenceConcentration
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::VesselBasedDiscreteSource< 2 >::SetReferenceConcentration )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetReferenceHaematocrit
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetReferenceHaematocrit"
                , SetReferenceHaematocrit_function_type( &::VesselBasedDiscreteSource< 2 >::SetReferenceHaematocrit )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetVesselPermeability
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetVesselPermeability"
                , SetVesselPermeability_function_type( &::VesselBasedDiscreteSource< 2 >::SetVesselPermeability )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        VesselBasedDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselBasedDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselBasedDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::VesselBasedDiscreteSource< 3 >
        typedef bp::class_< VesselBasedDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > VesselBasedDiscreteSource3_exposer_t;
<<<<<<< HEAD
        VesselBasedDiscreteSource3_exposer_t VesselBasedDiscreteSource3_exposer = VesselBasedDiscreteSource3_exposer_t( "VesselBasedDiscreteSource3", "", bp::init< >("Constructor\n/") );
=======
        VesselBasedDiscreteSource3_exposer_t VesselBasedDiscreteSource3_exposer = VesselBasedDiscreteSource3_exposer_t( "VesselBasedDiscreteSource3", bp::init< >() );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        bp::scope VesselBasedDiscreteSource3_scope( VesselBasedDiscreteSource3_exposer );
        { //::VesselBasedDiscreteSource< 3 >::Create
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselBasedDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            VesselBasedDiscreteSource3_exposer.def( 
                "Create"
<<<<<<< HEAD
                , Create_function_type( &::VesselBasedDiscreteSource< 3 >::Create )
                , "Factory constructor method\n@return a pointer to an instance of the class\n/" );
=======
                , Create_function_type( &::VesselBasedDiscreteSource< 3 >::Create ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetReferenceConcentration
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::VesselBasedDiscreteSource< 3 >::SetReferenceConcentration )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetReferenceHaematocrit
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetReferenceHaematocrit"
                , SetReferenceHaematocrit_function_type( &::VesselBasedDiscreteSource< 3 >::SetReferenceHaematocrit )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetVesselPermeability
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetVesselPermeability"
                , SetVesselPermeability_function_type( &::VesselBasedDiscreteSource< 3 >::SetVesselPermeability )
<<<<<<< HEAD
                , ( bp::arg("value") )
                , "Set the value of the source for PRESCRIBED type sources\n@param value the value of the source\n/" );
=======
                , ( bp::arg("value") ) );
>>>>>>> 771a962055d447a8738a2e7efbc60beb1eaaa477
        
        }
        VesselBasedDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselBasedDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselBasedDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }
}
