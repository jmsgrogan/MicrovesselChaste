// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/map.hpp"

#include "pde_headers.hpp"

namespace bp = boost::python;

struct AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper : AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >, bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > {

    AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper( )
    : AbstractDiscreteContinuumLinearEllipticPde<2, 2>( )
      , bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

};

struct AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper : AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >, bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > {

    AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : AbstractDiscreteContinuumLinearEllipticPde<3, 3>( )
      , bp::wrapper< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

};

struct AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper : AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >, bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > {

    AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper( )
    : AbstractDiscreteContinuumNonLinearEllipticPde<2, 2>( )
      , bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" );
        return func_ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" );
        return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ){
        bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" );
        return func_ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

};

struct AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper : AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >, bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > {

    AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : AbstractDiscreteContinuumNonLinearEllipticPde<3, 3>( )
      , bp::wrapper< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" );
        return func_ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" );
        return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ){
        bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" );
        return func_ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

};

struct AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper : AbstractDiscreteContinuumParabolicPde< 2, 2 >, bp::wrapper< AbstractDiscreteContinuumParabolicPde< 2, 2 > > {

    AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper( )
    : AbstractDiscreteContinuumParabolicPde<2, 2>( )
      , bp::wrapper< AbstractDiscreteContinuumParabolicPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual void UpdateMultiplierValue(  ) {
        if( bp::override func_UpdateMultiplierValue = this->get_override( "UpdateMultiplierValue" ) )
            func_UpdateMultiplierValue(  );
        else{
            this->AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateMultiplierValue(  );
        }
    }
    
    void default_UpdateMultiplierValue(  ) {
        AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateMultiplierValue( );
    }

};

struct AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper : AbstractDiscreteContinuumParabolicPde< 3, 3 >, bp::wrapper< AbstractDiscreteContinuumParabolicPde< 3, 3 > > {

    AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper( )
    : AbstractDiscreteContinuumParabolicPde<3, 3>( )
      , bp::wrapper< AbstractDiscreteContinuumParabolicPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ){
        bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" );
        return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" );
        return func_ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ){
        bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" );
        return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual void UpdateMultiplierValue(  ) {
        if( bp::override func_UpdateMultiplierValue = this->get_override( "UpdateMultiplierValue" ) )
            func_UpdateMultiplierValue(  );
        else{
            this->AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateMultiplierValue(  );
        }
    }
    
    void default_UpdateMultiplierValue(  ) {
        AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateMultiplierValue( );
    }

};

struct AbstractDiscreteContinuumSolver_less__2__greater__wrapper : AbstractDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractDiscreteContinuumSolver< 2 > > {

    AbstractDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pMesh );
    }

    virtual void Setup(  ){
        bp::override func_Setup = this->get_override( "Setup" );
        func_Setup(  );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ){
        bp::override func_Update = this->get_override( "Update" );
        func_Update(  );
    }

    virtual void UpdateCellData(  ){
        bp::override func_UpdateCellData = this->get_override( "UpdateCellData" );
        func_UpdateCellData(  );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ){
        bp::override func_Write = this->get_override( "Write" );
        func_Write(  );
    }

};

struct AbstractDiscreteContinuumSolver_less__3__greater__wrapper : AbstractDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractDiscreteContinuumSolver< 3 > > {

    AbstractDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ){
        bp::override func_GetConcentrations = this->get_override( "GetConcentrations" );
        return func_GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ){
        bp::override func_GetSolution = this->get_override( "GetSolution" );
        return func_GetSolution( pMesh );
    }

    virtual void Setup(  ){
        bp::override func_Setup = this->get_override( "Setup" );
        func_Setup(  );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ){
        bp::override func_Update = this->get_override( "Update" );
        func_Update(  );
    }

    virtual void UpdateCellData(  ){
        bp::override func_UpdateCellData = this->get_override( "UpdateCellData" );
        func_UpdateCellData(  );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ){
        bp::override func_Write = this->get_override( "Write" );
        func_Write(  );
    }

};

struct AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper : AbstractRegularGridDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 2 > > {

    AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractRegularGridDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

};

struct AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper : AbstractRegularGridDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > > {

    AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractRegularGridDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractRegularGridDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

};

struct AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper : AbstractUnstructuredGridDiscreteContinuumSolver< 2 >, bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > {

    AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper( )
    : AbstractUnstructuredGridDiscreteContinuumSolver<2>( )
      , bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

};

struct AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper : AbstractUnstructuredGridDiscreteContinuumSolver< 3 >, bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > {

    AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper( )
    : AbstractUnstructuredGridDiscreteContinuumSolver<3>( )
      , bp::wrapper< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Solve(  ){
        bp::override func_Solve = this->get_override( "Solve" );
        func_Solve(  );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

};

struct DiscreteSource_less__2__greater__wrapper : DiscreteSource< 2 >, bp::wrapper< DiscreteSource< 2 > > {

    DiscreteSource_less__2__greater__wrapper(DiscreteSource<2> const & arg )
    : DiscreteSource<2>( arg )
      , bp::wrapper< DiscreteSource< 2 > >(){
        // copy constructor
        
    }

    DiscreteSource_less__2__greater__wrapper( )
    : DiscreteSource<2>( )
      , bp::wrapper< DiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->DiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return DiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return DiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->DiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return DiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return DiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 2 >::GetNonlinearTermRegularGridValues( );
    }

};

struct CellBasedDiscreteSource_less__2__greater__wrapper : CellBasedDiscreteSource< 2 >, bp::wrapper< CellBasedDiscreteSource< 2 > > {

    CellBasedDiscreteSource_less__2__greater__wrapper(CellBasedDiscreteSource<2> const & arg )
    : CellBasedDiscreteSource<2>( arg )
      , bp::wrapper< CellBasedDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    CellBasedDiscreteSource_less__2__greater__wrapper( )
    : CellBasedDiscreteSource<2>( )
      , bp::wrapper< CellBasedDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 2 >::GetNonlinearTermRegularGridValues( );
    }

};

struct DiscreteSource_less__3__greater__wrapper : DiscreteSource< 3 >, bp::wrapper< DiscreteSource< 3 > > {

    DiscreteSource_less__3__greater__wrapper(DiscreteSource<3> const & arg )
    : DiscreteSource<3>( arg )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // copy constructor
        
    }

    DiscreteSource_less__3__greater__wrapper( )
    : DiscreteSource<3>( )
      , bp::wrapper< DiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->DiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return DiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return DiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->DiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return DiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return DiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetNonlinearTermRegularGridValues( );
    }

};

struct CellBasedDiscreteSource_less__3__greater__wrapper : CellBasedDiscreteSource< 3 >, bp::wrapper< CellBasedDiscreteSource< 3 > > {

    CellBasedDiscreteSource_less__3__greater__wrapper(CellBasedDiscreteSource<3> const & arg )
    : CellBasedDiscreteSource<3>( arg )
      , bp::wrapper< CellBasedDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    CellBasedDiscreteSource_less__3__greater__wrapper( )
    : CellBasedDiscreteSource<3>( )
      , bp::wrapper< CellBasedDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetNonlinearTermRegularGridValues( );
    }

};

struct CellStateDependentDiscreteSource_less__2__greater__wrapper : CellStateDependentDiscreteSource< 2 >, bp::wrapper< CellStateDependentDiscreteSource< 2 > > {

    CellStateDependentDiscreteSource_less__2__greater__wrapper(CellStateDependentDiscreteSource<2> const & arg )
    : CellStateDependentDiscreteSource<2>( arg )
      , bp::wrapper< CellStateDependentDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    CellStateDependentDiscreteSource_less__2__greater__wrapper( )
    : CellStateDependentDiscreteSource<2>( )
      , bp::wrapper< CellStateDependentDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 2 >::GetNonlinearTermRegularGridValues( );
    }

};

struct CellStateDependentDiscreteSource_less__3__greater__wrapper : CellStateDependentDiscreteSource< 3 >, bp::wrapper< CellStateDependentDiscreteSource< 3 > > {

    CellStateDependentDiscreteSource_less__3__greater__wrapper(CellStateDependentDiscreteSource<3> const & arg )
    : CellStateDependentDiscreteSource<3>( arg )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    CellStateDependentDiscreteSource_less__3__greater__wrapper( )
    : CellStateDependentDiscreteSource<3>( )
      , bp::wrapper< CellStateDependentDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetNonlinearTermRegularGridValues( );
    }

};

struct CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper : CoupledVegfPelletDiffusionReactionPde< 2, 2 >, bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 2, 2 > > {

    CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper(CoupledVegfPelletDiffusionReactionPde<2, 2> const & arg )
    : CoupledVegfPelletDiffusionReactionPde<2, 2>( arg )
      , bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 2, 2 > >(){
        // copy constructor
        
    }

    CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper( )
    : CoupledVegfPelletDiffusionReactionPde<2, 2>( )
      , bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual void UpdateMultiplierValue(  ) {
        if( bp::override func_UpdateMultiplierValue = this->get_override( "UpdateMultiplierValue" ) )
            func_UpdateMultiplierValue(  );
        else{
            this->CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateMultiplierValue(  );
        }
    }
    
    void default_UpdateMultiplierValue(  ) {
        CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateMultiplierValue( );
    }

};

struct CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper : CoupledVegfPelletDiffusionReactionPde< 3, 3 >, bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 3, 3 > > {

    CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper(CoupledVegfPelletDiffusionReactionPde<3, 3> const & arg )
    : CoupledVegfPelletDiffusionReactionPde<3, 3>( arg )
      , bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 3, 3 > >(){
        // copy constructor
        
    }

    CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper( )
    : CoupledVegfPelletDiffusionReactionPde<3, 3>( )
      , bp::wrapper< CoupledVegfPelletDiffusionReactionPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual void UpdateMultiplierValue(  ) {
        if( bp::override func_UpdateMultiplierValue = this->get_override( "UpdateMultiplierValue" ) )
            func_UpdateMultiplierValue(  );
        else{
            this->CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateMultiplierValue(  );
        }
    }
    
    void default_UpdateMultiplierValue(  ) {
        CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateMultiplierValue( );
    }

};

struct FiniteDifferenceSolver_less__2__greater__wrapper : FiniteDifferenceSolver< 2 >, bp::wrapper< FiniteDifferenceSolver< 2 > > {

    FiniteDifferenceSolver_less__2__greater__wrapper(FiniteDifferenceSolver<2> const & arg )
    : FiniteDifferenceSolver<2>( arg )
      , bp::wrapper< FiniteDifferenceSolver< 2 > >(){
        // copy constructor
        
    }

    FiniteDifferenceSolver_less__2__greater__wrapper( )
    : FiniteDifferenceSolver<2>( )
      , bp::wrapper< FiniteDifferenceSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteDifferenceSolver< 2 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteDifferenceSolver< 2 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteDifferenceSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteDifferenceSolver< 2 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FiniteDifferenceSolver_less__3__greater__wrapper : FiniteDifferenceSolver< 3 >, bp::wrapper< FiniteDifferenceSolver< 3 > > {

    FiniteDifferenceSolver_less__3__greater__wrapper(FiniteDifferenceSolver<3> const & arg )
    : FiniteDifferenceSolver<3>( arg )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteDifferenceSolver_less__3__greater__wrapper( )
    : FiniteDifferenceSolver<3>( )
      , bp::wrapper< FiniteDifferenceSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        FiniteDifferenceSolver< 3 >::Setup( );
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteDifferenceSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteDifferenceSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteDifferenceSolver< 3 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct FiniteElementSolver_less__2__greater__wrapper : FiniteElementSolver< 2 >, bp::wrapper< FiniteElementSolver< 2 > > {

    FiniteElementSolver_less__2__greater__wrapper(FiniteElementSolver<2> const & arg )
    : FiniteElementSolver<2>( arg )
      , bp::wrapper< FiniteElementSolver< 2 > >(){
        // copy constructor
        
    }

    FiniteElementSolver_less__2__greater__wrapper( )
    : FiniteElementSolver<2>( )
      , bp::wrapper< FiniteElementSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteElementSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteElementSolver< 2 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteElementSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteElementSolver< 2 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FiniteElementSolver_less__3__greater__wrapper : FiniteElementSolver< 3 >, bp::wrapper< FiniteElementSolver< 3 > > {

    FiniteElementSolver_less__3__greater__wrapper(FiniteElementSolver<3> const & arg )
    : FiniteElementSolver<3>( arg )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // copy constructor
        
    }

    FiniteElementSolver_less__3__greater__wrapper( )
    : FiniteElementSolver<3>( )
      , bp::wrapper< FiniteElementSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FiniteElementSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FiniteElementSolver< 3 >::Solve( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->FiniteElementSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        FiniteElementSolver< 3 >::Update( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrationsAtCentroids(  ) {
        if( bp::override func_GetConcentrationsAtCentroids = this->get_override( "GetConcentrationsAtCentroids" ) )
            return func_GetConcentrationsAtCentroids(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrationsAtCentroids(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids( );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkUnstructuredGrid > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkUnstructuredGrid > default_GetVtkSolution(  ) {
        return AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateElementSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateElementSolution = this->get_override( "UpdateElementSolution" ) )
            func_UpdateElementSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateElementSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct FunctionMap_less__2__greater__wrapper : FunctionMap< 2 >, bp::wrapper< FunctionMap< 2 > > {

    FunctionMap_less__2__greater__wrapper(FunctionMap<2> const & arg )
    : FunctionMap<2>( arg )
      , bp::wrapper< FunctionMap< 2 > >(){
        // copy constructor
        
    }

    FunctionMap_less__2__greater__wrapper( )
    : FunctionMap<2>( )
      , bp::wrapper< FunctionMap< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FunctionMap< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FunctionMap< 2 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct FunctionMap_less__3__greater__wrapper : FunctionMap< 3 >, bp::wrapper< FunctionMap< 3 > > {

    FunctionMap_less__3__greater__wrapper(FunctionMap<3> const & arg )
    : FunctionMap<3>( arg )
      , bp::wrapper< FunctionMap< 3 > >(){
        // copy constructor
        
    }

    FunctionMap_less__3__greater__wrapper( )
    : FunctionMap<3>( )
      , bp::wrapper< FunctionMap< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->FunctionMap< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        FunctionMap< 3 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct GreensFunctionSolver_less__2__greater__wrapper : GreensFunctionSolver< 2 >, bp::wrapper< GreensFunctionSolver< 2 > > {

    GreensFunctionSolver_less__2__greater__wrapper(GreensFunctionSolver<2> const & arg )
    : GreensFunctionSolver<2>( arg )
      , bp::wrapper< GreensFunctionSolver< 2 > >(){
        // copy constructor
        
    }

    GreensFunctionSolver_less__2__greater__wrapper( )
    : GreensFunctionSolver<2>( )
      , bp::wrapper< GreensFunctionSolver< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->GreensFunctionSolver< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        GreensFunctionSolver< 2 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 2 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 2 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<2> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 2 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 2 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 2 >::Write( );
    }

};

struct GreensFunctionSolver_less__3__greater__wrapper : GreensFunctionSolver< 3 >, bp::wrapper< GreensFunctionSolver< 3 > > {

    GreensFunctionSolver_less__3__greater__wrapper(GreensFunctionSolver<3> const & arg )
    : GreensFunctionSolver<3>( arg )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // copy constructor
        
    }

    GreensFunctionSolver_less__3__greater__wrapper( )
    : GreensFunctionSolver<3>( )
      , bp::wrapper< GreensFunctionSolver< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->GreensFunctionSolver< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        GreensFunctionSolver< 3 >::Solve( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations(  ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetConcentrations(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetConcentrations( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pGrid );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetConcentrations = this->get_override( "GetConcentrations" ) )
            return func_GetConcentrations( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConcentrations( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations( pMesh );
    }

    virtual ::std::vector< double > GetSolution(  ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution(  );
        else{
            return this->AbstractDiscreteContinuumSolver< 3 >::GetSolution(  );
        }
    }
    
    ::std::vector< double > default_GetSolution(  ) {
        return AbstractDiscreteContinuumSolver< 3 >::GetSolution( );
    }

    virtual ::std::vector< double > GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( boost::ref(rSamplePoints) );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::std::vector< DimensionalChastePoint<3> > const & rSamplePoints ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( boost::ref(rSamplePoints) );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pGrid );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< RegularGrid< 3 > > pGrid ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pGrid );
    }

    virtual ::std::vector< double > GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        if( bp::override func_GetSolution = this->get_override( "GetSolution" ) )
            return func_GetSolution( pMesh );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
        }
    }
    
    ::std::vector< double > default_GetSolution( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > pMesh ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution( pMesh );
    }

    virtual ::vtkSmartPointer< vtkImageData > GetVtkSolution(  ) {
        if( bp::override func_GetVtkSolution = this->get_override( "GetVtkSolution" ) )
            return func_GetVtkSolution(  );
        else{
            return this->AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution(  );
        }
    }
    
    ::vtkSmartPointer< vtkImageData > default_GetVtkSolution(  ) {
        return AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution( );
    }

    virtual void Setup(  ) {
        if( bp::override func_Setup = this->get_override( "Setup" ) )
            func_Setup(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup(  );
        }
    }
    
    void default_Setup(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup( );
    }

    virtual void Update(  ) {
        if( bp::override func_Update = this->get_override( "Update" ) )
            func_Update(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Update(  );
        }
    }
    
    void default_Update(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Update( );
    }

    virtual void UpdateCellData(  ) {
        if( bp::override func_UpdateCellData = this->get_override( "UpdateCellData" ) )
            func_UpdateCellData(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData(  );
        }
    }
    
    void default_UpdateCellData(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData( );
    }

    virtual void UpdateSolution( ::std::vector< double > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & rData ) {
        AbstractDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< double > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< double > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        if( bp::override func_UpdateSolution = this->get_override( "UpdateSolution" ) )
            func_UpdateSolution( boost::ref(rData) );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
        }
    }
    
    void default_UpdateSolution( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & rData ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution( boost::ref(rData) );
    }

    virtual void Write(  ) {
        if( bp::override func_Write = this->get_override( "Write" ) )
            func_Write(  );
        else{
            this->AbstractRegularGridDiscreteContinuumSolver< 3 >::Write(  );
        }
    }
    
    void default_Write(  ) {
        AbstractRegularGridDiscreteContinuumSolver< 3 >::Write( );
    }

};

struct DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper : DiscreteContinuumLinearEllipticPde< 2, 2 >, bp::wrapper< DiscreteContinuumLinearEllipticPde< 2, 2 > > {

    DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper(DiscreteContinuumLinearEllipticPde<2, 2> const & arg )
    : DiscreteContinuumLinearEllipticPde<2, 2>( arg )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 2, 2 > >(){
        // copy constructor
        
    }

    DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper( )
    : DiscreteContinuumLinearEllipticPde<2, 2>( )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->DiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        DiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 2 > const & rX, ::Element< 2, 2 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

};

struct DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper : DiscreteContinuumLinearEllipticPde< 3, 3 >, bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > > {

    DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper(DiscreteContinuumLinearEllipticPde<3, 3> const & arg )
    : DiscreteContinuumLinearEllipticPde<3, 3>( arg )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // copy constructor
        
    }

    DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper( )
    : DiscreteContinuumLinearEllipticPde<3, 3>( )
      , bp::wrapper< DiscreteContinuumLinearEllipticPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual double ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeLinearInUCoeffInSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

    virtual double ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
        }
    }
    
    double default_ComputeConstantInUSourceTerm( ::ChastePoint< 3 > const & rX, ::Element< 3, 3 > * pElement ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm( boost::ref(rX), boost::python::ptr(pElement) );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(arg0) );
        else{
            return this->AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & arg0 ) {
        return AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(arg0) );
    }

};

struct MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper : MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >, bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > > {

    MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper(MichaelisMentenSteadyStateDiffusionReactionPde<2, 2> const & arg )
    : MichaelisMentenSteadyStateDiffusionReactionPde<2, 2>( arg )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // copy constructor
        
    }

    MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper( )
    : MichaelisMentenSteadyStateDiffusionReactionPde<2, 2>( )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTerm( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 2, 2 > ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" ) )
            return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 2, 2 > default_ComputeDiffusionTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ) {
        if( bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" ) )
            return func_ComputeLinearSourceTerm( boost::ref(rX) );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm( boost::ref(rX) );
        }
    }
    
    double default_ComputeLinearSourceTerm( ::ChastePoint< 2 > const & rX ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTerm( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTermPrime( ::ChastePoint< 2 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths( );
    }

};

struct MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper : MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >, bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > > {

    MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper(MichaelisMentenSteadyStateDiffusionReactionPde<3, 3> const & arg )
    : MichaelisMentenSteadyStateDiffusionReactionPde<3, 3>( arg )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // copy constructor
        
    }

    MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper( )
    : MichaelisMentenSteadyStateDiffusionReactionPde<3, 3>( )
      , bp::wrapper< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeConstantInUSourceTerm = this->get_override( "ComputeConstantInUSourceTerm" ) )
            return func_ComputeConstantInUSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeConstantInUSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm( gridIndex );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTerm = this->get_override( "ComputeDiffusionTerm" ) )
            return func_ComputeDiffusionTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTerm( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm( boost::ref(rX), u );
    }

    virtual ::boost::numeric::ublas::c_matrix< double, 3, 3 > ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeDiffusionTermPrime = this->get_override( "ComputeDiffusionTermPrime" ) )
            return func_ComputeDiffusionTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
        }
    }
    
    ::boost::numeric::ublas::c_matrix< double, 3, 3 > default_ComputeDiffusionTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        if( bp::override func_ComputeLinearInUCoeffInSourceTerm = this->get_override( "ComputeLinearInUCoeffInSourceTerm" ) )
            return func_ComputeLinearInUCoeffInSourceTerm( gridIndex );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeLinearInUCoeffInSourceTerm( unsigned int gridIndex=0 ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm( gridIndex );
    }

    virtual double ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        if( bp::override func_ComputeLinearSourceTerm = this->get_override( "ComputeLinearSourceTerm" ) )
            return func_ComputeLinearSourceTerm( boost::ref(rX) );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
        }
    }
    
    double default_ComputeLinearSourceTerm( ::ChastePoint< 3 > const & rX ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm( boost::ref(rX) );
    }

    virtual double ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTerm( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTerm = this->get_override( "ComputeNonlinearSourceTerm" ) )
            return func_ComputeNonlinearSourceTerm( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTerm( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm( gridIndex, u );
    }

    virtual double ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
        }
    }
    
    double default_ComputeNonlinearSourceTermPrime( ::ChastePoint< 3 > const & rX, double u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( boost::ref(rX), u );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        if( bp::override func_ComputeNonlinearSourceTermPrime = this->get_override( "ComputeNonlinearSourceTermPrime" ) )
            return func_ComputeNonlinearSourceTermPrime( gridIndex, u );
        else{
            return this->MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_ComputeNonlinearSourceTermPrime( unsigned int gridIndex, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > u ) {
        return MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime( gridIndex, u );
    }

    virtual void UpdateDiscreteSourceStrengths(  ) {
        if( bp::override func_UpdateDiscreteSourceStrengths = this->get_override( "UpdateDiscreteSourceStrengths" ) )
            func_UpdateDiscreteSourceStrengths(  );
        else{
            this->AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths(  );
        }
    }
    
    void default_UpdateDiscreteSourceStrengths(  ) {
        AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths( );
    }

};

struct SolutionDependentDiscreteSource_less__2__greater__wrapper : SolutionDependentDiscreteSource< 2 >, bp::wrapper< SolutionDependentDiscreteSource< 2 > > {

    SolutionDependentDiscreteSource_less__2__greater__wrapper(SolutionDependentDiscreteSource<2> const & arg )
    : SolutionDependentDiscreteSource<2>( arg )
      , bp::wrapper< SolutionDependentDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    SolutionDependentDiscreteSource_less__2__greater__wrapper( )
    : SolutionDependentDiscreteSource<2>( )
      , bp::wrapper< SolutionDependentDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 2 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 2 >::GetNonlinearTermRegularGridValues( );
    }

};

struct SolutionDependentDiscreteSource_less__3__greater__wrapper : SolutionDependentDiscreteSource< 3 >, bp::wrapper< SolutionDependentDiscreteSource< 3 > > {

    SolutionDependentDiscreteSource_less__3__greater__wrapper(SolutionDependentDiscreteSource<3> const & arg )
    : SolutionDependentDiscreteSource<3>( arg )
      , bp::wrapper< SolutionDependentDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    SolutionDependentDiscreteSource_less__3__greater__wrapper( )
    : SolutionDependentDiscreteSource<3>( )
      , bp::wrapper< SolutionDependentDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->DiscreteSource< 3 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return DiscreteSource< 3 >::GetNonlinearTermRegularGridValues( );
    }

};

struct VesselBasedDiscreteSource_less__2__greater__wrapper : VesselBasedDiscreteSource< 2 >, bp::wrapper< VesselBasedDiscreteSource< 2 > > {

    VesselBasedDiscreteSource_less__2__greater__wrapper(VesselBasedDiscreteSource<2> const & arg )
    : VesselBasedDiscreteSource<2>( arg )
      , bp::wrapper< VesselBasedDiscreteSource< 2 > >(){
        // copy constructor
        
    }

    VesselBasedDiscreteSource_less__2__greater__wrapper( )
    : VesselBasedDiscreteSource<2>( )
      , bp::wrapper< VesselBasedDiscreteSource< 2 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 2 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return VesselBasedDiscreteSource< 2 >::GetNonlinearTermRegularGridValues( );
    }

};

struct VesselBasedDiscreteSource_less__3__greater__wrapper : VesselBasedDiscreteSource< 3 >, bp::wrapper< VesselBasedDiscreteSource< 3 > > {

    VesselBasedDiscreteSource_less__3__greater__wrapper(VesselBasedDiscreteSource<3> const & arg )
    : VesselBasedDiscreteSource<3>( arg )
      , bp::wrapper< VesselBasedDiscreteSource< 3 > >(){
        // copy constructor
        
    }

    VesselBasedDiscreteSource_less__3__greater__wrapper( )
    : VesselBasedDiscreteSource<3>( )
      , bp::wrapper< VesselBasedDiscreteSource< 3 > >(){
        // null constructor
    
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInUMeshValues(  ) {
        if( bp::override func_GetConstantInUMeshValues = this->get_override( "GetConstantInUMeshValues" ) )
            return func_GetConstantInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetConstantInURegularGridValues(  ) {
        if( bp::override func_GetConstantInURegularGridValues = this->get_override( "GetConstantInURegularGridValues" ) )
            return func_GetConstantInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetConstantInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInUMeshValues(  ) {
        if( bp::override func_GetLinearInUMeshValues = this->get_override( "GetLinearInUMeshValues" ) )
            return func_GetLinearInUMeshValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInUMeshValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetLinearInURegularGridValues(  ) {
        if( bp::override func_GetLinearInURegularGridValues = this->get_override( "GetLinearInURegularGridValues" ) )
            return func_GetLinearInURegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetLinearInURegularGridValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues( );
    }

    virtual ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > GetNonlinearTermRegularGridValues(  ) {
        if( bp::override func_GetNonlinearTermRegularGridValues = this->get_override( "GetNonlinearTermRegularGridValues" ) )
            return func_GetNonlinearTermRegularGridValues(  );
        else{
            return this->VesselBasedDiscreteSource< 3 >::GetNonlinearTermRegularGridValues(  );
        }
    }
    
    ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > default_GetNonlinearTermRegularGridValues(  ) {
        return VesselBasedDiscreteSource< 3 >::GetNonlinearTermRegularGridValues( );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 2 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< DimensionalChastePoint< 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< DiscreteSource< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< DiscreteSource< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_MicrovesselChaste_pde){
    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::vector< boost::shared_ptr<DiscreteSource<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<DiscreteSource<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<DiscreteSource<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<DiscreteSource<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<DiscreteSource<2> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<DiscreteSource<2> > > >() );
    }

    { //::std::vector< DimensionalChastePoint<3> >
        typedef bp::class_< std::vector< DimensionalChastePoint<3> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<3> > >() );
    }

    { //::std::vector< DimensionalChastePoint<2> >
        typedef bp::class_< std::vector< DimensionalChastePoint<2> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< DimensionalChastePoint<2> > >() );
    }

    { //::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > MapUnsigned_ConcentrationFlowRate_exposer_t;
        MapUnsigned_ConcentrationFlowRate_exposer_t MapUnsigned_ConcentrationFlowRate_exposer = MapUnsigned_ConcentrationFlowRate_exposer_t( "MapUnsigned_ConcentrationFlowRate" );
        bp::scope MapUnsigned_ConcentrationFlowRate_scope( MapUnsigned_ConcentrationFlowRate_exposer );
        MapUnsigned_ConcentrationFlowRate_exposer.def( bp::indexing::map_suite< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >
        typedef bp::class_< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > MapUnsigned_Concentration_exposer_t;
        MapUnsigned_Concentration_exposer_t MapUnsigned_Concentration_exposer = MapUnsigned_Concentration_exposer_t( "MapUnsigned_Concentration" );
        bp::scope MapUnsigned_Concentration_scope( MapUnsigned_Concentration_exposer );
        MapUnsigned_Concentration_exposer.def( bp::indexing::map_suite< std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );
    }

    { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t;
        AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde2_2", bp::init< >() );
        bp::scope AbstractDiscreteContinuumLinearEllipticPde2_2_scope( AbstractDiscreteContinuumLinearEllipticPde2_2_exposer );
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<2> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetMesh
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetReferenceConcentration )
                , ( bp::arg("referenceConcentration") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint<2> const &,::Element<2, 2> * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearEllipticPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > >();
    }

    { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >
        typedef bp::class_< AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t;
        AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumLinearEllipticPde3_3", bp::init< >() );
        bp::scope AbstractDiscreteContinuumLinearEllipticPde3_3_scope( AbstractDiscreteContinuumLinearEllipticPde3_3_exposer );
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetReferenceConcentration )
                , ( bp::arg("referenceConcentration") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint<3> const &,::Element<3, 3> * ) ;
            
            AbstractDiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearEllipticPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > >();
    }

    { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t;
        AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer = AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde2_2", bp::init< >() );
        bp::scope AbstractDiscreteContinuumNonLinearEllipticPde2_2_scope( AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer );
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<2> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetMesh
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 2, 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 2, 2> ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , bp::pure_virtual( ComputeDiffusionTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTerm) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 2, 2> ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTermPrime"
                , bp::pure_virtual( ComputeDiffusionTermPrime_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeDiffusionTermPrime) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeLinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint<2> const & ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearSourceTerm"
                , bp::pure_virtual( ComputeLinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeLinearSourceTerm) )
                , ( bp::arg("rX") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint<2> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractNonlinearEllipticPde< 2 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > >();
    }

    { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >
        typedef bp::class_< AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t;
        AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer = AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer_t( "AbstractDiscreteContinuumNonLinearEllipticPde3_3", bp::init< >() );
        bp::scope AbstractDiscreteContinuumNonLinearEllipticPde3_3_scope( AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer );
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< TetrahedralMesh< 3, 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumNonLinearEllipticPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 3, 3> ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , bp::pure_virtual( ComputeDiffusionTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTerm) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix<double, 3, 3> ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTermPrime"
                , bp::pure_virtual( ComputeDiffusionTermPrime_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeDiffusionTermPrime) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeLinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint<3> const & ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearSourceTerm"
                , bp::pure_virtual( ComputeLinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeLinearSourceTerm) )
                , ( bp::arg("rX") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint<3> const &,double ) ;
            
            AbstractDiscreteContinuumNonLinearEllipticPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractNonlinearEllipticPde< 3 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > >();
    }

    { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >
        typedef bp::class_< AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumParabolicPde2_2_exposer_t;
        AbstractDiscreteContinuumParabolicPde2_2_exposer_t AbstractDiscreteContinuumParabolicPde2_2_exposer = AbstractDiscreteContinuumParabolicPde2_2_exposer_t( "AbstractDiscreteContinuumParabolicPde2_2", bp::init< >() );
        bp::scope AbstractDiscreteContinuumParabolicPde2_2_scope( AbstractDiscreteContinuumParabolicPde2_2_exposer );
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 2 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeDiffusionTerm )
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumParabolicPde< 2, 2 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<2> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::GetMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMultiplierValue_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "GetMultiplierValue"
                , GetMultiplierValue_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::GetMultiplierValue ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetMesh
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMultiplierValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetMultiplierValue"
                , SetMultiplierValue_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetMultiplierValue )
                , ( bp::arg("multiplier") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetReferenceConcentration )
                , ( bp::arg("referenceConcentration") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumParabolicPde< 2, 2 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateMultiplierValue_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper::*default_UpdateMultiplierValue_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde2_2_exposer.def( 
                "UpdateMultiplierValue"
                , UpdateMultiplierValue_function_type(&::AbstractDiscreteContinuumParabolicPde< 2, 2 >::UpdateMultiplierValue)
                , default_UpdateMultiplierValue_function_type(&AbstractDiscreteContinuumParabolicPde_less__2_comma__2__greater__wrapper::default_UpdateMultiplierValue) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumParabolicPde<2, 2> > >();
    }

    { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >
        typedef bp::class_< AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper, boost::noncopyable > AbstractDiscreteContinuumParabolicPde3_3_exposer_t;
        AbstractDiscreteContinuumParabolicPde3_3_exposer_t AbstractDiscreteContinuumParabolicPde3_3_exposer = AbstractDiscreteContinuumParabolicPde3_3_exposer_t( "AbstractDiscreteContinuumParabolicPde3_3", bp::init< >() );
        bp::scope AbstractDiscreteContinuumParabolicPde3_3_scope( AbstractDiscreteContinuumParabolicPde3_3_exposer );
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::AddDiscreteSource
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*AddDiscreteSource_function_type)( ::boost::shared_ptr< DiscreteSource< 3 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "AddDiscreteSource"
                , AddDiscreteSource_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::AddDiscreteSource )
                , ( bp::arg("pDiscreteSource") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeDiffusionTerm )
                , ( bp::arg("arg0") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeIsotropicDiffusionTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeIsotropicDiffusionTerm_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeIsotropicDiffusionTerm"
                , ComputeIsotropicDiffusionTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeIsotropicDiffusionTerm ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , bp::pure_virtual( ComputeLinearInUCoeffInSourceTerm_function_type(&::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm) )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , bp::pure_virtual( ComputeNonlinearSourceTerm_function_type(&::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeNonlinearSourceTerm) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , bp::pure_virtual( ComputeNonlinearSourceTermPrime_function_type(&::AbstractDiscreteContinuumParabolicPde< 3, 3 >::ComputeNonlinearSourceTermPrime) )
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::GetDiscreteSources
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<DiscreteSource<3> > > ( exported_class_t::*GetDiscreteSources_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "GetDiscreteSources"
                , GetDiscreteSources_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::GetDiscreteSources ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::GetMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMultiplierValue_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "GetMultiplierValue"
                , GetMultiplierValue_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::GetMultiplierValue ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetContinuumConstantInUTerm
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumConstantInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetContinuumConstantInUTerm"
                , SetContinuumConstantInUTerm_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetContinuumConstantInUTerm )
                , ( bp::arg("constantInUTerm") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetIsotropicDiffusionConstant
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsotropicDiffusionConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetIsotropicDiffusionConstant"
                , SetIsotropicDiffusionConstant_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetIsotropicDiffusionConstant )
                , ( bp::arg("diffusivity") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetMesh
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMultiplierValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetMultiplierValue"
                , SetMultiplierValue_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetMultiplierValue )
                , ( bp::arg("multiplier") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetReferenceConcentration
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetReferenceConcentration )
                , ( bp::arg("referenceConcentration") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetRegularGrid
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetUseRegularGrid
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseRegularGrid_function_type)( bool ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "SetUseRegularGrid"
                , SetUseRegularGrid_function_type( &::AbstractDiscreteContinuumParabolicPde< 3, 3 >::SetUseRegularGrid )
                , ( bp::arg("useRegularGrid") ) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateMultiplierValue
        
            typedef AbstractDiscreteContinuumParabolicPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateMultiplierValue_function_type)(  ) ;
            typedef void ( AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper::*default_UpdateMultiplierValue_function_type)(  ) ;
            
            AbstractDiscreteContinuumParabolicPde3_3_exposer.def( 
                "UpdateMultiplierValue"
                , UpdateMultiplierValue_function_type(&::AbstractDiscreteContinuumParabolicPde< 3, 3 >::UpdateMultiplierValue)
                , default_UpdateMultiplierValue_function_type(&AbstractDiscreteContinuumParabolicPde_less__3_comma__3__greater__wrapper::default_UpdateMultiplierValue) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< AbstractDiscreteContinuumParabolicPde<3, 3> > >();
    }

    bp::class_< AbstractDiscreteContinuumSolver_less__2__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver2", bp::init< >() )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") ) )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::CellPopulationIsSet ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetNonLinearPde ) )    
        .def( 
            "GetParabolicPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetParabolicPde ) )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetPde ) )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::GetReferenceConcentration ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasRegularGrid ) )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))( &::AbstractDiscreteContinuumSolver< 2 >::HasUnstructuredGrid ) )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") ) )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") ) )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetFileName )
            , ( bp::arg("rFilename") ) )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 2 >::SetLabel )
            , ( bp::arg("rLabel") ) )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetNonLinearPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetParabolicPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetParabolicPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > > ))( &::AbstractDiscreteContinuumSolver< 2 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 2 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) ) )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Setup) ) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Solve) ) )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Update) ) )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateCellData) ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::Write) ) );

    bp::class_< AbstractDiscreteContinuumSolver_less__3__greater__wrapper, boost::noncopyable >( "AbstractDiscreteContinuumSolver3", bp::init< >() )    
        .def( 
            "AddBoundaryCondition"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::AddBoundaryCondition )
            , ( bp::arg("pBoundaryCondition") ) )    
        .def( 
            "CellPopulationIsSet"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::CellPopulationIsSet ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , bp::pure_virtual( (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetLabel"
            , (::std::string const & ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetLabel )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetNonLinearPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetNonLinearPde ) )    
        .def( 
            "GetParabolicPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetParabolicPde ) )    
        .def( 
            "GetPde"
            , (::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetPde ) )    
        .def( 
            "GetReferenceConcentration"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::GetReferenceConcentration ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , bp::pure_virtual( (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution) )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "HasRegularGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasRegularGrid ) )    
        .def( 
            "HasUnstructuredGrid"
            , (bool ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))( &::AbstractDiscreteContinuumSolver< 3 >::HasUnstructuredGrid ) )    
        .def( 
            "SetCellPopulation"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetCellPopulation )
            , ( bp::arg("rCellPopulation"), bp::arg("cellPopulationReferenceLength"), bp::arg("cellPopulationReferenceConcentration") ) )    
        .def( 
            "SetFileHandler"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< OutputFileHandler > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileHandler )
            , ( bp::arg("pOutputFileHandler") ) )    
        .def( 
            "SetFileName"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetFileName )
            , ( bp::arg("rFilename") ) )    
        .def( 
            "SetLabel"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::string const & ))( &::AbstractDiscreteContinuumSolver< 3 >::SetLabel )
            , ( bp::arg("rLabel") ) )    
        .def( 
            "SetNonLinearPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetNonLinearPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetParabolicPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetParabolicPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetPde"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetPde )
            , ( bp::arg("pPde") ) )    
        .def( 
            "SetReferenceConcentration"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetReferenceConcentration )
            , ( bp::arg("referenceConcentration") ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > > ))( &::AbstractDiscreteContinuumSolver< 3 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) )    
        .def( 
            "SetWriteSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( bool ))( &::AbstractDiscreteContinuumSolver< 3 >::SetWriteSolution )
            , ( bp::arg("write")=(bool)(true) ) )    
        .def( 
            "Setup"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Setup) ) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Solve) ) )    
        .def( 
            "Update"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Update) ) )    
        .def( 
            "UpdateCellData"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateCellData) ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , bp::pure_virtual( (void ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::Write) ) );

    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver2", bp::init< >() )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetGrid"
            , (::boost::shared_ptr< RegularGrid< 2 > > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetGrid ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetGrid"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))( &::AbstractRegularGridDiscreteContinuumSolver< 2 >::SetGrid )
            , ( bp::arg("pRegularGrid") ) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Solve) ) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) );

    bp::class_< AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractRegularGridDiscreteContinuumSolver3", bp::init< >() )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetGrid"
            , (::boost::shared_ptr< RegularGrid< 3 > > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetGrid ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetGrid"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))( &::AbstractRegularGridDiscreteContinuumSolver< 3 >::SetGrid )
            , ( bp::arg("pRegularGrid") ) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Solve) ) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractRegularGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) );

    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 2 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver2", bp::init< >() )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetConcentrationsAtCentroids"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrationsAtCentroids) )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetMesh ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetMesh"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::SetMesh )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "Setup"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Solve) ) )    
        .def( 
            "Update"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateElementSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateElementSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__2__greater__wrapper::default_GetSolution) );

    bp::class_< AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumSolver< 3 > >, boost::noncopyable >( "AbstractUnstructuredGridDiscreteContinuumSolver3", bp::init< >() )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetConcentrationsAtCentroids"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrationsAtCentroids) )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetMesh ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkUnstructuredGrid > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "SetMesh"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))( &::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::SetMesh )
            , ( bp::arg("pMesh") ) )    
        .def( 
            "Setup"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Solve"
            , bp::pure_virtual( (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Solve) ) )    
        .def( 
            "Update"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateElementSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateElementSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractUnstructuredGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_Write) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::* )(  ))(&AbstractUnstructuredGridDiscreteContinuumSolver_less__3__greater__wrapper::default_GetSolution) );

    { //::BoundaryConditionSource
        typedef bp::class_< BoundaryConditionSource > BoundaryConditionSource_exposer_t;
        BoundaryConditionSource_exposer_t BoundaryConditionSource_exposer = BoundaryConditionSource_exposer_t( "BoundaryConditionSource" );
        bp::scope BoundaryConditionSource_scope( BoundaryConditionSource_exposer );
        bp::enum_< BoundaryConditionSource::Value>("Value")
            .value("LABEL_BASED", BoundaryConditionSource::LABEL_BASED)
            .value("PRESCRIBED", BoundaryConditionSource::PRESCRIBED)
            .export_values()
            ;
    }

    { //::BoundaryConditionType
        typedef bp::class_< BoundaryConditionType > BoundaryConditionType_exposer_t;
        BoundaryConditionType_exposer_t BoundaryConditionType_exposer = BoundaryConditionType_exposer_t( "BoundaryConditionType" );
        bp::scope BoundaryConditionType_scope( BoundaryConditionType_exposer );
        bp::enum_< BoundaryConditionType::Value>("Value")
            .value("POINT", BoundaryConditionType::POINT)
            .value("FACET", BoundaryConditionType::FACET)
            .value("OUTER", BoundaryConditionType::OUTER)
            .value("VESSEL_LINE", BoundaryConditionType::VESSEL_LINE)
            .value("VESSEL_VOLUME", BoundaryConditionType::VESSEL_VOLUME)
            .value("CELL", BoundaryConditionType::CELL)
            .value("IN_PART", BoundaryConditionType::IN_PART)
            .export_values()
            ;
    }

    { //::DiscreteSource< 2 >
        typedef bp::class_< DiscreteSource_less__2__greater__wrapper > DiscreteSource2_exposer_t;
        DiscreteSource2_exposer_t DiscreteSource2_exposer = DiscreteSource2_exposer_t( "DiscreteSource2", bp::init< >() );
        bp::scope DiscreteSource2_scope( DiscreteSource2_exposer );
        { //::DiscreteSource< 2 >::Create
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteSource< 2 > > ( *Create_function_type )(  );
            
            DiscreteSource2_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteSource< 2 >::Create ) );
        
        }
        { //::DiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::DiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::DiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::DiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::DiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::DiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::DiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::DiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__2__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            DiscreteSource2_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&DiscreteSource_less__2__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        { //::DiscreteSource< 2 >::SetConstantInUValue
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetConstantInUValue"
                , SetConstantInUValue_function_type( &::DiscreteSource< 2 >::SetConstantInUValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 2 >::SetLabelName
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteSource2_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteSource< 2 >::SetLabelName )
                , ( bp::arg("rLabel") ) );
        
        }
        { //::DiscreteSource< 2 >::SetLinearInUValue
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetLinearInUValue"
                , SetLinearInUValue_function_type( &::DiscreteSource< 2 >::SetLinearInUValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 2 >::SetMesh
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteSource< 2 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteSource< 2 >::SetPoints
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<2> > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteSource< 2 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteSource< 2 >::SetRegularGrid
        
            typedef DiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            DiscreteSource2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteSource< 2 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        DiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteSource<2> > >();
    }

    { //::CellBasedDiscreteSource< 2 >
        typedef bp::class_< CellBasedDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > CellBasedDiscreteSource2_exposer_t;
        CellBasedDiscreteSource2_exposer_t CellBasedDiscreteSource2_exposer = CellBasedDiscreteSource2_exposer_t( "CellBasedDiscreteSource2", bp::init< >() );
        bp::scope CellBasedDiscreteSource2_scope( CellBasedDiscreteSource2_exposer );
        { //::CellBasedDiscreteSource< 2 >::Create
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< CellBasedDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            CellBasedDiscreteSource2_exposer.def( 
                "Create"
                , Create_function_type( &::CellBasedDiscreteSource< 2 >::Create ) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellBasedDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellBasedDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellBasedDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellBasedDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::SetConstantInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "SetConstantInUConsumptionRatePerCell"
                , SetConstantInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 2 >::SetConstantInUConsumptionRatePerCell )
                , ( bp::arg("value") ) );
        
        }
        { //::CellBasedDiscreteSource< 2 >::SetLinearInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "SetLinearInUConsumptionRatePerCell"
                , SetLinearInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 2 >::SetLinearInUConsumptionRatePerCell )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues
        
            typedef CellBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__2__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource2_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&CellBasedDiscreteSource_less__2__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        CellBasedDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellBasedDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellBasedDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::DiscreteSource< 3 >
        typedef bp::class_< DiscreteSource_less__3__greater__wrapper > DiscreteSource3_exposer_t;
        DiscreteSource3_exposer_t DiscreteSource3_exposer = DiscreteSource3_exposer_t( "DiscreteSource3", bp::init< >() );
        bp::scope DiscreteSource3_scope( DiscreteSource3_exposer );
        { //::DiscreteSource< 3 >::Create
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteSource< 3 > > ( *Create_function_type )(  );
            
            DiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteSource< 3 >::Create ) );
        
        }
        { //::DiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::DiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::DiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::DiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::DiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::DiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::DiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( DiscreteSource_less__3__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            DiscreteSource3_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&DiscreteSource_less__3__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        { //::DiscreteSource< 3 >::SetConstantInUValue
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetConstantInUValue"
                , SetConstantInUValue_function_type( &::DiscreteSource< 3 >::SetConstantInUValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 3 >::SetLabelName
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteSource3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteSource< 3 >::SetLabelName )
                , ( bp::arg("rLabel") ) );
        
        }
        { //::DiscreteSource< 3 >::SetLinearInUValue
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetLinearInUValue"
                , SetLinearInUValue_function_type( &::DiscreteSource< 3 >::SetLinearInUValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 3 >::SetMesh
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteSource< 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteSource< 3 >::SetPoints
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<3> > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteSource< 3 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteSource< 3 >::SetRegularGrid
        
            typedef DiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            DiscreteSource3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteSource< 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        DiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteSource<3> > >();
    }

    { //::CellBasedDiscreteSource< 3 >
        typedef bp::class_< CellBasedDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > CellBasedDiscreteSource3_exposer_t;
        CellBasedDiscreteSource3_exposer_t CellBasedDiscreteSource3_exposer = CellBasedDiscreteSource3_exposer_t( "CellBasedDiscreteSource3", bp::init< >() );
        bp::scope CellBasedDiscreteSource3_scope( CellBasedDiscreteSource3_exposer );
        { //::CellBasedDiscreteSource< 3 >::Create
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellBasedDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            CellBasedDiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::CellBasedDiscreteSource< 3 >::Create ) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellBasedDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellBasedDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellBasedDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellBasedDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::SetConstantInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "SetConstantInUConsumptionRatePerCell"
                , SetConstantInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 3 >::SetConstantInUConsumptionRatePerCell )
                , ( bp::arg("value") ) );
        
        }
        { //::CellBasedDiscreteSource< 3 >::SetLinearInUConsumptionRatePerCell
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUConsumptionRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "SetLinearInUConsumptionRatePerCell"
                , SetLinearInUConsumptionRatePerCell_function_type( &::CellBasedDiscreteSource< 3 >::SetLinearInUConsumptionRatePerCell )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues
        
            typedef CellBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellBasedDiscreteSource_less__3__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            CellBasedDiscreteSource3_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&CellBasedDiscreteSource_less__3__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        CellBasedDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellBasedDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellBasedDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::CellStateDependentDiscreteSource< 2 >
        typedef bp::class_< CellStateDependentDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > CellStateDependentDiscreteSource2_exposer_t;
        CellStateDependentDiscreteSource2_exposer_t CellStateDependentDiscreteSource2_exposer = CellStateDependentDiscreteSource2_exposer_t( "CellStateDependentDiscreteSource2", bp::init< >() );
        bp::scope CellStateDependentDiscreteSource2_scope( CellStateDependentDiscreteSource2_exposer );
        { //::CellStateDependentDiscreteSource< 2 >::Create
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< CellStateDependentDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "Create"
                , Create_function_type( &::CellStateDependentDiscreteSource< 2 >::Create ) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::SetStateRateMap
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "SetStateRateMap"
                , SetStateRateMap_function_type( &::CellStateDependentDiscreteSource< 2 >::SetStateRateMap )
                , ( bp::arg("stateRateMap") ) );
        
        }
        { //::CellStateDependentDiscreteSource< 2 >::SetStateRateThresholdMap
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateThresholdMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "SetStateRateThresholdMap"
                , SetStateRateThresholdMap_function_type( &::CellStateDependentDiscreteSource< 2 >::SetStateRateThresholdMap )
                , ( bp::arg("stateThresholdMap") ) );
        
        }
        { //::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__2__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource2_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__2__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        CellStateDependentDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellStateDependentDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellStateDependentDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::CellStateDependentDiscreteSource< 3 >
        typedef bp::class_< CellStateDependentDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > CellStateDependentDiscreteSource3_exposer_t;
        CellStateDependentDiscreteSource3_exposer_t CellStateDependentDiscreteSource3_exposer = CellStateDependentDiscreteSource3_exposer_t( "CellStateDependentDiscreteSource3", bp::init< >() );
        bp::scope CellStateDependentDiscreteSource3_scope( CellStateDependentDiscreteSource3_exposer );
        { //::CellStateDependentDiscreteSource< 3 >::Create
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< CellStateDependentDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::CellStateDependentDiscreteSource< 3 >::Create ) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::CellStateDependentDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateMap"
                , SetStateRateMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateMap )
                , ( bp::arg("stateRateMap") ) );
        
        }
        { //::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetStateRateThresholdMap_function_type)( ::std::map< unsigned int, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "SetStateRateThresholdMap"
                , SetStateRateThresholdMap_function_type( &::CellStateDependentDiscreteSource< 3 >::SetStateRateThresholdMap )
                , ( bp::arg("stateThresholdMap") ) );
        
        }
        { //::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues
        
            typedef CellStateDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( CellStateDependentDiscreteSource_less__3__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            CellStateDependentDiscreteSource3_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&CellStateDependentDiscreteSource_less__3__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        CellStateDependentDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CellStateDependentDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CellStateDependentDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >
        typedef bp::class_< CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumParabolicPde< 2, 2 > > > CoupledVegfPelletDiffusionReactionPde2_2_exposer_t;
        CoupledVegfPelletDiffusionReactionPde2_2_exposer_t CoupledVegfPelletDiffusionReactionPde2_2_exposer = CoupledVegfPelletDiffusionReactionPde2_2_exposer_t( "CoupledVegfPelletDiffusionReactionPde2_2", bp::init< >() );
        bp::scope CoupledVegfPelletDiffusionReactionPde2_2_scope( CoupledVegfPelletDiffusionReactionPde2_2_exposer );
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::Create
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde< 2, 2 > > ( *Create_function_type )(  );
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "Create"
                , Create_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::Create ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetCorneaPelletPermeability
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetCorneaPelletPermeability_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetCorneaPelletPermeability"
                , GetCorneaPelletPermeability_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetCorneaPelletPermeability ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetInitialVegfInPellet
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetInitialVegfInPellet_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetInitialVegfInPellet"
                , GetInitialVegfInPellet_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetInitialVegfInPellet ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletBindingConstant
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletBindingConstant_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetPelletBindingConstant"
                , GetPelletBindingConstant_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletBindingConstant ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletFreeDecayRate
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletFreeDecayRate_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetPelletFreeDecayRate"
                , GetPelletFreeDecayRate_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletFreeDecayRate ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletSurfaceArea
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletSurfaceArea_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetPelletSurfaceArea"
                , GetPelletSurfaceArea_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletSurfaceArea ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletVolume
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletVolume_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "GetPelletVolume"
                , GetPelletVolume_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::GetPelletVolume ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetContinuumLinearInUTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetCorneaPelletPermeability
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCorneaPelletPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetCorneaPelletPermeability"
                , SetCorneaPelletPermeability_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetCorneaPelletPermeability )
                , ( bp::arg("permeability") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetHalfMaxVegfConcentration
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetHalfMaxVegfConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetHalfMaxVegfConcentration"
                , SetHalfMaxVegfConcentration_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetHalfMaxVegfConcentration )
                , ( bp::arg("halfMax") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetInitialVegfInPellet
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetInitialVegfInPellet_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetInitialVegfInPellet"
                , SetInitialVegfInPellet_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetInitialVegfInPellet )
                , ( bp::arg("initialVegf") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletBindingConstant
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletBindingConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetPelletBindingConstant"
                , SetPelletBindingConstant_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletBindingConstant )
                , ( bp::arg("bindingConstant") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletFreeDecayRate
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletFreeDecayRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetPelletFreeDecayRate"
                , SetPelletFreeDecayRate_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletFreeDecayRate )
                , ( bp::arg("rate") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletSurfaceArea
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletSurfaceArea_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetPelletSurfaceArea"
                , SetPelletSurfaceArea_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletSurfaceArea )
                , ( bp::arg("surfaceArea") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletVolume
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletVolume_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "SetPelletVolume"
                , SetPelletVolume_function_type( &::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::SetPelletVolume )
                , ( bp::arg("volume") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateMultiplierValue
        
            typedef CoupledVegfPelletDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateMultiplierValue_function_type)(  ) ;
            typedef void ( CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_UpdateMultiplierValue_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde2_2_exposer.def( 
                "UpdateMultiplierValue"
                , UpdateMultiplierValue_function_type(&::CoupledVegfPelletDiffusionReactionPde< 2, 2 >::UpdateMultiplierValue)
                , default_UpdateMultiplierValue_function_type(&CoupledVegfPelletDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_UpdateMultiplierValue) );
        
        }
        CoupledVegfPelletDiffusionReactionPde2_2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 2, 2 > > >();
    }

    { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >
        typedef bp::class_< CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumParabolicPde< 3, 3 > > > CoupledVegfPelletDiffusionReactionPde3_3_exposer_t;
        CoupledVegfPelletDiffusionReactionPde3_3_exposer_t CoupledVegfPelletDiffusionReactionPde3_3_exposer = CoupledVegfPelletDiffusionReactionPde3_3_exposer_t( "CoupledVegfPelletDiffusionReactionPde3_3", bp::init< >() );
        bp::scope CoupledVegfPelletDiffusionReactionPde3_3_scope( CoupledVegfPelletDiffusionReactionPde3_3_exposer );
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::Create
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde< 3, 3 > > ( *Create_function_type )(  );
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "Create"
                , Create_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::Create ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetCorneaPelletPermeability
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetCorneaPelletPermeability_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetCorneaPelletPermeability"
                , GetCorneaPelletPermeability_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetCorneaPelletPermeability ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetInitialVegfInPellet
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetInitialVegfInPellet_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetInitialVegfInPellet"
                , GetInitialVegfInPellet_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetInitialVegfInPellet ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletBindingConstant
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletBindingConstant_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetPelletBindingConstant"
                , GetPelletBindingConstant_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletBindingConstant ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletFreeDecayRate
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletFreeDecayRate_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetPelletFreeDecayRate"
                , GetPelletFreeDecayRate_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletFreeDecayRate ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletSurfaceArea
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletSurfaceArea_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetPelletSurfaceArea"
                , GetPelletSurfaceArea_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletSurfaceArea ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletVolume
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetPelletVolume_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "GetPelletVolume"
                , GetPelletVolume_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::GetPelletVolume ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetCorneaPelletPermeability
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCorneaPelletPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetCorneaPelletPermeability"
                , SetCorneaPelletPermeability_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetCorneaPelletPermeability )
                , ( bp::arg("permeability") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetHalfMaxVegfConcentration
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHalfMaxVegfConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetHalfMaxVegfConcentration"
                , SetHalfMaxVegfConcentration_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetHalfMaxVegfConcentration )
                , ( bp::arg("halfMax") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetInitialVegfInPellet
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetInitialVegfInPellet_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetInitialVegfInPellet"
                , SetInitialVegfInPellet_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetInitialVegfInPellet )
                , ( bp::arg("initialVegf") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletBindingConstant
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletBindingConstant_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetPelletBindingConstant"
                , SetPelletBindingConstant_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletBindingConstant )
                , ( bp::arg("bindingConstant") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletFreeDecayRate
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletFreeDecayRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetPelletFreeDecayRate"
                , SetPelletFreeDecayRate_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletFreeDecayRate )
                , ( bp::arg("rate") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletSurfaceArea
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletSurfaceArea_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetPelletSurfaceArea"
                , SetPelletSurfaceArea_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletSurfaceArea )
                , ( bp::arg("surfaceArea") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletVolume
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPelletVolume_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "SetPelletVolume"
                , SetPelletVolume_function_type( &::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::SetPelletVolume )
                , ( bp::arg("volume") ) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateMultiplierValue
        
            typedef CoupledVegfPelletDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateMultiplierValue_function_type)(  ) ;
            typedef void ( CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_UpdateMultiplierValue_function_type)(  ) ;
            
            CoupledVegfPelletDiffusionReactionPde3_3_exposer.def( 
                "UpdateMultiplierValue"
                , UpdateMultiplierValue_function_type(&::CoupledVegfPelletDiffusionReactionPde< 3, 3 >::UpdateMultiplierValue)
                , default_UpdateMultiplierValue_function_type(&CoupledVegfPelletDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_UpdateMultiplierValue) );
        
        }
        CoupledVegfPelletDiffusionReactionPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< CoupledVegfPelletDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractDiscreteContinuumParabolicPde< 3, 3 > > >();
    }

    { //::DiscreteContinuumBoundaryCondition< 2 >
        typedef bp::class_< DiscreteContinuumBoundaryCondition< 2 > > DiscreteContinuumBoundaryCondition2_exposer_t;
        DiscreteContinuumBoundaryCondition2_exposer_t DiscreteContinuumBoundaryCondition2_exposer = DiscreteContinuumBoundaryCondition2_exposer_t( "DiscreteContinuumBoundaryCondition2", bp::init< >() );
        bp::scope DiscreteContinuumBoundaryCondition2_scope( DiscreteContinuumBoundaryCondition2_exposer );
        { //::DiscreteContinuumBoundaryCondition< 2 >::Create
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 2 > > ( *Create_function_type )(  );
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::Create ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetType
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::BoundaryConditionType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetType"
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetType ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetValue_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetValue ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef ::std::pair< bool, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetValue_function_type)( ::DimensionalChastePoint< 2 >,double ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::GetValue )
                , ( bp::arg("location"), bp::arg("tolerance") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetDomain
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDomain_function_type)( ::boost::shared_ptr< Part< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetDomain"
                , SetDomain_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetLabelName
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetLabelName )
                , ( bp::arg("label") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetMesh
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetNetwork
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetPoints
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<2> > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetRegularGrid
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetSource
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::BoundaryConditionSource::Value ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetSource )
                , ( bp::arg("boundarySource") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetType
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::BoundaryConditionType::Value ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetType )
                , ( bp::arg("boundaryType") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::SetValue
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::SetValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateBoundaryConditionContainer
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionContainer_function_type)( ::boost::shared_ptr< BoundaryConditionsContainer< 2, 2, 1 > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateBoundaryConditionContainer"
                , UpdateBoundaryConditionContainer_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateBoundaryConditionContainer )
                , ( bp::arg("pContainer") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridBoundaryConditions"
                , UpdateRegularGridBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridCellBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridCellBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridCellBoundaryConditions"
                , UpdateRegularGridCellBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridCellBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridFacetBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridFacetBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridFacetBoundaryConditions"
                , UpdateRegularGridFacetBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridFacetBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPartBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPartBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridPartBoundaryConditions"
                , UpdateRegularGridPartBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPartBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPointBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPointBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridPointBoundaryConditions"
                , UpdateRegularGridPointBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridPointBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridSegmentBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridSegmentBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition2_exposer.def( 
                "UpdateRegularGridSegmentBoundaryConditions"
                , UpdateRegularGridSegmentBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 2 >::UpdateRegularGridSegmentBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        DiscreteContinuumBoundaryCondition2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumBoundaryCondition<2> > >();
    }

    { //::DiscreteContinuumBoundaryCondition< 3 >
        typedef bp::class_< DiscreteContinuumBoundaryCondition< 3 > > DiscreteContinuumBoundaryCondition3_exposer_t;
        DiscreteContinuumBoundaryCondition3_exposer_t DiscreteContinuumBoundaryCondition3_exposer = DiscreteContinuumBoundaryCondition3_exposer_t( "DiscreteContinuumBoundaryCondition3", bp::init< >() );
        bp::scope DiscreteContinuumBoundaryCondition3_scope( DiscreteContinuumBoundaryCondition3_exposer );
        { //::DiscreteContinuumBoundaryCondition< 3 >::Create
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumBoundaryCondition< 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::Create ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::BoundaryConditionType::Value ( exported_class_t::*GetType_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetType"
                , GetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetType ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetValue_function_type)(  ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::GetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef ::std::pair< bool, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetValue_function_type)( ::DimensionalChastePoint< 3 >,double ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::GetValue )
                , ( bp::arg("location"), bp::arg("tolerance") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetDomain
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDomain_function_type)( ::boost::shared_ptr< Part< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetDomain"
                , SetDomain_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetDomain )
                , ( bp::arg("pDomain") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLabelName_function_type)( ::std::string const & ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetLabelName"
                , SetLabelName_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetLabelName )
                , ( bp::arg("label") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetMesh
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMesh_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetMesh"
                , SetMesh_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetMesh )
                , ( bp::arg("pMesh") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetNetwork"
                , SetNetwork_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetPoints
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoints_function_type)( ::std::vector< DimensionalChastePoint<3> > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetPoints"
                , SetPoints_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetPoints )
                , ( bp::arg("points") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegularGrid_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetRegularGrid"
                , SetRegularGrid_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetRegularGrid )
                , ( bp::arg("pRegularGrid") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetSource
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSource_function_type)( ::BoundaryConditionSource::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetSource"
                , SetSource_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetSource )
                , ( bp::arg("boundarySource") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetType
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetType_function_type)( ::BoundaryConditionType::Value ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetType"
                , SetType_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetType )
                , ( bp::arg("boundaryType") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::SetValue
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetValue_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::SetValue )
                , ( bp::arg("value") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionContainer_function_type)( ::boost::shared_ptr< BoundaryConditionsContainer< 3, 3, 1 > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateBoundaryConditionContainer"
                , UpdateBoundaryConditionContainer_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateBoundaryConditionContainer )
                , ( bp::arg("pContainer") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridBoundaryConditions"
                , UpdateRegularGridBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridCellBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridCellBoundaryConditions"
                , UpdateRegularGridCellBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridCellBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridFacetBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridFacetBoundaryConditions"
                , UpdateRegularGridFacetBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridFacetBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPartBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPartBoundaryConditions"
                , UpdateRegularGridPartBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPartBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridPointBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridPointBoundaryConditions"
                , UpdateRegularGridPointBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridPointBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        { //::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions
        
            typedef DiscreteContinuumBoundaryCondition< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateRegularGridSegmentBoundaryConditions_function_type)( ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ) ;
            
            DiscreteContinuumBoundaryCondition3_exposer.def( 
                "UpdateRegularGridSegmentBoundaryConditions"
                , UpdateRegularGridSegmentBoundaryConditions_function_type( &::DiscreteContinuumBoundaryCondition< 3 >::UpdateRegularGridSegmentBoundaryConditions )
                , ( bp::arg("pBoundaryConditions") ) );
        
        }
        DiscreteContinuumBoundaryCondition3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumBoundaryCondition<3> > >();
    }

    { //::FiniteDifferenceSolver< 2 >
        typedef bp::class_< FiniteDifferenceSolver_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > > FiniteDifferenceSolver2_exposer_t;
        FiniteDifferenceSolver2_exposer_t FiniteDifferenceSolver2_exposer = FiniteDifferenceSolver2_exposer_t( "FiniteDifferenceSolver2", bp::init< >() );
        bp::scope FiniteDifferenceSolver2_scope( FiniteDifferenceSolver2_exposer );
        { //::FiniteDifferenceSolver< 2 >::Create
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteDifferenceSolver< 2 > > ( *Create_function_type )(  );
            
            FiniteDifferenceSolver2_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteDifferenceSolver< 2 >::Create ) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::GetRGBoundaryConditions
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ( exported_class_t::*GetRGBoundaryConditions_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetRGBoundaryConditions"
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 2 >::GetRGBoundaryConditions ) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::SetParabolicSolverTimeIncrement
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetParabolicSolverTimeIncrement_function_type)( double ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "SetParabolicSolverTimeIncrement"
                , SetParabolicSolverTimeIncrement_function_type( &::FiniteDifferenceSolver< 2 >::SetParabolicSolverTimeIncrement )
                , ( bp::arg("timeIncrement") ) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::Setup
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteDifferenceSolver< 2 >::Setup)
                , default_Setup_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::Solve
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteDifferenceSolver< 2 >::Solve)
                , default_Solve_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::Update
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteDifferenceSolver< 2 >::Update)
                , default_Update_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Update) );
        
        }
        { //::FiniteDifferenceSolver< 2 >::UpdateBoundaryConditionsEachSolve
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionsEachSolve_function_type)( bool ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateBoundaryConditionsEachSolve"
                , UpdateBoundaryConditionsEachSolve_function_type( &::FiniteDifferenceSolver< 2 >::UpdateBoundaryConditionsEachSolve )
                , ( bp::arg("doUpdate") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FiniteDifferenceSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteDifferenceSolver2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FiniteDifferenceSolver_less__2__greater__wrapper::default_Write) );
        
        }
        FiniteDifferenceSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteDifferenceSolver<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FiniteDifferenceSolver< 3 >
        typedef bp::class_< FiniteDifferenceSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FiniteDifferenceSolver3_exposer_t;
        FiniteDifferenceSolver3_exposer_t FiniteDifferenceSolver3_exposer = FiniteDifferenceSolver3_exposer_t( "FiniteDifferenceSolver3", bp::init< >() );
        bp::scope FiniteDifferenceSolver3_scope( FiniteDifferenceSolver3_exposer );
        { //::FiniteDifferenceSolver< 3 >::Create
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteDifferenceSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteDifferenceSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteDifferenceSolver< 3 >::Create ) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< std::vector< std::pair<bool, boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > > > ( exported_class_t::*GetRGBoundaryConditions_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetRGBoundaryConditions"
                , GetRGBoundaryConditions_function_type( &::FiniteDifferenceSolver< 3 >::GetRGBoundaryConditions ) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::SetParabolicSolverTimeIncrement
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetParabolicSolverTimeIncrement_function_type)( double ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "SetParabolicSolverTimeIncrement"
                , SetParabolicSolverTimeIncrement_function_type( &::FiniteDifferenceSolver< 3 >::SetParabolicSolverTimeIncrement )
                , ( bp::arg("timeIncrement") ) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Setup
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::FiniteDifferenceSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Solve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteDifferenceSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::Update
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteDifferenceSolver< 3 >::Update)
                , default_Update_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateBoundaryConditionsEachSolve_function_type)( bool ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateBoundaryConditionsEachSolve"
                , UpdateBoundaryConditionsEachSolve_function_type( &::FiniteDifferenceSolver< 3 >::UpdateBoundaryConditionsEachSolve )
                , ( bp::arg("doUpdate") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FiniteDifferenceSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteDifferenceSolver_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteDifferenceSolver3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FiniteDifferenceSolver_less__3__greater__wrapper::default_Write) );
        
        }
        FiniteDifferenceSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteDifferenceSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteDifferenceSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FiniteElementSolver< 2 >
        typedef bp::class_< FiniteElementSolver_less__2__greater__wrapper, bp::bases< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > > FiniteElementSolver2_exposer_t;
        FiniteElementSolver2_exposer_t FiniteElementSolver2_exposer = FiniteElementSolver2_exposer_t( "FiniteElementSolver2", bp::init< >() );
        bp::scope FiniteElementSolver2_scope( FiniteElementSolver2_exposer );
        { //::FiniteElementSolver< 2 >::Create
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteElementSolver< 2 > > ( *Create_function_type )(  );
            
            FiniteElementSolver2_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteElementSolver< 2 >::Create ) );
        
        }
        { //::FiniteElementSolver< 2 >::SetGuess
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGuess_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetGuess"
                , SetGuess_function_type( &::FiniteElementSolver< 2 >::SetGuess )
                , ( bp::arg("guess") ) );
        
        }
        { //::FiniteElementSolver< 2 >::SetUseLinearSolveForGuess
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseLinearSolveForGuess_function_type)( bool ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetUseLinearSolveForGuess"
                , SetUseLinearSolveForGuess_function_type( &::FiniteElementSolver< 2 >::SetUseLinearSolveForGuess )
                , ( bp::arg("useLinearSolve") ) );
        
        }
        { //::FiniteElementSolver< 2 >::SetUseSimpleNetonSolver
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSimpleNetonSolver_function_type)( bool ) ;
            
            FiniteElementSolver2_exposer.def( 
                "SetUseSimpleNetonSolver"
                , SetUseSimpleNetonSolver_function_type( &::FiniteElementSolver< 2 >::SetUseSimpleNetonSolver )
                , ( bp::arg("useNewton") ) );
        
        }
        { //::FiniteElementSolver< 2 >::Solve
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteElementSolver< 2 >::Solve)
                , default_Solve_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteElementSolver< 2 >::Update
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteElementSolver< 2 >::Update)
                , default_Update_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Update) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrationsAtCentroids_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetConcentrationsAtCentroids_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetConcentrationsAtCentroids"
                , GetConcentrationsAtCentroids_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetConcentrationsAtCentroids)
                , default_GetConcentrationsAtCentroids_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetConcentrationsAtCentroids) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( FiniteElementSolver_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Setup)
                , default_Setup_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateElementSolution"
                , UpdateElementSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateElementSolution)
                , default_UpdateElementSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateElementSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteElementSolver2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FiniteElementSolver< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteElementSolver2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FiniteElementSolver_less__2__greater__wrapper::default_Write) );
        
        }
        FiniteElementSolver2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteElementSolver<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 2 > >, boost::shared_ptr< AbstractUnstructuredGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FiniteElementSolver< 3 >
        typedef bp::class_< FiniteElementSolver_less__3__greater__wrapper, bp::bases< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > > FiniteElementSolver3_exposer_t;
        FiniteElementSolver3_exposer_t FiniteElementSolver3_exposer = FiniteElementSolver3_exposer_t( "FiniteElementSolver3", bp::init< >() );
        bp::scope FiniteElementSolver3_scope( FiniteElementSolver3_exposer );
        { //::FiniteElementSolver< 3 >::Create
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FiniteElementSolver< 3 > > ( *Create_function_type )(  );
            
            FiniteElementSolver3_exposer.def( 
                "Create"
                , Create_function_type( &::FiniteElementSolver< 3 >::Create ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGuess_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetGuess"
                , SetGuess_function_type( &::FiniteElementSolver< 3 >::SetGuess )
                , ( bp::arg("guess") ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseLinearSolveForGuess_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseLinearSolveForGuess"
                , SetUseLinearSolveForGuess_function_type( &::FiniteElementSolver< 3 >::SetUseLinearSolveForGuess )
                , ( bp::arg("useLinearSolve") ) );
        
        }
        { //::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSimpleNetonSolver_function_type)( bool ) ;
            
            FiniteElementSolver3_exposer.def( 
                "SetUseSimpleNetonSolver"
                , SetUseSimpleNetonSolver_function_type( &::FiniteElementSolver< 3 >::SetUseSimpleNetonSolver )
                , ( bp::arg("useNewton") ) );
        
        }
        { //::FiniteElementSolver< 3 >::Solve
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FiniteElementSolver< 3 >::Solve)
                , default_Solve_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FiniteElementSolver< 3 >::Update
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Update"
                , Update_function_type(&::FiniteElementSolver< 3 >::Update)
                , default_Update_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Update) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrationsAtCentroids_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetConcentrationsAtCentroids_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetConcentrationsAtCentroids"
                , GetConcentrationsAtCentroids_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetConcentrationsAtCentroids)
                , default_GetConcentrationsAtCentroids_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetConcentrationsAtCentroids) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkUnstructuredGrid > ( FiniteElementSolver_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Setup)
                , default_Setup_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateElementSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateElementSolution"
                , UpdateElementSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateElementSolution)
                , default_UpdateElementSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateElementSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FiniteElementSolver3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FiniteElementSolver< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FiniteElementSolver_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FiniteElementSolver3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractUnstructuredGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FiniteElementSolver_less__3__greater__wrapper::default_Write) );
        
        }
        FiniteElementSolver3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FiniteElementSolver<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 3 > >, boost::shared_ptr< AbstractUnstructuredGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FiniteElementSolver< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::FunctionMap< 2 >
        typedef bp::class_< FunctionMap_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > > FunctionMap2_exposer_t;
        FunctionMap2_exposer_t FunctionMap2_exposer = FunctionMap2_exposer_t( "FunctionMap2", bp::init< >() );
        bp::scope FunctionMap2_scope( FunctionMap2_exposer );
        { //::FunctionMap< 2 >::Create
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::boost::shared_ptr< FunctionMap< 2 > > ( *Create_function_type )(  );
            
            FunctionMap2_exposer.def( 
                "Create"
                , Create_function_type( &::FunctionMap< 2 >::Create ) );
        
        }
        { //::FunctionMap< 2 >::Solve
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Solve"
                , Solve_function_type(&::FunctionMap< 2 >::Solve)
                , default_Solve_function_type(&FunctionMap_less__2__greater__wrapper::default_Solve) );
        
        }
        { //::FunctionMap< 2 >::UpdateFunctionSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateFunctionSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateFunctionSolution"
                , UpdateFunctionSolution_function_type( &::FunctionMap< 2 >::UpdateFunctionSolution )
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__2__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__2__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<2> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__2__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ) ;
            
            FunctionMap2_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FunctionMap_less__2__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
                , default_Setup_function_type(&FunctionMap_less__2__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Update"
                , Update_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
                , default_Update_function_type(&FunctionMap_less__2__greater__wrapper::default_Update) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FunctionMap2_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__2__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write
        
            typedef FunctionMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FunctionMap_less__2__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FunctionMap2_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
                , default_Write_function_type(&FunctionMap_less__2__greater__wrapper::default_Write) );
        
        }
        FunctionMap2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FunctionMap<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::FunctionMap< 3 >
        typedef bp::class_< FunctionMap_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > > FunctionMap3_exposer_t;
        FunctionMap3_exposer_t FunctionMap3_exposer = FunctionMap3_exposer_t( "FunctionMap3", bp::init< >() );
        bp::scope FunctionMap3_scope( FunctionMap3_exposer );
        { //::FunctionMap< 3 >::Create
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::boost::shared_ptr< FunctionMap< 3 > > ( *Create_function_type )(  );
            
            FunctionMap3_exposer.def( 
                "Create"
                , Create_function_type( &::FunctionMap< 3 >::Create ) );
        
        }
        { //::FunctionMap< 3 >::Solve
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Solve"
                , Solve_function_type(&::FunctionMap< 3 >::Solve)
                , default_Solve_function_type(&FunctionMap_less__3__greater__wrapper::default_Solve) );
        
        }
        { //::FunctionMap< 3 >::UpdateFunctionSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateFunctionSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateFunctionSolution"
                , UpdateFunctionSolution_function_type( &::FunctionMap< 3 >::UpdateFunctionSolution )
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( FunctionMap_less__3__greater__wrapper::*default_GetConcentrations_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetConcentrations"
                , GetConcentrations_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
                , default_GetConcentrations_function_type(&FunctionMap_less__3__greater__wrapper::default_GetConcentrations)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)(  ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::std::vector< DimensionalChastePoint<3> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("rSamplePoints") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< RegularGrid< 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pGrid") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::std::vector< double > ( exported_class_t::*GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            typedef ::std::vector< double > ( FunctionMap_less__3__greater__wrapper::*default_GetSolution_function_type)( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ) ;
            
            FunctionMap3_exposer.def( 
                "GetSolution"
                , GetSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
                , default_GetSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetSolution)
                , ( bp::arg("pMesh") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkImageData > ( exported_class_t::*GetVtkSolution_function_type)(  ) ;
            typedef ::vtkSmartPointer< vtkImageData > ( FunctionMap_less__3__greater__wrapper::*default_GetVtkSolution_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "GetVtkSolution"
                , GetVtkSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
                , default_GetVtkSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_GetVtkSolution) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Setup_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Setup_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Setup"
                , Setup_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
                , default_Setup_function_type(&FunctionMap_less__3__greater__wrapper::default_Setup) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Update_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Update_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Update"
                , Update_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
                , default_Update_function_type(&FunctionMap_less__3__greater__wrapper::default_Update) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateCellData_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateCellData_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateCellData"
                , UpdateCellData_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
                , default_UpdateCellData_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateCellData) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > const & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< double > & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< double > & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_UpdateSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ) ;
            
            FunctionMap3_exposer.def( 
                "UpdateSolution"
                , UpdateSolution_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
                , default_UpdateSolution_function_type(&FunctionMap_less__3__greater__wrapper::default_UpdateSolution)
                , ( bp::arg("rData") ) );
        
        }
        { //::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write
        
            typedef FunctionMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            typedef void ( FunctionMap_less__3__greater__wrapper::*default_Write_function_type)(  ) ;
            
            FunctionMap3_exposer.def( 
                "Write"
                , Write_function_type(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
                , default_Write_function_type(&FunctionMap_less__3__greater__wrapper::default_Write) );
        
        }
        FunctionMap3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< FunctionMap<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< FunctionMap< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    bp::class_< GreensFunctionSolver_less__2__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 2 > > >( "GreensFunctionSolver2", bp::init< >() )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 2 >::SetSubSegmentCutoff )
            , ( bp::arg("value") ) )    
        .def( 
            "Solve"
            , (void ( ::GreensFunctionSolver<2>::* )(  ))(&::GreensFunctionSolver< 2 >::Solve)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Solve) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<2>::* )(  ))(&::AbstractDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<2> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 2, 2 > > ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Setup)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Setup) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Update)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateCellData)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< double > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< double > & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&GreensFunctionSolver_less__2__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<2>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 2 >::Write)
            , (void ( GreensFunctionSolver_less__2__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__2__greater__wrapper::default_Write) );

    bp::class_< GreensFunctionSolver_less__3__greater__wrapper, bp::bases< AbstractRegularGridDiscreteContinuumSolver< 3 > > >( "GreensFunctionSolver3", bp::init< >() )    
        .def( 
            "SetSubSegmentCutoff"
            , (void ( ::GreensFunctionSolver<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::GreensFunctionSolver< 3 >::SetSubSegmentCutoff )
            , ( bp::arg("value") ) )    
        .def( 
            "Solve"
            , (void ( ::GreensFunctionSolver<3>::* )(  ))(&::GreensFunctionSolver< 3 >::Solve)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Solve) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetConcentrations"
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetConcentrations)
            , (::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetConcentrations)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractDiscreteContinuumSolver<3>::* )(  ))(&::AbstractDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< DimensionalChastePoint<3> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("rSamplePoints") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< RegularGrid< 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pGrid") ) )    
        .def( 
            "GetSolution"
            , (::std::vector< double > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetSolution)
            , (::std::vector< double > ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::boost::shared_ptr< DiscreteContinuumMesh< 3, 3 > > ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetSolution)
            , ( bp::arg("pMesh") ) )    
        .def( 
            "GetVtkSolution"
            , (::vtkSmartPointer< vtkImageData > ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::GetVtkSolution)
            , (::vtkSmartPointer< vtkImageData > ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_GetVtkSolution) )    
        .def( 
            "Setup"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Setup)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Setup) )    
        .def( 
            "Update"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Update)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Update) )    
        .def( 
            "UpdateCellData"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateCellData)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateCellData) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< double > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< double > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&::AbstractDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > const & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< double > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< double > & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "UpdateSolution"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::UpdateSolution)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > & ))(&GreensFunctionSolver_less__3__greater__wrapper::default_UpdateSolution)
            , ( bp::arg("rData") ) )    
        .def( 
            "Write"
            , (void ( ::AbstractRegularGridDiscreteContinuumSolver<3>::* )(  ))(&::AbstractRegularGridDiscreteContinuumSolver< 3 >::Write)
            , (void ( GreensFunctionSolver_less__3__greater__wrapper::* )(  ))(&GreensFunctionSolver_less__3__greater__wrapper::default_Write) );

    { //::DiscreteContinuumLinearEllipticPde< 2, 2 >
        typedef bp::class_< DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumLinearEllipticPde< 2, 2 > > > DiscreteContinuumLinearEllipticPde2_2_exposer_t;
        DiscreteContinuumLinearEllipticPde2_2_exposer_t DiscreteContinuumLinearEllipticPde2_2_exposer = DiscreteContinuumLinearEllipticPde2_2_exposer_t( "DiscreteContinuumLinearEllipticPde2_2", bp::init< >() );
        bp::scope DiscreteContinuumLinearEllipticPde2_2_scope( DiscreteContinuumLinearEllipticPde2_2_exposer );
        { //::DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 2, 2 >::Create
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 2, 2 > > ( *Create_function_type )(  );
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumLinearEllipticPde< 2, 2 >::Create ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 2, 2 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::DiscreteContinuumLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            DiscreteContinuumLinearEllipticPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        DiscreteContinuumLinearEllipticPde2_2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumLinearEllipticPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearEllipticPde< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 2, 2 > >, boost::shared_ptr< AbstractLinearPde< 2, 2 > > >();
    }

    { //::DiscreteContinuumLinearEllipticPde< 3, 3 >
        typedef bp::class_< DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumLinearEllipticPde< 3, 3 > > > DiscreteContinuumLinearEllipticPde3_3_exposer_t;
        DiscreteContinuumLinearEllipticPde3_3_exposer_t DiscreteContinuumLinearEllipticPde3_3_exposer = DiscreteContinuumLinearEllipticPde3_3_exposer_t( "DiscreteContinuumLinearEllipticPde3_3", bp::init< >() );
        bp::scope DiscreteContinuumLinearEllipticPde3_3_scope( DiscreteContinuumLinearEllipticPde3_3_exposer );
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::Create
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > > ( *Create_function_type )(  );
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "Create"
                , Create_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::Create ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetContinuumLinearInUTerm_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "SetContinuumLinearInUTerm"
                , SetContinuumLinearInUTerm_function_type( &::DiscreteContinuumLinearEllipticPde< 3, 3 >::SetContinuumLinearInUTerm )
                , ( bp::arg("linearInUTerm") ) );
        
        }
        { //::DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::DiscreteContinuumLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            typedef double ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef DiscreteContinuumLinearEllipticPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            DiscreteContinuumLinearEllipticPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::AbstractDiscreteContinuumLinearEllipticPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&DiscreteContinuumLinearEllipticPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("arg0") ) );
        
        }
        DiscreteContinuumLinearEllipticPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DiscreteContinuumLinearEllipticPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearEllipticPde< 3, 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DiscreteContinuumLinearEllipticPde< 3, 3 > >, boost::shared_ptr< AbstractLinearPde< 3, 3 > > >();
    }

    { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >
        typedef bp::class_< MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper, bp::bases< AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 > > > MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t;
        MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer = MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde2_2", bp::init< >() );
        bp::scope MichaelisMentenSteadyStateDiffusionReactionPde2_2_scope( MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer );
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 2, 2 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeDiffusionTermPrime"
                , ComputeDiffusionTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeDiffusionTermPrime)
                , default_ComputeDiffusionTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeDiffusionTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 2 > const &,::Element< 2, 2 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeLinearSourceTerm_function_type)( ::ChastePoint< 2 > const & ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeLinearSourceTerm"
                , ComputeLinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeLinearSourceTerm)
                , default_ComputeLinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeLinearSourceTerm)
                , ( bp::arg("rX") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 2 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::Create
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > > ( *Create_function_type )(  );
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "Create"
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::Create ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::GetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMichaelisMentenThreshold_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "GetMichaelisMentenThreshold"
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::GetMichaelisMentenThreshold ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::SetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetMichaelisMentenThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "SetMichaelisMentenThreshold"
                , SetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 >::SetMichaelisMentenThreshold )
                , ( bp::arg("threshold") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 2, 2 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__2_comma__2__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        MichaelisMentenSteadyStateDiffusionReactionPde2_2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 2, 2 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 2 > > >();
    }

    { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >
        typedef bp::class_< MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper, bp::bases< AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 > > > MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t;
        MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer = MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer_t( "MichaelisMentenSteadyStateDiffusionReactionPde3_3", bp::init< >() );
        bp::scope MichaelisMentenSteadyStateDiffusionReactionPde3_3_scope( MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer );
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeConstantInUSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeConstantInUSourceTerm"
                , ComputeConstantInUSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeConstantInUSourceTerm)
                , default_ComputeConstantInUSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeConstantInUSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeDiffusionTerm"
                , ComputeDiffusionTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTerm)
                , default_ComputeDiffusionTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( exported_class_t::*ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef ::boost::numeric::ublas::c_matrix< double, 3, 3 > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeDiffusionTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeDiffusionTermPrime"
                , ComputeDiffusionTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeDiffusionTermPrime)
                , default_ComputeDiffusionTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeDiffusionTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( ::ChastePoint< 3 > const &,::Element< 3, 3 > * ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm )
                , ( bp::arg("rX"), bp::arg("pElement") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearInUCoeffInSourceTerm_function_type)( unsigned int ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearInUCoeffInSourceTerm"
                , ComputeLinearInUCoeffInSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearInUCoeffInSourceTerm)
                , default_ComputeLinearInUCoeffInSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearInUCoeffInSourceTerm)
                , ( bp::arg("gridIndex")=(unsigned int)(0) ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeLinearSourceTerm_function_type)( ::ChastePoint< 3 > const & ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeLinearSourceTerm"
                , ComputeLinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeLinearSourceTerm)
                , default_ComputeLinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeLinearSourceTerm)
                , ( bp::arg("rX") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTerm_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTerm"
                , ComputeNonlinearSourceTerm_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTerm)
                , default_ComputeNonlinearSourceTerm_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTerm)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            typedef double ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( ::ChastePoint< 3 > const &,double ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("rX"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_ComputeNonlinearSourceTermPrime_function_type)( unsigned int,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "ComputeNonlinearSourceTermPrime"
                , ComputeNonlinearSourceTermPrime_function_type(&::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::ComputeNonlinearSourceTermPrime)
                , default_ComputeNonlinearSourceTermPrime_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_ComputeNonlinearSourceTermPrime)
                , ( bp::arg("gridIndex"), bp::arg("u") ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::Create
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > > ( *Create_function_type )(  );
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "Create"
                , Create_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::Create ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::GetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetMichaelisMentenThreshold_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "GetMichaelisMentenThreshold"
                , GetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::GetMichaelisMentenThreshold ) );
        
        }
        { //::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::SetMichaelisMentenThreshold
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetMichaelisMentenThreshold_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "SetMichaelisMentenThreshold"
                , SetMichaelisMentenThreshold_function_type( &::MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 >::SetMichaelisMentenThreshold )
                , ( bp::arg("threshold") ) );
        
        }
        { //::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths
        
            typedef MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateDiscreteSourceStrengths_function_type)(  ) ;
            typedef void ( MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::*default_UpdateDiscreteSourceStrengths_function_type)(  ) ;
            
            MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.def( 
                "UpdateDiscreteSourceStrengths"
                , UpdateDiscreteSourceStrengths_function_type(&::AbstractDiscreteContinuumNonLinearEllipticPde< 3, 3 >::UpdateDiscreteSourceStrengths)
                , default_UpdateDiscreteSourceStrengths_function_type(&MichaelisMentenSteadyStateDiffusionReactionPde_less__3_comma__3__greater__wrapper::default_UpdateDiscreteSourceStrengths) );
        
        }
        MichaelisMentenSteadyStateDiffusionReactionPde3_3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde<3, 3> > >();
        bp::implicitly_convertible< boost::shared_ptr< MichaelisMentenSteadyStateDiffusionReactionPde< 3, 3 > >, boost::shared_ptr< AbstractNonlinearEllipticPde< 3 > > >();
    }

    { //::SolutionDependentDiscreteSource< 2 >
        typedef bp::class_< SolutionDependentDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > SolutionDependentDiscreteSource2_exposer_t;
        SolutionDependentDiscreteSource2_exposer_t SolutionDependentDiscreteSource2_exposer = SolutionDependentDiscreteSource2_exposer_t( "SolutionDependentDiscreteSource2", bp::init< >() );
        bp::scope SolutionDependentDiscreteSource2_scope( SolutionDependentDiscreteSource2_exposer );
        { //::SolutionDependentDiscreteSource< 2 >::Create
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< SolutionDependentDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "Create"
                , Create_function_type( &::SolutionDependentDiscreteSource< 2 >::Create ) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetConstantInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetConstantInUSinkRatePerSolutionQuantity"
                , SetConstantInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 2 >::SetConstantInUSinkRatePerSolutionQuantity )
                , ( bp::arg("value") ) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetLinearInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetLinearInUSinkRatePerSolutionQuantity"
                , SetLinearInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 2 >::SetLinearInUSinkRatePerSolutionQuantity )
                , ( bp::arg("value") ) );
        
        }
        { //::SolutionDependentDiscreteSource< 2 >::SetSolution
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "SetSolution"
                , SetSolution_function_type( &::SolutionDependentDiscreteSource< 2 >::SetSolution )
                , ( bp::arg("solution") ) );
        
        }
        { //::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues
        
            typedef SolutionDependentDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__2__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource2_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 2 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&SolutionDependentDiscreteSource_less__2__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        SolutionDependentDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< SolutionDependentDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< SolutionDependentDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::SolutionDependentDiscreteSource< 3 >
        typedef bp::class_< SolutionDependentDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > SolutionDependentDiscreteSource3_exposer_t;
        SolutionDependentDiscreteSource3_exposer_t SolutionDependentDiscreteSource3_exposer = SolutionDependentDiscreteSource3_exposer_t( "SolutionDependentDiscreteSource3", bp::init< >() );
        bp::scope SolutionDependentDiscreteSource3_scope( SolutionDependentDiscreteSource3_exposer );
        { //::SolutionDependentDiscreteSource< 3 >::Create
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< SolutionDependentDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::SolutionDependentDiscreteSource< 3 >::Create ) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::SolutionDependentDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetConstantInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetConstantInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetConstantInUSinkRatePerSolutionQuantity"
                , SetConstantInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 3 >::SetConstantInUSinkRatePerSolutionQuantity )
                , ( bp::arg("value") ) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetLinearInUSinkRatePerSolutionQuantity
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLinearInUSinkRatePerSolutionQuantity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetLinearInUSinkRatePerSolutionQuantity"
                , SetLinearInUSinkRatePerSolutionQuantity_function_type( &::SolutionDependentDiscreteSource< 3 >::SetLinearInUSinkRatePerSolutionQuantity )
                , ( bp::arg("value") ) );
        
        }
        { //::SolutionDependentDiscreteSource< 3 >::SetSolution
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSolution_function_type)( ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "SetSolution"
                , SetSolution_function_type( &::SolutionDependentDiscreteSource< 3 >::SetSolution )
                , ( bp::arg("solution") ) );
        
        }
        { //::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues
        
            typedef SolutionDependentDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( SolutionDependentDiscreteSource_less__3__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            SolutionDependentDiscreteSource3_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::DiscreteSource< 3 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&SolutionDependentDiscreteSource_less__3__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        SolutionDependentDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< SolutionDependentDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< SolutionDependentDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }

    { //::VesselBasedDiscreteSource< 2 >
        typedef bp::class_< VesselBasedDiscreteSource_less__2__greater__wrapper, bp::bases< DiscreteSource< 2 > > > VesselBasedDiscreteSource2_exposer_t;
        VesselBasedDiscreteSource2_exposer_t VesselBasedDiscreteSource2_exposer = VesselBasedDiscreteSource2_exposer_t( "VesselBasedDiscreteSource2", bp::init< >() );
        bp::scope VesselBasedDiscreteSource2_scope( VesselBasedDiscreteSource2_exposer );
        { //::VesselBasedDiscreteSource< 2 >::Create
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselBasedDiscreteSource< 2 > > ( *Create_function_type )(  );
            
            VesselBasedDiscreteSource2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselBasedDiscreteSource< 2 >::Create ) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::GetNonlinearTermRegularGridValues
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__2__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::VesselBasedDiscreteSource< 2 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&VesselBasedDiscreteSource_less__2__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetNumberOfCellsPerLength
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNumberOfCellsPerLength_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetNumberOfCellsPerLength"
                , SetNumberOfCellsPerLength_function_type( &::VesselBasedDiscreteSource< 2 >::SetNumberOfCellsPerLength )
                , ( bp::arg("cellsPerLength") ) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetReferenceConcentration
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::VesselBasedDiscreteSource< 2 >::SetReferenceConcentration )
                , ( bp::arg("value") ) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetReferenceHaematocrit
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetReferenceHaematocrit"
                , SetReferenceHaematocrit_function_type( &::VesselBasedDiscreteSource< 2 >::SetReferenceHaematocrit )
                , ( bp::arg("value") ) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetUptakeRatePerCell
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUptakeRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetUptakeRatePerCell"
                , SetUptakeRatePerCell_function_type( &::VesselBasedDiscreteSource< 2 >::SetUptakeRatePerCell )
                , ( bp::arg("ratePerCell") ) );
        
        }
        { //::VesselBasedDiscreteSource< 2 >::SetVesselPermeability
        
            typedef VesselBasedDiscreteSource< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource2_exposer.def( 
                "SetVesselPermeability"
                , SetVesselPermeability_function_type( &::VesselBasedDiscreteSource< 2 >::SetVesselPermeability )
                , ( bp::arg("value") ) );
        
        }
        VesselBasedDiscreteSource2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselBasedDiscreteSource<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselBasedDiscreteSource< 2 > >, boost::shared_ptr< DiscreteSource< 2 > > >();
    }

    { //::VesselBasedDiscreteSource< 3 >
        typedef bp::class_< VesselBasedDiscreteSource_less__3__greater__wrapper, bp::bases< DiscreteSource< 3 > > > VesselBasedDiscreteSource3_exposer_t;
        VesselBasedDiscreteSource3_exposer_t VesselBasedDiscreteSource3_exposer = VesselBasedDiscreteSource3_exposer_t( "VesselBasedDiscreteSource3", bp::init< >() );
        bp::scope VesselBasedDiscreteSource3_scope( VesselBasedDiscreteSource3_exposer );
        { //::VesselBasedDiscreteSource< 3 >::Create
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselBasedDiscreteSource< 3 > > ( *Create_function_type )(  );
            
            VesselBasedDiscreteSource3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselBasedDiscreteSource< 3 >::Create ) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetConstantInUMeshValues"
                , GetConstantInUMeshValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetConstantInUMeshValues)
                , default_GetConstantInUMeshValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetConstantInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetConstantInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetConstantInURegularGridValues"
                , GetConstantInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetConstantInURegularGridValues)
                , default_GetConstantInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetConstantInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInUMeshValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInUMeshValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetLinearInUMeshValues"
                , GetLinearInUMeshValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetLinearInUMeshValues)
                , default_GetLinearInUMeshValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInUMeshValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetLinearInURegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetLinearInURegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetLinearInURegularGridValues"
                , GetLinearInURegularGridValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetLinearInURegularGridValues)
                , default_GetLinearInURegularGridValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetLinearInURegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::GetNonlinearTermRegularGridValues
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetNonlinearTermRegularGridValues_function_type)(  ) ;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-3, 1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension, boost::units::static_rational<-1, 1> >, boost::units::list<boost::units::dim<boost::units::amount_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type> > >, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( VesselBasedDiscreteSource_less__3__greater__wrapper::*default_GetNonlinearTermRegularGridValues_function_type)(  ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "GetNonlinearTermRegularGridValues"
                , GetNonlinearTermRegularGridValues_function_type(&::VesselBasedDiscreteSource< 3 >::GetNonlinearTermRegularGridValues)
                , default_GetNonlinearTermRegularGridValues_function_type(&VesselBasedDiscreteSource_less__3__greater__wrapper::default_GetNonlinearTermRegularGridValues) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetNumberOfCellsPerLength
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNumberOfCellsPerLength_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetNumberOfCellsPerLength"
                , SetNumberOfCellsPerLength_function_type( &::VesselBasedDiscreteSource< 3 >::SetNumberOfCellsPerLength )
                , ( bp::arg("cellsPerLength") ) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetReferenceConcentration
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceConcentration_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -3, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetReferenceConcentration"
                , SetReferenceConcentration_function_type( &::VesselBasedDiscreteSource< 3 >::SetReferenceConcentration )
                , ( bp::arg("value") ) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetReferenceHaematocrit
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetReferenceHaematocrit"
                , SetReferenceHaematocrit_function_type( &::VesselBasedDiscreteSource< 3 >::SetReferenceHaematocrit )
                , ( bp::arg("value") ) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetUptakeRatePerCell
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUptakeRatePerCell_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::amount_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetUptakeRatePerCell"
                , SetUptakeRatePerCell_function_type( &::VesselBasedDiscreteSource< 3 >::SetUptakeRatePerCell )
                , ( bp::arg("ratePerCell") ) );
        
        }
        { //::VesselBasedDiscreteSource< 3 >::SetVesselPermeability
        
            typedef VesselBasedDiscreteSource< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselPermeability_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselBasedDiscreteSource3_exposer.def( 
                "SetVesselPermeability"
                , SetVesselPermeability_function_type( &::VesselBasedDiscreteSource< 3 >::SetVesselPermeability )
                , ( bp::arg("value") ) );
        
        }
        VesselBasedDiscreteSource3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselBasedDiscreteSource<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselBasedDiscreteSource< 3 > >, boost::shared_ptr< DiscreteSource< 3 > > >();
    }
}
