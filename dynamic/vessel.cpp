// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/map.hpp"

#include "vessel_headers.hpp"

namespace bp = boost::python;

struct AbstractVesselNetworkComponent_less__3__greater__wrapper : AbstractVesselNetworkComponent< 3 >, bp::wrapper< AbstractVesselNetworkComponent< 3 > > {

    AbstractVesselNetworkComponent_less__3__greater__wrapper( )
    : AbstractVesselNetworkComponent<3>( )
      , bp::wrapper< AbstractVesselNetworkComponent< 3 > >(){
        // null constructor
    
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ){
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct NodeFlowProperties_less__3__greater__wrapper : NodeFlowProperties< 3 >, bp::wrapper< NodeFlowProperties< 3 > > {

    NodeFlowProperties_less__3__greater__wrapper(NodeFlowProperties<3> const & arg )
    : NodeFlowProperties<3>( arg )
      , bp::wrapper< NodeFlowProperties< 3 > >(){
        // copy constructor
        
    }

    NodeFlowProperties_less__3__greater__wrapper( )
    : NodeFlowProperties<3>( )
      , bp::wrapper< NodeFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->NodeFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return NodeFlowProperties< 3 >::GetOutputData( );
    }

};

struct SegmentFlowProperties_less__3__greater__wrapper : SegmentFlowProperties< 3 >, bp::wrapper< SegmentFlowProperties< 3 > > {

    SegmentFlowProperties_less__3__greater__wrapper(SegmentFlowProperties<3> const & arg )
    : SegmentFlowProperties<3>( arg )
      , bp::wrapper< SegmentFlowProperties< 3 > >(){
        // copy constructor
        
    }

    SegmentFlowProperties_less__3__greater__wrapper( )
    : SegmentFlowProperties<3>( )
      , bp::wrapper< SegmentFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->SegmentFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return SegmentFlowProperties< 3 >::GetOutputData( );
    }

};

struct Vessel_less__3__greater__wrapper : Vessel< 3 >, bp::wrapper< Vessel< 3 > > {

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->Vessel< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return Vessel< 3 >::GetOutputData( );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->Vessel< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return Vessel< 3 >::GetRadius( );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->Vessel< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        Vessel< 3 >::SetRadius( radius );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

};

struct VesselFlowProperties_less__3__greater__wrapper : VesselFlowProperties< 3 >, bp::wrapper< VesselFlowProperties< 3 > > {

    VesselFlowProperties_less__3__greater__wrapper(VesselFlowProperties<3> const & arg )
    : VesselFlowProperties<3>( arg )
      , bp::wrapper< VesselFlowProperties< 3 > >(){
        // copy constructor
        
    }

    VesselFlowProperties_less__3__greater__wrapper( )
    : VesselFlowProperties<3>( )
      , bp::wrapper< VesselFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return VesselFlowProperties< 3 >::GetOutputData( );
    }

};

struct VesselNetwork_less__3__greater__wrapper : VesselNetwork< 3 >, bp::wrapper< VesselNetwork< 3 > > {

    VesselNetwork_less__3__greater__wrapper(VesselNetwork<3> const & arg )
    : VesselNetwork<3>( arg )
      , bp::wrapper< VesselNetwork< 3 > >(){
        // copy constructor
        
    }

    VesselNetwork_less__3__greater__wrapper( )
    : VesselNetwork<3>( )
      , bp::wrapper< VesselNetwork< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNetwork< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNetwork< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct VesselNode_less__3__greater__wrapper : VesselNode< 3 >, bp::wrapper< VesselNode< 3 > > {

    VesselNode_less__3__greater__wrapper(double v1, double v2, double v3, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > referenceLength )
    : VesselNode<3>( v1, v2, v3, referenceLength )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(double v1=0., double v2=0., double v3=0. )
    : VesselNode<3>( v1, v2, v3 )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(::DimensionalChastePoint< 3 > const & location )
    : VesselNode<3>( boost::ref(location) )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(::VesselNode< 3 > const & rExistingNode )
    : VesselNode<3>( boost::ref(rExistingNode) )
      , bp::wrapper< VesselNode< 3 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNode< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNode< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct VesselSegment_less__3__greater__wrapper : VesselSegment< 3 >, bp::wrapper< VesselSegment< 3 > > {

    VesselSegment_less__3__greater__wrapper(::VesselSegment< 3 > const & rSegment )
    : VesselSegment<3>( boost::ref(rSegment) )
      , bp::wrapper< VesselSegment< 3 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselSegment< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselSegment< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Vertex > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Vessel< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselSegment< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

boost::shared_ptr<VesselSegment<3> > (*VS3_Nodes)(boost::shared_ptr<VesselNode<3> >, boost::shared_ptr<VesselNode<3> >) = &VesselSegment<3>::Create;

boost::shared_ptr<VesselSegment<3> > (*VS3_Copy)(boost::shared_ptr<VesselSegment<3> >) = &VesselSegment<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_SingleSegment)(boost::shared_ptr<VesselSegment<3> >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_MultiSegment)(std::vector<boost::shared_ptr<VesselSegment<3> > >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_Nodes)(std::vector<boost::shared_ptr<VesselNode<3> > >) = &Vessel<3>::Create;

BOOST_PYTHON_MODULE(_chaste_project_Microvessel_vessel){
    bp::class_< std::vector< unsigned int > >("vector_less__unsigned_int__greater_")    
        .def( bp::indexing::vector_suite< std::vector< unsigned int > >() );

    bp::class_< std::vector< std::string > >("vector_less__std_scope_string__greater_")    
        .def( bp::indexing::vector_suite< std::vector< std::string > >() );

    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselSegment<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselSegment<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselSegment<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselNode<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselNode<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<Vessel<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<Vessel<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Vessel<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<Vertex> >
        typedef bp::class_< std::vector< boost::shared_ptr<Vertex> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Vertex> > >() );
    }

    { //::std::map< std::string, double >
        typedef bp::class_< std::map< std::string, double > > map_less__std_scope_string_comma__double__greater__exposer_t;
        map_less__std_scope_string_comma__double__greater__exposer_t map_less__std_scope_string_comma__double__greater__exposer = map_less__std_scope_string_comma__double__greater__exposer_t( "map_less__std_scope_string_comma__double__greater_" );
        bp::scope map_less__std_scope_string_comma__double__greater__scope( map_less__std_scope_string_comma__double__greater__exposer );
        map_less__std_scope_string_comma__double__greater__exposer.def( bp::indexing::map_suite< std::map< std::string, double > >() );
    }

    bp::class_< AbstractVesselNetworkComponent_less__3__greater__wrapper, boost::noncopyable >( "AbstractVesselNetworkComponent3", bp::init< >() )    
        .def( 
            "GetId"
            , (unsigned int ( ::AbstractVesselNetworkComponent<3>::* )(  )const)(&::AbstractVesselNetworkComponent< 3 >::GetId)
            , (unsigned int ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetId) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponent<3>::* )(  ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputData) ) )    
        .def( 
            "GetOutputDataKeys"
            , (::std::vector< std::string > ( ::AbstractVesselNetworkComponent<3>::* )(  ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
            , (::std::vector< std::string > ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetOutputDataKeys) )    
        .def( 
            "GetOutputDataValue"
            , (double ( ::AbstractVesselNetworkComponent<3>::* )( ::std::string const & ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
            , (double ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::std::string const & ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetOutputDataValue)
            , ( bp::arg("rKey") ) )    
        .def( 
            "GetRadius"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponent<3>::* )(  )const)(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetRadius) )    
        .def( 
            "SetId"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( unsigned int ))(&::AbstractVesselNetworkComponent< 3 >::SetId)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( unsigned int ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetId)
            , ( bp::arg("id") ) )    
        .def( 
            "SetOutputData"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( ::std::string const &,double ))(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::std::string const &,double ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetOutputData)
            , ( bp::arg("rKey"), bp::arg("value") ) )    
        .def( 
            "SetRadius"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetRadius)
            , ( bp::arg("radius") ) );

    { //::NodeFlowProperties< 3 >
        typedef bp::class_< NodeFlowProperties_less__3__greater__wrapper > NodeFlowProperties3_exposer_t;
        NodeFlowProperties3_exposer_t NodeFlowProperties3_exposer = NodeFlowProperties3_exposer_t( "NodeFlowProperties3", bp::init< >() );
        bp::scope NodeFlowProperties3_scope( NodeFlowProperties3_exposer );
        { //::NodeFlowProperties< 3 >::GetOutputData
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( NodeFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::NodeFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&NodeFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::NodeFlowProperties< 3 >::IsInputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsInputNode_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "IsInputNode"
                , IsInputNode_function_type( &::NodeFlowProperties< 3 >::IsInputNode ) );
        
        }
        { //::NodeFlowProperties< 3 >::IsOutputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsOutputNode_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "IsOutputNode"
                , IsOutputNode_function_type( &::NodeFlowProperties< 3 >::IsOutputNode ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetIsInputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsInputNode_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetIsInputNode"
                , SetIsInputNode_function_type( &::NodeFlowProperties< 3 >::SetIsInputNode )
                , ( bp::arg("isInput") ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetIsOutputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsOutputNode_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetIsOutputNode"
                , SetIsOutputNode_function_type( &::NodeFlowProperties< 3 >::SetIsOutputNode )
                , ( bp::arg("isOutput") ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetUseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseVelocityBoundaryCondition_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetUseVelocityBoundaryCondition"
                , SetUseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 3 >::SetUseVelocityBoundaryCondition )
                , ( bp::arg("useVelocity") ) );
        
        }
        { //::NodeFlowProperties< 3 >::UseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*UseVelocityBoundaryCondition_function_type)(  ) ;
            
            NodeFlowProperties3_exposer.def( 
                "UseVelocityBoundaryCondition"
                , UseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 3 >::UseVelocityBoundaryCondition ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< NodeFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< NodeFlowProperties< 3 > > > >();
    }

    { //::SegmentFlowProperties< 3 >
        typedef bp::class_< SegmentFlowProperties_less__3__greater__wrapper > SegmentFlowProperties3_exposer_t;
        SegmentFlowProperties3_exposer_t SegmentFlowProperties3_exposer = SegmentFlowProperties3_exposer_t( "SegmentFlowProperties3", bp::init< >() );
        bp::scope SegmentFlowProperties3_scope( SegmentFlowProperties3_exposer );
        { //::SegmentFlowProperties< 3 >::GetFlowRate
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::SegmentFlowProperties< 3 >::GetFlowRate ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetGrowthStimulus
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::SegmentFlowProperties< 3 >::GetGrowthStimulus ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetHaematocrit
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::SegmentFlowProperties< 3 >::GetHaematocrit ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetImpedance
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::SegmentFlowProperties< 3 >::GetImpedance ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetOutputData
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( SegmentFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::SegmentFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&SegmentFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetViscosity
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::SegmentFlowProperties< 3 >::GetViscosity ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetWallShearStress
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::SegmentFlowProperties< 3 >::GetWallShearStress ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetFlowRate
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::SegmentFlowProperties< 3 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetGrowthStimulus
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::SegmentFlowProperties< 3 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetHaematocrit
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::SegmentFlowProperties< 3 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetImpedance
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::SegmentFlowProperties< 3 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetViscosity
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::SegmentFlowProperties< 3 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetWallShearStress
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::SegmentFlowProperties< 3 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< SegmentFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< SegmentFlowProperties< 3 > > > >();
    }

    { //::SegmentLocation
        typedef bp::class_< SegmentLocation > SegmentLocation_exposer_t;
        SegmentLocation_exposer_t SegmentLocation_exposer = SegmentLocation_exposer_t( "SegmentLocation" );
        bp::scope SegmentLocation_scope( SegmentLocation_exposer );
        bp::enum_< SegmentLocation::Value>("Value")
            .value("Start", SegmentLocation::Start)
            .value("End", SegmentLocation::End)
            .export_values()
            ;
    }

    { //::Vessel< 3 >
        typedef bp::class_< Vessel_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > >, boost::noncopyable > Vessel3_exposer_t;
        Vessel3_exposer_t Vessel3_exposer = Vessel3_exposer_t( "Vessel3", bp::no_init );
        bp::scope Vessel3_scope( Vessel3_exposer );
        { //::Vessel< 3 >::AddSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegment"
                , AddSegment_function_type( &::Vessel< 3 >::AddSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::AddSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<3> > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegments"
                , AddSegments_function_type( &::Vessel< 3 >::AddSegments )
                , ( bp::arg("pSegments") ) );
        
        }
        { //::Vessel< 3 >::CopyDataFromExistingVessel
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "CopyDataFromExistingVessel"
                , CopyDataFromExistingVessel_function_type( &::Vessel< 3 >::CopyDataFromExistingVessel )
                , ( bp::arg("pTargetVessel") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselSegment<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("segments") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselNode<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("nodes") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pStartNode"), bp::arg("pEndNode") ) );
        
        }
        { //::Vessel< 3 >::DivideSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*DivideSegment_function_type)( ::DimensionalChastePoint< 3 > const &,double ) ;
            
            Vessel3_exposer.def( 
                "DivideSegment"
                , DivideSegment_function_type( &::Vessel< 3 >::DivideSegment )
                , ( bp::arg("rLocation"), bp::arg("distanceTolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::Vessel< 3 >::GetClosestEndNodeDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetClosestEndNodeDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "GetClosestEndNodeDistance"
                , GetClosestEndNodeDistance_function_type( &::Vessel< 3 >::GetClosestEndNodeDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetConnectedVessels
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*GetConnectedVessels_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetConnectedVessels"
                , GetConnectedVessels_function_type( &::Vessel< 3 >::GetConnectedVessels ) );
        
        }
        { //::Vessel< 3 >::GetDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            Vessel3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::Vessel< 3 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetEndNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetEndNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetEndNode"
                , GetEndNode_function_type( &::Vessel< 3 >::GetEndNode ) );
        
        }
        { //::Vessel< 3 >::GetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::Vessel< 3 >::GetFlowProperties ) );
        
        }
        { //::Vessel< 3 >::GetLength
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::Vessel< 3 >::GetLength ) );
        
        }
        { //::Vessel< 3 >::GetNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::Vessel< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetNodeAtOppositeEnd
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNodeAtOppositeEnd_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "GetNodeAtOppositeEnd"
                , GetNodeAtOppositeEnd_function_type( &::Vessel< 3 >::GetNodeAtOppositeEnd )
                , ( bp::arg("pQueryNode") ) );
        
        }
        { //::Vessel< 3 >::GetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::Vessel< 3 >::GetNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::Vessel< 3 >::GetNumberOfNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::Vessel< 3 >::GetNumberOfSegments ) );
        
        }
        { //::Vessel< 3 >::GetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( Vessel_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::Vessel< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::Vessel< 3 >::GetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( Vessel_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::Vessel< 3 >::GetRadius)
                , default_GetRadius_function_type(&Vessel_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::Vessel< 3 >::GetSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::Vessel< 3 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::Vessel< 3 >::GetSegments ) );
        
        }
        { //::Vessel< 3 >::GetStartNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetStartNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetStartNode"
                , GetStartNode_function_type( &::Vessel< 3 >::GetStartNode ) );
        
        }
        { //::Vessel< 3 >::IsConnectedTo
        
            typedef Vessel< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::Vessel< 3 >::IsConnectedTo )
                , ( bp::arg("pOtherVessel") ) );
        
        }
        { //::Vessel< 3 >::Remove
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "Remove"
                , Remove_function_type( &::Vessel< 3 >::Remove ) );
        
        }
        { //::Vessel< 3 >::RemoveSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveSegments_function_type)( ::SegmentLocation::Value ) ;
            
            Vessel3_exposer.def( 
                "RemoveSegments"
                , RemoveSegments_function_type( &::Vessel< 3 >::RemoveSegments )
                , ( bp::arg("location") ) );
        
        }
        { //::Vessel< 3 >::SetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::VesselFlowProperties< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::Vessel< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::Vessel< 3 >::SetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Vessel3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::Vessel< 3 >::SetRadius)
                , default_SetRadius_function_type(&Vessel_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        { //::Vessel< 3 >::UpdateNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::Vessel< 3 >::UpdateNodes ) );
        
        }
        { //::Vessel< 3 >::rGetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ( exported_class_t::*rGetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "rGetNodes"
                , rGetNodes_function_type( &::Vessel< 3 >::rGetNodes )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( Vessel_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&Vessel_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( Vessel_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef Vessel< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( Vessel_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&Vessel_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            Vessel3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        Vessel3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Vessel<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< Vessel< 3 > > > >();
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_SingleSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_MultiSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_Nodes));
    }

    { //::VesselDistribution
        typedef bp::class_< VesselDistribution > VesselDistribution_exposer_t;
        VesselDistribution_exposer_t VesselDistribution_exposer = VesselDistribution_exposer_t( "VesselDistribution" );
        bp::scope VesselDistribution_scope( VesselDistribution_exposer );
        bp::enum_< VesselDistribution::Value>("Value")
            .value("REGULAR", VesselDistribution::REGULAR)
            .value("UNIFORM", VesselDistribution::UNIFORM)
            .value("TWO_LAYER", VesselDistribution::TWO_LAYER)
            .value("CUSTOM", VesselDistribution::CUSTOM)
            .export_values()
            ;
    }

    { //::VesselFlowProperties< 3 >
        typedef bp::class_< VesselFlowProperties_less__3__greater__wrapper > VesselFlowProperties3_exposer_t;
        VesselFlowProperties3_exposer_t VesselFlowProperties3_exposer = VesselFlowProperties3_exposer_t( "VesselFlowProperties3", bp::init< >() );
        bp::scope VesselFlowProperties3_scope( VesselFlowProperties3_exposer );
        { //::VesselFlowProperties< 3 >::CheckSegments
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*CheckSegments_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "CheckSegments"
                , CheckSegments_function_type( &::VesselFlowProperties< 3 >::CheckSegments ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetFlowRate
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::VesselFlowProperties< 3 >::GetFlowRate ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetGrowthStimulus
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::VesselFlowProperties< 3 >::GetGrowthStimulus ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetHaematocrit
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::VesselFlowProperties< 3 >::GetHaematocrit ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetImpedance
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::VesselFlowProperties< 3 >::GetImpedance ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetOutputData
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( VesselFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselFlowProperties< 3 >::GetRegressionTime
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRegressionTime_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetRegressionTime"
                , GetRegressionTime_function_type( &::VesselFlowProperties< 3 >::GetRegressionTime ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetViscosity
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::VesselFlowProperties< 3 >::GetViscosity ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetWallShearStress
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::VesselFlowProperties< 3 >::GetWallShearStress ) );
        
        }
        { //::VesselFlowProperties< 3 >::HasRegressionTimerStarted
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasRegressionTimerStarted_function_type)(  ) ;
            
            VesselFlowProperties3_exposer.def( 
                "HasRegressionTimerStarted"
                , HasRegressionTimerStarted_function_type( &::VesselFlowProperties< 3 >::HasRegressionTimerStarted ) );
        
        }
        { //::VesselFlowProperties< 3 >::HasVesselRegressed
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasVesselRegressed_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "HasVesselRegressed"
                , HasVesselRegressed_function_type( &::VesselFlowProperties< 3 >::HasVesselRegressed )
                , ( bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 3 >::ResetRegressionTimer
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*ResetRegressionTimer_function_type)(  ) ;
            
            VesselFlowProperties3_exposer.def( 
                "ResetRegressionTimer"
                , ResetRegressionTimer_function_type( &::VesselFlowProperties< 3 >::ResetRegressionTimer ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetFlowRate
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::VesselFlowProperties< 3 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetGrowthStimulus
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::VesselFlowProperties< 3 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetHaematocrit
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::VesselFlowProperties< 3 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetImpedance
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::VesselFlowProperties< 3 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetRegressionTime
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegressionTime_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetRegressionTime"
                , SetRegressionTime_function_type( &::VesselFlowProperties< 3 >::SetRegressionTime )
                , ( bp::arg("time") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetTimeUntilRegression
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetTimeUntilRegression_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetTimeUntilRegression"
                , SetTimeUntilRegression_function_type( &::VesselFlowProperties< 3 >::SetTimeUntilRegression )
                , ( bp::arg("time"), bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetViscosity
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::VesselFlowProperties< 3 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetWallShearStress
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::VesselFlowProperties< 3 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        { //::VesselFlowProperties< 3 >::UpdateSegments
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<3> > > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselFlowProperties< 3 >::UpdateSegments )
                , ( bp::arg("segments") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< VesselFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselFlowProperties< 3 > > > >();
    }

    { //::VesselNetwork< 3 >
        typedef bp::class_< VesselNetwork_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselNetwork3_exposer_t;
        VesselNetwork3_exposer_t VesselNetwork3_exposer = VesselNetwork3_exposer_t( "VesselNetwork3", bp::init< >() );
        bp::scope VesselNetwork3_scope( VesselNetwork3_exposer );
        { //::VesselNetwork< 3 >::AddVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "AddVessel"
                , AddVessel_function_type( &::VesselNetwork< 3 >::AddVessel )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 3 >::AddVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "AddVessels"
                , AddVessels_function_type( &::VesselNetwork< 3 >::AddVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::CopySegmentFlowProperties
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopySegmentFlowProperties_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "CopySegmentFlowProperties"
                , CopySegmentFlowProperties_function_type( &::VesselNetwork< 3 >::CopySegmentFlowProperties )
                , ( bp::arg("index")=(unsigned int)(0) ) );
        
        }
        { //::VesselNetwork< 3 >::CopyVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*CopyVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 3 >::CopyVessels ) );
        
        }
        { //::VesselNetwork< 3 >::CopyVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*CopyVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 3 >::CopyVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::Create
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 3 > > ( *Create_function_type )(  );
            
            VesselNetwork3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetwork< 3 >::Create ) );
        
        }
        { //::VesselNetwork< 3 >::DivideVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*DivideVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "DivideVessel"
                , DivideVessel_function_type( &::VesselNetwork< 3 >::DivideVessel )
                , ( bp::arg("pVessel"), bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::ExtendVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*ExtendVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "ExtendVessel"
                , ExtendVessel_function_type( &::VesselNetwork< 3 >::ExtendVessel )
                , ( bp::arg("pVessel"), bp::arg("pEndNode"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselNetwork< 3 >::FormSprout
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*FormSprout_function_type)( ::DimensionalChastePoint< 3 > const &,::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "FormSprout"
                , FormSprout_function_type( &::VesselNetwork< 3 >::FormSprout )
                , ( bp::arg("sproutBaseLocation"), bp::arg("sproutTipLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetDistanceToNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistanceToNearestNode_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetDistanceToNearestNode"
                , GetDistanceToNearestNode_function_type( &::VesselNetwork< 3 >::GetDistanceToNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetExtents
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< DimensionalChastePoint< 3 >, DimensionalChastePoint< 3 > > ( exported_class_t::*GetExtents_function_type)( bool ) ;
            
            VesselNetwork3_exposer.def( 
                "GetExtents"
                , GetExtents_function_type( &::VesselNetwork< 3 >::GetExtents )
                , ( bp::arg("useRadii")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::GetMaxBranchesOnNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetMaxBranchesOnNode_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetMaxBranchesOnNode"
                , GetMaxBranchesOnNode_function_type( &::VesselNetwork< 3 >::GetMaxBranchesOnNode ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNearestNode_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 3 >::GetNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNearestNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 3 >::GetNearestNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselNode< 3 > >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("pNode"), bp::arg("sameVessel")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetNearestVessel_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestVessel"
                , GetNearestVessel_function_type( &::VesselNetwork< 3 >::GetNearestVessel )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselNetwork< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNodeIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNodeIndex_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNodeIndex"
                , GetNodeIndex_function_type( &::VesselNetwork< 3 >::GetNodeIndex )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselNetwork< 3 >::GetNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::VesselNetwork< 3 >::GetNumberOfNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfVesselNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVesselNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfVesselNodes"
                , GetNumberOfVesselNodes_function_type( &::VesselNetwork< 3 >::GetNumberOfVesselNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfVessels"
                , GetNumberOfVessels_function_type( &::VesselNetwork< 3 >::GetNumberOfVessels ) );
        
        }
        { //::VesselNetwork< 3 >::GetOutputData
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNetwork< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNetwork< 3 >::GetVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetVessel_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselNetwork< 3 >::GetVessel )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselEndNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetVesselEndNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselEndNodes"
                , GetVesselEndNodes_function_type( &::VesselNetwork< 3 >::GetVesselEndNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselIndex_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselIndex"
                , GetVesselIndex_function_type( &::VesselNetwork< 3 >::GetVesselIndex )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselSegmentIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselSegmentIndex_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselSegmentIndex"
                , GetVesselSegmentIndex_function_type( &::VesselNetwork< 3 >::GetVesselSegmentIndex )
                , ( bp::arg("pVesselSegment") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetVesselSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselSegments"
                , GetVesselSegments_function_type( &::VesselNetwork< 3 >::GetVesselSegments ) );
        
        }
        { //::VesselNetwork< 3 >::GetVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*GetVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVessels"
                , GetVessels_function_type( &::VesselNetwork< 3 >::GetVessels ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > >,double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("pVessels"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > >,double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("nodes"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeShortVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeShortVessels"
                , MergeShortVessels_function_type( &::VesselNetwork< 3 >::MergeShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNetwork< 3 >::NodeIsInNetwork
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef bool ( exported_class_t::*NodeIsInNetwork_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "NodeIsInNetwork"
                , NodeIsInNetwork_function_type( &::VesselNetwork< 3 >::NodeIsInNetwork )
                , ( bp::arg("pSourceNode") ) );
        
        }
        { //::VesselNetwork< 3 >::NumberOfNodesNearLocation
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*NumberOfNodesNearLocation_function_type)( ::DimensionalChastePoint< 3 > const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "NumberOfNodesNearLocation"
                , NumberOfNodesNearLocation_function_type( &::VesselNetwork< 3 >::NumberOfNodesNearLocation )
                , ( bp::arg("rLocation"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::RemoveShortVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "RemoveShortVessels"
                , RemoveShortVessels_function_type( &::VesselNetwork< 3 >::RemoveShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres, bp::arg("endsOnly")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 3 >::RemoveVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "RemoveVessel"
                , RemoveVessel_function_type( &::VesselNetwork< 3 >::RemoveVessel )
                , ( bp::arg("pVessel"), bp::arg("deleteVessel")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::SetNodeRadii
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetNodeRadii"
                , SetNodeRadii_function_type( &::VesselNetwork< 3 >::SetNodeRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 3 >::SetNodeRadiiFromSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadiiFromSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "SetNodeRadiiFromSegments"
                , SetNodeRadiiFromSegments_function_type( &::VesselNetwork< 3 >::SetNodeRadiiFromSegments ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentProperties
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentProperties_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentProperties"
                , SetSegmentProperties_function_type( &::VesselNetwork< 3 >::SetSegmentProperties )
                , ( bp::arg("prototype") ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentRadii
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentRadii"
                , SetSegmentRadii_function_type( &::VesselNetwork< 3 >::SetSegmentRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentViscosity
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentViscosity"
                , SetSegmentViscosity_function_type( &::VesselNetwork< 3 >::SetSegmentViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselNetwork< 3 >::Translate
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 3 > ) ;
            
            VesselNetwork3_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 3 >::Translate )
                , ( bp::arg("rTranslationVector") ) );
        
        }
        { //::VesselNetwork< 3 >::Translate
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 3 >,::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 3 >::Translate )
                , ( bp::arg("rTranslationVector"), bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateAll
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateAll_function_type)( bool ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateAll"
                , UpdateAll_function_type( &::VesselNetwork< 3 >::UpdateAll )
                , ( bp::arg("merge")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::VesselNetwork< 3 >::UpdateNodes ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselNetwork< 3 >::UpdateSegments ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateVesselIds
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselIds_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateVesselIds"
                , UpdateVesselIds_function_type( &::VesselNetwork< 3 >::UpdateVesselIds ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateVesselNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateVesselNodes"
                , UpdateVesselNodes_function_type( &::VesselNetwork< 3 >::UpdateVesselNodes ) );
        
        }
        { //::VesselNetwork< 3 >::VesselCrossesLineSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef bool ( exported_class_t::*VesselCrossesLineSegment_function_type)( ::DimensionalChastePoint< 3 > const &,::DimensionalChastePoint< 3 > const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "VesselCrossesLineSegment"
                , VesselCrossesLineSegment_function_type( &::VesselNetwork< 3 >::VesselCrossesLineSegment )
                , ( bp::arg("rCoord1"), bp::arg("rCoord2"), bp::arg("tolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::VesselNetwork< 3 >::Write
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)( ::std::string const & ) ;
            
            VesselNetwork3_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetwork< 3 >::Write )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNetwork_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNetwork3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNetwork_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNetwork3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNetwork3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetwork<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNetwork< 3 > > > >();
    }

    bp::class_< VesselNetworkGenerator< 3 > >( "VesselNetworkGenerator3", bp::init< >() )    
        .def( 
            "Generate3dNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > >,::std::vector< double >,::VesselDistribution::Value,double,bool,::std::vector< boost::shared_ptr<Vertex> > ))( &::VesselNetworkGenerator< 3 >::Generate3dNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance")=0., bp::arg("useBbox")=(bool)(false), bp::arg("seeds")=std::vector<boost::shared_ptr<Vertex> >() ) )    
        .def( 
            "GenerateBifurcationUnit"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 3 > ))( &::VesselNetworkGenerator< 3 >::GenerateBifurcationUnit )
            , ( bp::arg("vesselLength"), bp::arg("startPosition") ) )    
        .def( 
            "GenerateFromPart"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > > ))( &::VesselNetworkGenerator< 3 >::GenerateFromPart )
            , ( bp::arg("part") ) )    
        .def( 
            "GenerateHexagonalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::GenerateHexagonalNetwork )
            , ( bp::arg("width"), bp::arg("height"), bp::arg("vesselLength") ) )    
        .def( 
            "GenerateHexagonalUnit"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::GenerateHexagonalUnit )
            , ( bp::arg("vesselLength") ) )    
        .def( 
            "GenerateOvalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int,double,double ))( &::VesselNetworkGenerator< 3 >::GenerateOvalNetwork )
            , ( bp::arg("scaleFactor"), bp::arg("num_increments")=(unsigned int)(40), bp::arg("a_param")=0.5, bp::arg("b_param")=1. ) )    
        .def( 
            "GenerateParrallelNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > >,double,::VesselDistribution::Value,double,bool,::std::vector< boost::shared_ptr<Vertex> > ))( &::VesselNetworkGenerator< 3 >::GenerateParrallelNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance")=0., bp::arg("useBbox")=(bool)(false), bp::arg("seeds")=std::vector<boost::shared_ptr<Vertex> >() ) )    
        .def( 
            "GenerateSingleVessel"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 3 >,unsigned int,unsigned int ))( &::VesselNetworkGenerator< 3 >::GenerateSingleVessel )
            , ( bp::arg("vesselLength"), bp::arg("startPosition"), bp::arg("divisions")=(unsigned int)(0), bp::arg("axis")=(unsigned int)(2) ) )    
        .def( 
            "GenerateVoronoiNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int ))( &::VesselNetworkGenerator< 3 >::GenerateVoronoiNetwork )
            , ( bp::arg("cubeX"), bp::arg("cubeY"), bp::arg("cubeZ"), bp::arg("numPoints")=(unsigned int)(400) ) )    
        .def( 
            "MapToSphere"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double,double ))( &::VesselNetworkGenerator< 3 >::MapToSphere )
            , ( bp::arg("pInputUnit"), bp::arg("radius"), bp::arg("thickess"), bp::arg("azimuthExtent"), bp::arg("polarExtent") ) )    
        .def( 
            "PatternUnitByTranslation"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > >,::std::vector< unsigned int > ))( &::VesselNetworkGenerator< 3 >::PatternUnitByTranslation )
            , ( bp::arg("pInputUnit"), bp::arg("numberOfUnits") ) )    
        .def( 
            "SetReferenceLengthScale"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::SetReferenceLengthScale )
            , ( bp::arg("rReferenceLength") ) );

    { //::VesselNetworkReader< 3 >
        typedef bp::class_< VesselNetworkReader< 3 > > VesselNetworkReader3_exposer_t;
        VesselNetworkReader3_exposer_t VesselNetworkReader3_exposer = VesselNetworkReader3_exposer_t( "VesselNetworkReader3", bp::init< >() );
        bp::scope VesselNetworkReader3_scope( VesselNetworkReader3_exposer );
        { //::VesselNetworkReader< 3 >::Create
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkReader< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkReader3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkReader< 3 >::Create ) );
        
        }
        { //::VesselNetworkReader< 3 >::Read
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 3 > > ( exported_class_t::*Read_function_type)(  ) ;
            
            VesselNetworkReader3_exposer.def( 
                "Read"
                , Read_function_type( &::VesselNetworkReader< 3 >::Read ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetFileName
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkReader< 3 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetRadiusArrayName
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadiusArrayName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetRadiusArrayName"
                , SetRadiusArrayName_function_type( &::VesselNetworkReader< 3 >::SetRadiusArrayName )
                , ( bp::arg("rRadius") ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetReferenceLengthScale
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkReader< 3 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        VesselNetworkReader3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkReader<3> > >();
    }

    { //::VesselNetworkWriter< 3 >
        typedef bp::class_< VesselNetworkWriter< 3 > > VesselNetworkWriter3_exposer_t;
        VesselNetworkWriter3_exposer_t VesselNetworkWriter3_exposer = VesselNetworkWriter3_exposer_t( "VesselNetworkWriter3", bp::init< >() );
        bp::scope VesselNetworkWriter3_scope( VesselNetworkWriter3_exposer );
        { //::VesselNetworkWriter< 3 >::Create
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkWriter< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkWriter3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkWriter< 3 >::Create ) );
        
        }
        { //::VesselNetworkWriter< 3 >::GetOutput
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkPolyData > ( exported_class_t::*GetOutput_function_type)(  ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "GetOutput"
                , GetOutput_function_type( &::VesselNetworkWriter< 3 >::GetOutput ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetFileName
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkWriter< 3 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetReferenceLengthScale
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkWriter< 3 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetVesselNetwork
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkWriter< 3 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::Write
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetworkWriter< 3 >::Write ) );
        
        }
        VesselNetworkWriter3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkWriter<3> > >();
    }

    { //::VesselNode< 3 >
        typedef bp::class_< VesselNode_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselNode3_exposer_t;
        VesselNode3_exposer_t VesselNode3_exposer = VesselNode3_exposer_t( "VesselNode3", bp::init< double, double, double, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >(( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") )) );
        bp::scope VesselNode3_scope( VesselNode3_exposer );
        VesselNode3_exposer.def( bp::init< bp::optional< double, double, double > >(( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. )) );
        bp::implicitly_convertible< double, VesselNode< 3 > >();
        VesselNode3_exposer.def( bp::init< DimensionalChastePoint< 3 > const & >(( bp::arg("location") )) );
        bp::implicitly_convertible< DimensionalChastePoint< 3 > const &, VesselNode< 3 > >();
        VesselNode3_exposer.def( bp::init< VesselNode< 3 > const & >(( bp::arg("rExistingNode") )) );
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( double,double,double );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::DimensionalChastePoint< 3 > const & );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::VesselNode< 3 > const & );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("rExistingNode") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > > );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("pExistingNode") ) );
        
        }
        { //::VesselNode< 3 >::GetComparisonId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetComparisonId_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetComparisonId"
                , GetComparisonId_function_type( &::VesselNode< 3 >::GetComparisonId ) );
        
        }
        { //::VesselNode< 3 >::GetDistance
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselNode3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselNode< 3 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::GetFlowProperties
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< NodeFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselNode< 3 >::GetFlowProperties ) );
        
        }
        { //::VesselNode< 3 >::GetNumberOfSegments
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::VesselNode< 3 >::GetNumberOfSegments ) );
        
        }
        { //::VesselNode< 3 >::GetOutputData
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNode_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNode< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNode< 3 >::GetReferenceLengthScale
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetReferenceLengthScale_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetReferenceLengthScale"
                , GetReferenceLengthScale_function_type( &::VesselNode< 3 >::GetReferenceLengthScale ) );
        
        }
        { //::VesselNode< 3 >::GetSegment
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) const;
            
            VesselNode3_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::VesselNode< 3 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNode< 3 >::GetSegments
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetSegments_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::VesselNode< 3 >::GetSegments ) );
        
        }
        { //::VesselNode< 3 >::IsAttachedTo
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsAttachedTo_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > const ) const;
            
            VesselNode3_exposer.def( 
                "IsAttachedTo"
                , IsAttachedTo_function_type( &::VesselNode< 3 >::IsAttachedTo )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNode< 3 >::IsCoincident
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsCoincident_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselNode3_exposer.def( 
                "IsCoincident"
                , IsCoincident_function_type( &::VesselNode< 3 >::IsCoincident )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::IsMigrating
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsMigrating_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "IsMigrating"
                , IsMigrating_function_type( &::VesselNode< 3 >::IsMigrating ) );
        
        }
        { //::VesselNode< 3 >::SetComparisonId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetComparisonId_function_type)( unsigned int ) ;
            
            VesselNode3_exposer.def( 
                "SetComparisonId"
                , SetComparisonId_function_type( &::VesselNode< 3 >::SetComparisonId )
                , ( bp::arg("id") ) );
        
        }
        { //::VesselNode< 3 >::SetFlowProperties
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::NodeFlowProperties< 3 > const & ) ;
            
            VesselNode3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselNode< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::VesselNode< 3 >::SetIsMigrating
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsMigrating_function_type)( bool ) ;
            
            VesselNode3_exposer.def( 
                "SetIsMigrating"
                , SetIsMigrating_function_type( &::VesselNode< 3 >::SetIsMigrating )
                , ( bp::arg("isMigrating") ) );
        
        }
        { //::VesselNode< 3 >::SetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNode3_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 3 >::SetLocation )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::SetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 3 >::SetLocation )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z")=0., bp::arg("referenceLength")=9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNode< 3 >::SetReferenceLengthScale
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNode< 3 >::SetReferenceLengthScale )
                , ( bp::arg("lenthScale") ) );
        
        }
        { //::VesselNode< 3 >::rGetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::VesselNode< 3 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNode_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselNode_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNode_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselNode< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNode_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNode_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselNode_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNode3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselNode_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNode3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNode_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselNode_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNode3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNode<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNode< 3 > > > >();
    }

    { //::VesselSegment< 3 >
        typedef bp::class_< VesselSegment_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselSegment3_exposer_t;
        VesselSegment3_exposer_t VesselSegment3_exposer = VesselSegment3_exposer_t( "VesselSegment3", bp::no_init );
        bp::scope VesselSegment3_scope( VesselSegment3_exposer );
        VesselSegment3_exposer.def( bp::init< VesselSegment< 3 > const & >(( bp::arg("rSegment") )) );
        { //::VesselSegment< 3 >::CopyDataFromExistingSegment
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > const ) ;
            
            VesselSegment3_exposer.def( 
                "CopyDataFromExistingSegment"
                , CopyDataFromExistingSegment_function_type( &::VesselSegment< 3 >::CopyDataFromExistingSegment )
                , ( bp::arg("pTargetSegment") ) );
        
        }
        { //::VesselSegment< 3 >::Create
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > );
            
            VesselSegment3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 3 >::Create )
                , ( bp::arg("pNode1"), bp::arg("pNode2") ) );
        
        }
        { //::VesselSegment< 3 >::Create
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 3 > > );
            
            VesselSegment3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 3 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselSegment< 3 >::GetDistance
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselSegment3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselSegment< 3 >::GetDistance )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselSegment< 3 >::GetFlowProperties
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< SegmentFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselSegment< 3 >::GetFlowProperties ) );
        
        }
        { //::VesselSegment< 3 >::GetLength
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::VesselSegment< 3 >::GetLength ) );
        
        }
        { //::VesselSegment< 3 >::GetMidPoint
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > ( exported_class_t::*GetMidPoint_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetMidPoint"
                , GetMidPoint_function_type( &::VesselSegment< 3 >::GetMidPoint ) );
        
        }
        { //::VesselSegment< 3 >::GetNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) const;
            
            VesselSegment3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselSegment< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselSegment< 3 >::GetNodes
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< VesselNode< 3 > > > ( exported_class_t::*GetNodes_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselSegment< 3 >::GetNodes ) );
        
        }
        { //::VesselSegment< 3 >::GetOppositeNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetOppositeNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "GetOppositeNode"
                , GetOppositeNode_function_type( &::VesselSegment< 3 >::GetOppositeNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselSegment< 3 >::GetOutputData
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselSegment_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselSegment< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselSegment< 3 >::GetPointProjection
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > ( exported_class_t::*GetPointProjection_function_type)( ::DimensionalChastePoint< 3 > const &,bool ) const;
            
            VesselSegment3_exposer.def( 
                "GetPointProjection"
                , GetPointProjection_function_type( &::VesselSegment< 3 >::GetPointProjection )
                , ( bp::arg("location"), bp::arg("projectToEnds")=(bool)(false) ) );
        
        }
        { //::VesselSegment< 3 >::GetUnitTangent
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetUnitTangent_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetUnitTangent"
                , GetUnitTangent_function_type( &::VesselSegment< 3 >::GetUnitTangent ) );
        
        }
        { //::VesselSegment< 3 >::GetVessel
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetVessel_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselSegment< 3 >::GetVessel ) );
        
        }
        { //::VesselSegment< 3 >::HasNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "HasNode"
                , HasNode_function_type( &::VesselSegment< 3 >::HasNode )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselSegment< 3 >::IsConnectedTo
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::VesselSegment< 3 >::IsConnectedTo )
                , ( bp::arg("pOtherSegment") ) );
        
        }
        { //::VesselSegment< 3 >::Remove
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "Remove"
                , Remove_function_type( &::VesselSegment< 3 >::Remove ) );
        
        }
        { //::VesselSegment< 3 >::ReplaceNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*ReplaceNode_function_type)( unsigned int,::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselSegment3_exposer.def( 
                "ReplaceNode"
                , ReplaceNode_function_type( &::VesselSegment< 3 >::ReplaceNode )
                , ( bp::arg("oldNodeIndex"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselSegment< 3 >::SetFlowProperties
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::SegmentFlowProperties< 3 > const & ) ;
            
            VesselSegment3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselSegment< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselSegment_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselSegment_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselSegment_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselSegment_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselSegment_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselSegment_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselSegment3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselSegment_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselSegment3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselSegment_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselSegment3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselSegment_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselSegment3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselSegment<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselSegment< 3 > > > >();
        VesselSegment3_exposer.def("__init__", bp::make_constructor(VS3_Nodes));
        VesselSegment3_exposer.def("__init__", bp::make_constructor(VS3_Copy));
    }
}
