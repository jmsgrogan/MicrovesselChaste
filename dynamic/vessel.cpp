// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/map.hpp"

#include "vessel_headers.hpp"

namespace bp = boost::python;

struct AbstractVesselNetworkComponent_less__2__greater__wrapper : AbstractVesselNetworkComponent< 2 >, bp::wrapper< AbstractVesselNetworkComponent< 2 > > {

    AbstractVesselNetworkComponent_less__2__greater__wrapper( )
    : AbstractVesselNetworkComponent<2>( )
      , bp::wrapper< AbstractVesselNetworkComponent< 2 > >(){
        // null constructor
    
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetId( );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ){
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 2 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
    }

};

struct AbstractVesselNetworkComponent_less__3__greater__wrapper : AbstractVesselNetworkComponent< 3 >, bp::wrapper< AbstractVesselNetworkComponent< 3 > > {

    AbstractVesselNetworkComponent_less__3__greater__wrapper( )
    : AbstractVesselNetworkComponent<3>( )
      , bp::wrapper< AbstractVesselNetworkComponent< 3 > >(){
        // null constructor
    
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ){
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct AbstractVesselNetworkComponentProperties_less__2__greater__wrapper : AbstractVesselNetworkComponentProperties< 2 >, bp::wrapper< AbstractVesselNetworkComponentProperties< 2 > > {

    AbstractVesselNetworkComponentProperties_less__2__greater__wrapper( )
    : AbstractVesselNetworkComponentProperties<2>( )
      , bp::wrapper< AbstractVesselNetworkComponentProperties< 2 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct AbstractVesselNetworkComponentChemicalProperties_less__2__greater__wrapper : AbstractVesselNetworkComponentChemicalProperties< 2 >, bp::wrapper< AbstractVesselNetworkComponentChemicalProperties< 2 > > {

    AbstractVesselNetworkComponentChemicalProperties_less__2__greater__wrapper( )
    : AbstractVesselNetworkComponentChemicalProperties<2>( )
      , bp::wrapper< AbstractVesselNetworkComponentChemicalProperties< 2 > >(){
        // null constructor
    
    }

    virtual void SetPermeability( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > permeability ) {
        if( bp::override func_SetPermeability = this->get_override( "SetPermeability" ) )
            func_SetPermeability( permeability );
        else{
            this->AbstractVesselNetworkComponentChemicalProperties< 2 >::SetPermeability( permeability );
        }
    }
    
    void default_SetPermeability( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > permeability ) {
        AbstractVesselNetworkComponentChemicalProperties< 2 >::SetPermeability( permeability );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct AbstractVesselNetworkComponentProperties_less__3__greater__wrapper : AbstractVesselNetworkComponentProperties< 3 >, bp::wrapper< AbstractVesselNetworkComponentProperties< 3 > > {

    AbstractVesselNetworkComponentProperties_less__3__greater__wrapper( )
    : AbstractVesselNetworkComponentProperties<3>( )
      , bp::wrapper< AbstractVesselNetworkComponentProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct AbstractVesselNetworkComponentChemicalProperties_less__3__greater__wrapper : AbstractVesselNetworkComponentChemicalProperties< 3 >, bp::wrapper< AbstractVesselNetworkComponentChemicalProperties< 3 > > {

    AbstractVesselNetworkComponentChemicalProperties_less__3__greater__wrapper( )
    : AbstractVesselNetworkComponentChemicalProperties<3>( )
      , bp::wrapper< AbstractVesselNetworkComponentChemicalProperties< 3 > >(){
        // null constructor
    
    }

    virtual void SetPermeability( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > permeability ) {
        if( bp::override func_SetPermeability = this->get_override( "SetPermeability" ) )
            func_SetPermeability( permeability );
        else{
            this->AbstractVesselNetworkComponentChemicalProperties< 3 >::SetPermeability( permeability );
        }
    }
    
    void default_SetPermeability( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > permeability ) {
        AbstractVesselNetworkComponentChemicalProperties< 3 >::SetPermeability( permeability );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct AbstractVesselNetworkComponentFlowProperties_less__2__greater__wrapper : AbstractVesselNetworkComponentFlowProperties< 2 >, bp::wrapper< AbstractVesselNetworkComponentFlowProperties< 2 > > {

    AbstractVesselNetworkComponentFlowProperties_less__2__greater__wrapper( )
    : AbstractVesselNetworkComponentFlowProperties<2>( )
      , bp::wrapper< AbstractVesselNetworkComponentFlowProperties< 2 > >(){
        // null constructor
    
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct AbstractVesselNetworkComponentFlowProperties_less__3__greater__wrapper : AbstractVesselNetworkComponentFlowProperties< 3 >, bp::wrapper< AbstractVesselNetworkComponentFlowProperties< 3 > > {

    AbstractVesselNetworkComponentFlowProperties_less__3__greater__wrapper( )
    : AbstractVesselNetworkComponentFlowProperties<3>( )
      , bp::wrapper< AbstractVesselNetworkComponentFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const {
        bp::override func_GetOutputData = this->get_override( "GetOutputData" );
        return func_GetOutputData(  );
    }

};

struct DensityMap_less__2__greater__wrapper : DensityMap< 2 >, bp::wrapper< DensityMap< 2 > > {

    DensityMap_less__2__greater__wrapper(DensityMap<2> const & arg )
    : DensityMap<2>( arg )
      , bp::wrapper< DensityMap< 2 > >(){
        // copy constructor
        
    }

    DensityMap_less__2__greater__wrapper( )
    : DensityMap<2>( )
      , bp::wrapper< DensityMap< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->DensityMap< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        DensityMap< 2 >::Solve( );
    }

};

struct DensityMap_less__3__greater__wrapper : DensityMap< 3 >, bp::wrapper< DensityMap< 3 > > {

    DensityMap_less__3__greater__wrapper(DensityMap<3> const & arg )
    : DensityMap<3>( arg )
      , bp::wrapper< DensityMap< 3 > >(){
        // copy constructor
        
    }

    DensityMap_less__3__greater__wrapper( )
    : DensityMap<3>( )
      , bp::wrapper< DensityMap< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->DensityMap< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        DensityMap< 3 >::Solve( );
    }

};

struct DistanceMap_less__2__greater__wrapper : DistanceMap< 2 >, bp::wrapper< DistanceMap< 2 > > {

    DistanceMap_less__2__greater__wrapper(DistanceMap<2> const & arg )
    : DistanceMap<2>( arg )
      , bp::wrapper< DistanceMap< 2 > >(){
        // copy constructor
        
    }

    DistanceMap_less__2__greater__wrapper( )
    : DistanceMap<2>( )
      , bp::wrapper< DistanceMap< 2 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->DistanceMap< 2 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        DistanceMap< 2 >::Solve( );
    }

};

struct DistanceMap_less__3__greater__wrapper : DistanceMap< 3 >, bp::wrapper< DistanceMap< 3 > > {

    DistanceMap_less__3__greater__wrapper(DistanceMap<3> const & arg )
    : DistanceMap<3>( arg )
      , bp::wrapper< DistanceMap< 3 > >(){
        // copy constructor
        
    }

    DistanceMap_less__3__greater__wrapper( )
    : DistanceMap<3>( )
      , bp::wrapper< DistanceMap< 3 > >(){
        // null constructor
    
    }

    virtual void Solve(  ) {
        if( bp::override func_Solve = this->get_override( "Solve" ) )
            func_Solve(  );
        else{
            this->DistanceMap< 3 >::Solve(  );
        }
    }
    
    void default_Solve(  ) {
        DistanceMap< 3 >::Solve( );
    }

};

struct NodeFlowProperties_less__2__greater__wrapper : NodeFlowProperties< 2 >, bp::wrapper< NodeFlowProperties< 2 > > {

    NodeFlowProperties_less__2__greater__wrapper(NodeFlowProperties<2> const & arg )
    : NodeFlowProperties<2>( arg )
      , bp::wrapper< NodeFlowProperties< 2 > >(){
        // copy constructor
        
    }

    NodeFlowProperties_less__2__greater__wrapper( )
    : NodeFlowProperties<2>( )
      , bp::wrapper< NodeFlowProperties< 2 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->NodeFlowProperties< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return NodeFlowProperties< 2 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
    }

};

struct NodeFlowProperties_less__3__greater__wrapper : NodeFlowProperties< 3 >, bp::wrapper< NodeFlowProperties< 3 > > {

    NodeFlowProperties_less__3__greater__wrapper(NodeFlowProperties<3> const & arg )
    : NodeFlowProperties<3>( arg )
      , bp::wrapper< NodeFlowProperties< 3 > >(){
        // copy constructor
        
    }

    NodeFlowProperties_less__3__greater__wrapper( )
    : NodeFlowProperties<3>( )
      , bp::wrapper< NodeFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->NodeFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return NodeFlowProperties< 3 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
    }

};

struct SegmentFlowProperties_less__2__greater__wrapper : SegmentFlowProperties< 2 >, bp::wrapper< SegmentFlowProperties< 2 > > {

    SegmentFlowProperties_less__2__greater__wrapper(SegmentFlowProperties<2> const & arg )
    : SegmentFlowProperties<2>( arg )
      , bp::wrapper< SegmentFlowProperties< 2 > >(){
        // copy constructor
        
    }

    SegmentFlowProperties_less__2__greater__wrapper( )
    : SegmentFlowProperties<2>( )
      , bp::wrapper< SegmentFlowProperties< 2 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->SegmentFlowProperties< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return SegmentFlowProperties< 2 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
    }

};

struct SegmentFlowProperties_less__3__greater__wrapper : SegmentFlowProperties< 3 >, bp::wrapper< SegmentFlowProperties< 3 > > {

    SegmentFlowProperties_less__3__greater__wrapper(SegmentFlowProperties<3> const & arg )
    : SegmentFlowProperties<3>( arg )
      , bp::wrapper< SegmentFlowProperties< 3 > >(){
        // copy constructor
        
    }

    SegmentFlowProperties_less__3__greater__wrapper( )
    : SegmentFlowProperties<3>( )
      , bp::wrapper< SegmentFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->SegmentFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return SegmentFlowProperties< 3 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
    }

};

struct Vessel_less__2__greater__wrapper : Vessel< 2 >, bp::wrapper< Vessel< 2 > > {

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->Vessel< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return Vessel< 2 >::GetOutputData( );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->Vessel< 2 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return Vessel< 2 >::GetRadius( );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->Vessel< 2 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        Vessel< 2 >::SetRadius( radius );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 2 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
    }

};

struct Vessel_less__3__greater__wrapper : Vessel< 3 >, bp::wrapper< Vessel< 3 > > {

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->Vessel< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return Vessel< 3 >::GetOutputData( );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->Vessel< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return Vessel< 3 >::GetRadius( );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->Vessel< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        Vessel< 3 >::SetRadius( radius );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

};

struct VesselFlowProperties_less__2__greater__wrapper : VesselFlowProperties< 2 >, bp::wrapper< VesselFlowProperties< 2 > > {

    VesselFlowProperties_less__2__greater__wrapper(VesselFlowProperties<2> const & arg )
    : VesselFlowProperties<2>( arg )
      , bp::wrapper< VesselFlowProperties< 2 > >(){
        // copy constructor
        
    }

    VesselFlowProperties_less__2__greater__wrapper( )
    : VesselFlowProperties<2>( )
      , bp::wrapper< VesselFlowProperties< 2 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselFlowProperties< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return VesselFlowProperties< 2 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure( pressure );
    }

};

struct VesselFlowProperties_less__3__greater__wrapper : VesselFlowProperties< 3 >, bp::wrapper< VesselFlowProperties< 3 > > {

    VesselFlowProperties_less__3__greater__wrapper(VesselFlowProperties<3> const & arg )
    : VesselFlowProperties<3>( arg )
      , bp::wrapper< VesselFlowProperties< 3 > >(){
        // copy constructor
        
    }

    VesselFlowProperties_less__3__greater__wrapper( )
    : VesselFlowProperties<3>( )
      , bp::wrapper< VesselFlowProperties< 3 > >(){
        // null constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) const  {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselFlowProperties< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) const  {
        return VesselFlowProperties< 3 >::GetOutputData( );
    }

    virtual void SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        if( bp::override func_SetPressure = this->get_override( "SetPressure" ) )
            func_SetPressure( pressure );
        else{
            this->AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
        }
    }
    
    void default_SetPressure( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > pressure ) {
        AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure( pressure );
    }

};

struct VesselNetwork_less__2__greater__wrapper : VesselNetwork< 2 >, bp::wrapper< VesselNetwork< 2 > > {

    VesselNetwork_less__2__greater__wrapper(VesselNetwork<2> const & arg )
    : VesselNetwork<2>( arg )
      , bp::wrapper< VesselNetwork< 2 > >(){
        // copy constructor
        
    }

    VesselNetwork_less__2__greater__wrapper( )
    : VesselNetwork<2>( )
      , bp::wrapper< VesselNetwork< 2 > >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< VesselNode< 2 > > DivideVessel( ::boost::shared_ptr< Vessel< 2 > > pVessel, ::DimensionalChastePoint< 2 > const & rLocation ) {
        if( bp::override func_DivideVessel = this->get_override( "DivideVessel" ) )
            return func_DivideVessel( pVessel, boost::ref(rLocation) );
        else{
            return this->VesselNetwork< 2 >::DivideVessel( pVessel, boost::ref(rLocation) );
        }
    }
    
    ::boost::shared_ptr< VesselNode< 2 > > default_DivideVessel( ::boost::shared_ptr< Vessel< 2 > > pVessel, ::DimensionalChastePoint< 2 > const & rLocation ) {
        return VesselNetwork< 2 >::DivideVessel( pVessel, boost::ref(rLocation) );
    }

    virtual void ExtendVessel( ::boost::shared_ptr< Vessel< 2 > > pVessel, ::boost::shared_ptr< VesselNode< 2 > > pEndNode, ::boost::shared_ptr< VesselNode< 2 > > pNewNode ) {
        if( bp::override func_ExtendVessel = this->get_override( "ExtendVessel" ) )
            func_ExtendVessel( pVessel, pEndNode, pNewNode );
        else{
            this->VesselNetwork< 2 >::ExtendVessel( pVessel, pEndNode, pNewNode );
        }
    }
    
    void default_ExtendVessel( ::boost::shared_ptr< Vessel< 2 > > pVessel, ::boost::shared_ptr< VesselNode< 2 > > pEndNode, ::boost::shared_ptr< VesselNode< 2 > > pNewNode ) {
        VesselNetwork< 2 >::ExtendVessel( pVessel, pEndNode, pNewNode );
    }

    virtual ::boost::shared_ptr< Vessel< 2 > > FormSprout( ::DimensionalChastePoint< 2 > const & sproutBaseLocation, ::DimensionalChastePoint< 2 > const & sproutTipLocation ) {
        if( bp::override func_FormSprout = this->get_override( "FormSprout" ) )
            return func_FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
        else{
            return this->VesselNetwork< 2 >::FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
        }
    }
    
    ::boost::shared_ptr< Vessel< 2 > > default_FormSprout( ::DimensionalChastePoint< 2 > const & sproutBaseLocation, ::DimensionalChastePoint< 2 > const & sproutTipLocation ) {
        return VesselNetwork< 2 >::FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNetwork< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNetwork< 2 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 2 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
    }

};

struct VesselNetwork_less__3__greater__wrapper : VesselNetwork< 3 >, bp::wrapper< VesselNetwork< 3 > > {

    VesselNetwork_less__3__greater__wrapper(VesselNetwork<3> const & arg )
    : VesselNetwork<3>( arg )
      , bp::wrapper< VesselNetwork< 3 > >(){
        // copy constructor
        
    }

    VesselNetwork_less__3__greater__wrapper( )
    : VesselNetwork<3>( )
      , bp::wrapper< VesselNetwork< 3 > >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< VesselNode< 3 > > DivideVessel( ::boost::shared_ptr< Vessel< 3 > > pVessel, ::DimensionalChastePoint< 3 > const & rLocation ) {
        if( bp::override func_DivideVessel = this->get_override( "DivideVessel" ) )
            return func_DivideVessel( pVessel, boost::ref(rLocation) );
        else{
            return this->VesselNetwork< 3 >::DivideVessel( pVessel, boost::ref(rLocation) );
        }
    }
    
    ::boost::shared_ptr< VesselNode< 3 > > default_DivideVessel( ::boost::shared_ptr< Vessel< 3 > > pVessel, ::DimensionalChastePoint< 3 > const & rLocation ) {
        return VesselNetwork< 3 >::DivideVessel( pVessel, boost::ref(rLocation) );
    }

    virtual void ExtendVessel( ::boost::shared_ptr< Vessel< 3 > > pVessel, ::boost::shared_ptr< VesselNode< 3 > > pEndNode, ::boost::shared_ptr< VesselNode< 3 > > pNewNode ) {
        if( bp::override func_ExtendVessel = this->get_override( "ExtendVessel" ) )
            func_ExtendVessel( pVessel, pEndNode, pNewNode );
        else{
            this->VesselNetwork< 3 >::ExtendVessel( pVessel, pEndNode, pNewNode );
        }
    }
    
    void default_ExtendVessel( ::boost::shared_ptr< Vessel< 3 > > pVessel, ::boost::shared_ptr< VesselNode< 3 > > pEndNode, ::boost::shared_ptr< VesselNode< 3 > > pNewNode ) {
        VesselNetwork< 3 >::ExtendVessel( pVessel, pEndNode, pNewNode );
    }

    virtual ::boost::shared_ptr< Vessel< 3 > > FormSprout( ::DimensionalChastePoint< 3 > const & sproutBaseLocation, ::DimensionalChastePoint< 3 > const & sproutTipLocation ) {
        if( bp::override func_FormSprout = this->get_override( "FormSprout" ) )
            return func_FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
        else{
            return this->VesselNetwork< 3 >::FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
        }
    }
    
    ::boost::shared_ptr< Vessel< 3 > > default_FormSprout( ::DimensionalChastePoint< 3 > const & sproutBaseLocation, ::DimensionalChastePoint< 3 > const & sproutTipLocation ) {
        return VesselNetwork< 3 >::FormSprout( boost::ref(sproutBaseLocation), boost::ref(sproutTipLocation) );
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNetwork< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNetwork< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct VesselNode_less__2__greater__wrapper : VesselNode< 2 >, bp::wrapper< VesselNode< 2 > > {

    VesselNode_less__2__greater__wrapper(double v1, double v2, double v3, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > referenceLength )
    : VesselNode<2>( v1, v2, v3, referenceLength )
      , bp::wrapper< VesselNode< 2 > >(){
        // constructor
    
    }

    VesselNode_less__2__greater__wrapper(double v1=0., double v2=0., double v3=0. )
    : VesselNode<2>( v1, v2, v3 )
      , bp::wrapper< VesselNode< 2 > >(){
        // constructor
    
    }

    VesselNode_less__2__greater__wrapper(::DimensionalChastePoint< 2 > const & location )
    : VesselNode<2>( boost::ref(location) )
      , bp::wrapper< VesselNode< 2 > >(){
        // constructor
    
    }

    VesselNode_less__2__greater__wrapper(::VesselNode< 2 > const & rExistingNode )
    : VesselNode<2>( boost::ref(rExistingNode) )
      , bp::wrapper< VesselNode< 2 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNode< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNode< 2 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 2 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
    }

};

struct VesselNode_less__3__greater__wrapper : VesselNode< 3 >, bp::wrapper< VesselNode< 3 > > {

    VesselNode_less__3__greater__wrapper(double v1, double v2, double v3, ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > referenceLength )
    : VesselNode<3>( v1, v2, v3, referenceLength )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(double v1=0., double v2=0., double v3=0. )
    : VesselNode<3>( v1, v2, v3 )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(::DimensionalChastePoint< 3 > const & location )
    : VesselNode<3>( boost::ref(location) )
      , bp::wrapper< VesselNode< 3 > >(){
        // constructor
    
    }

    VesselNode_less__3__greater__wrapper(::VesselNode< 3 > const & rExistingNode )
    : VesselNode<3>( boost::ref(rExistingNode) )
      , bp::wrapper< VesselNode< 3 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselNode< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselNode< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

struct VesselSegment_less__2__greater__wrapper : VesselSegment< 2 >, bp::wrapper< VesselSegment< 2 > > {

    VesselSegment_less__2__greater__wrapper(::VesselSegment< 2 > const & rSegment )
    : VesselSegment<2>( boost::ref(rSegment) )
      , bp::wrapper< VesselSegment< 2 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselSegment< 2 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselSegment< 2 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 2 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 2 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 2 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 2 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 2 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 2 >::SetRadius( radius );
    }

};

struct VesselSegment_less__3__greater__wrapper : VesselSegment< 3 >, bp::wrapper< VesselSegment< 3 > > {

    VesselSegment_less__3__greater__wrapper(::VesselSegment< 3 > const & rSegment )
    : VesselSegment<3>( boost::ref(rSegment) )
      , bp::wrapper< VesselSegment< 3 > >(){
        // copy constructor
    
    }

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->VesselSegment< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return VesselSegment< 3 >::GetOutputData( );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetRadius( );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        AbstractVesselNetworkComponent< 3 >::SetRadius( radius );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Vessel< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Vessel< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselNode< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselSegment< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< VesselSegment< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< std::vector< unsigned int > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

boost::shared_ptr<VesselSegment<3> > (*VS3_Nodes)(boost::shared_ptr<VesselNode<3> >, boost::shared_ptr<VesselNode<3> >) = &VesselSegment<3>::Create;

boost::shared_ptr<VesselSegment<3> > (*VS3_Copy)(boost::shared_ptr<VesselSegment<3> >) = &VesselSegment<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_SingleSegment)(boost::shared_ptr<VesselSegment<3> >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_MultiSegment)(std::vector<boost::shared_ptr<VesselSegment<3> > >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_Nodes)(std::vector<boost::shared_ptr<VesselNode<3> > >) = &Vessel<3>::Create;

BOOST_PYTHON_MODULE(_chaste_project_MicrovesselChaste_vessel){
    { //::std::vector< unsigned int >
        typedef bp::class_< std::vector< unsigned int > > vector_less__unsigned_int__greater__exposer_t;
        vector_less__unsigned_int__greater__exposer_t vector_less__unsigned_int__greater__exposer = vector_less__unsigned_int__greater__exposer_t( "vector_less__unsigned_int__greater_" );
        bp::scope vector_less__unsigned_int__greater__scope( vector_less__unsigned_int__greater__exposer );
        vector_less__unsigned_int__greater__exposer.def( bp::indexing::vector_suite< std::vector< unsigned int > >() );
    }

    { //::std::vector< std::vector< unsigned int > >
        typedef bp::class_< std::vector< std::vector< unsigned int > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< std::vector< unsigned int > > >() );
    }

    { //::std::vector< std::string >
        typedef bp::class_< std::vector< std::string > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< std::string > >() );
    }

    bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >("vector_less__boost_scope_units_scope_quantity_less_boost_scope_units_scope_unit_less_boost_scope_units_scope_list_less_boost_scope_units_scope_dim_less_boost_scope_units_scope_length_base_dimension_comma__boost_scope_units_scope_static_rational_less_1_comma__1_greater___greater__comma__boost_scope_units_scope_dimensionless_type_greater__comma__boost_scope_units_scope_homogeneous_system_less_boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_meter_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_scaled_base_unit_less_boost_scope_units_scope_cgs_scope_gram_base_unit_comma__boost_scope_units_scope_scale_less_10_comma__static_rational_less_3_greater___greater___greater__comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_second_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_ampere_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_kelvin_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_mole_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_candela_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_angle_scope_radian_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_angle_scope_steradian_base_unit_comma__boost_scope_units_scope_dimensionless_type_greater___greater___greater___greater___greater___greater___greater___greater___greater___greater__comma__void_greater__comma__double_greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );

    bp::class_< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-2, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >("vector_less__boost_scope_units_scope_quantity_less_boost_scope_units_scope_unit_less_boost_scope_units_scope_list_less_boost_scope_units_scope_dim_less_boost_scope_units_scope_length_base_dimension_comma__boost_scope_units_scope_static_rational_less_-2_comma__1_greater___greater__comma__boost_scope_units_scope_dimensionless_type_greater__comma__boost_scope_units_scope_homogeneous_system_less_boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_meter_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_scaled_base_unit_less_boost_scope_units_scope_cgs_scope_gram_base_unit_comma__boost_scope_units_scope_scale_less_10_comma__static_rational_less_3_greater___greater___greater__comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_second_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_ampere_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_kelvin_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_mole_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_si_scope_candela_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_angle_scope_radian_base_unit_comma__boost_scope_units_scope_list_less_boost_scope_units_scope_angle_scope_steradian_base_unit_comma__boost_scope_units_scope_dimensionless_type_greater___greater___greater___greater___greater___greater___greater___greater___greater___greater__comma__void_greater__comma__double_greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-2, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > >() );

    { //::std::vector< boost::shared_ptr<VesselSegment<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselSegment<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselSegment<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselSegment<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselSegment<2> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselSegment<2> > > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselNode<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselNode<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<VesselNode<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<VesselNode<2> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<VesselNode<2> > > >() );
    }

    { //::std::vector< boost::shared_ptr<Vessel<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<Vessel<3> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Vessel<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<Vessel<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<Vessel<2> > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Vessel<2> > > >() );
    }

    { //::std::vector< bool >
        typedef bp::class_< std::vector< bool > > vector_less__bool__greater__exposer_t;
        vector_less__bool__greater__exposer_t vector_less__bool__greater__exposer = vector_less__bool__greater__exposer_t( "vector_less__bool__greater_" );
        bp::scope vector_less__bool__greater__scope( vector_less__bool__greater__exposer );
        vector_less__bool__greater__exposer.def( bp::indexing::vector_suite< std::vector< bool > >() );
    }

    { //::std::map< std::string, double >
        typedef bp::class_< std::map< std::string, double > > map_less__std_scope_string_comma__double__greater__exposer_t;
        map_less__std_scope_string_comma__double__greater__exposer_t map_less__std_scope_string_comma__double__greater__exposer = map_less__std_scope_string_comma__double__greater__exposer_t( "map_less__std_scope_string_comma__double__greater_" );
        bp::scope map_less__std_scope_string_comma__double__greater__scope( map_less__std_scope_string_comma__double__greater__exposer );
        map_less__std_scope_string_comma__double__greater__exposer.def( bp::indexing::map_suite< std::map< std::string, double > >() );
    }

    bp::class_< AbstractVesselNetworkComponent_less__2__greater__wrapper, boost::noncopyable >( "AbstractVesselNetworkComponent2", bp::init< >() )    
        .def( 
            "GetId"
            , (unsigned int ( ::AbstractVesselNetworkComponent<2>::* )(  )const)(&::AbstractVesselNetworkComponent< 2 >::GetId)
            , (unsigned int ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_GetId) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponent<2>::* )(  ))(&::AbstractVesselNetworkComponent< 2 >::GetOutputData) ) )    
        .def( 
            "GetOutputDataKeys"
            , (::std::vector< std::string > ( ::AbstractVesselNetworkComponent<2>::* )(  ))(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys)
            , (::std::vector< std::string > ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )(  ))(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_GetOutputDataKeys) )    
        .def( 
            "GetOutputDataValue"
            , (double ( ::AbstractVesselNetworkComponent<2>::* )( ::std::string const & ))(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue)
            , (double ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )( ::std::string const & ))(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_GetOutputDataValue)
            , ( bp::arg("rKey") ) )    
        .def( 
            "GetRadius"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponent<2>::* )(  )const)(&::AbstractVesselNetworkComponent< 2 >::GetRadius)
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_GetRadius) )    
        .def( 
            "SetId"
            , (void ( ::AbstractVesselNetworkComponent<2>::* )( unsigned int ))(&::AbstractVesselNetworkComponent< 2 >::SetId)
            , (void ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )( unsigned int ))(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_SetId)
            , ( bp::arg("id") ) )    
        .def( 
            "SetOutputData"
            , (void ( ::AbstractVesselNetworkComponent<2>::* )( ::std::string const &,double ))(&::AbstractVesselNetworkComponent< 2 >::SetOutputData)
            , (void ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )( ::std::string const &,double ))(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_SetOutputData)
            , ( bp::arg("rKey"), bp::arg("value") ) )    
        .def( 
            "SetRadius"
            , (void ( ::AbstractVesselNetworkComponent<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponent< 2 >::SetRadius)
            , (void ( AbstractVesselNetworkComponent_less__2__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponent_less__2__greater__wrapper::default_SetRadius)
            , ( bp::arg("radius") ) );

    bp::class_< AbstractVesselNetworkComponent_less__3__greater__wrapper, boost::noncopyable >( "AbstractVesselNetworkComponent3", bp::init< >() )    
        .def( 
            "GetId"
            , (unsigned int ( ::AbstractVesselNetworkComponent<3>::* )(  )const)(&::AbstractVesselNetworkComponent< 3 >::GetId)
            , (unsigned int ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetId) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponent<3>::* )(  ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputData) ) )    
        .def( 
            "GetOutputDataKeys"
            , (::std::vector< std::string > ( ::AbstractVesselNetworkComponent<3>::* )(  ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
            , (::std::vector< std::string > ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetOutputDataKeys) )    
        .def( 
            "GetOutputDataValue"
            , (double ( ::AbstractVesselNetworkComponent<3>::* )( ::std::string const & ))(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
            , (double ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::std::string const & ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetOutputDataValue)
            , ( bp::arg("rKey") ) )    
        .def( 
            "GetRadius"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponent<3>::* )(  )const)(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )(  )const)(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_GetRadius) )    
        .def( 
            "SetId"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( unsigned int ))(&::AbstractVesselNetworkComponent< 3 >::SetId)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( unsigned int ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetId)
            , ( bp::arg("id") ) )    
        .def( 
            "SetOutputData"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( ::std::string const &,double ))(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::std::string const &,double ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetOutputData)
            , ( bp::arg("rKey"), bp::arg("value") ) )    
        .def( 
            "SetRadius"
            , (void ( ::AbstractVesselNetworkComponent<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
            , (void ( AbstractVesselNetworkComponent_less__3__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponent_less__3__greater__wrapper::default_SetRadius)
            , ( bp::arg("radius") ) );

    bp::class_< AbstractVesselNetworkComponentProperties_less__2__greater__wrapper, boost::noncopyable >( "AbstractVesselNetworkComponentProperties2", bp::init< >() )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<2>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 2 >::GetOutputData) ) );

    bp::class_< AbstractVesselNetworkComponentChemicalProperties_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponentProperties< 2 > >, boost::noncopyable >( "AbstractVesselNetworkComponentChemicalProperties2", bp::init< >() )    
        .def( 
            "GetPermeability"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponentChemicalProperties<2>::* )(  )const)( &::AbstractVesselNetworkComponentChemicalProperties< 2 >::GetPermeability ) )    
        .def( 
            "SetPermeability"
            , (void ( ::AbstractVesselNetworkComponentChemicalProperties<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponentChemicalProperties< 2 >::SetPermeability)
            , (void ( AbstractVesselNetworkComponentChemicalProperties_less__2__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponentChemicalProperties_less__2__greater__wrapper::default_SetPermeability)
            , ( bp::arg("permeability") ) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<2>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 2 >::GetOutputData) ) );

    bp::class_< AbstractVesselNetworkComponentProperties_less__3__greater__wrapper, boost::noncopyable >( "AbstractVesselNetworkComponentProperties3", bp::init< >() )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<3>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 3 >::GetOutputData) ) );

    bp::class_< AbstractVesselNetworkComponentChemicalProperties_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponentProperties< 3 > >, boost::noncopyable >( "AbstractVesselNetworkComponentChemicalProperties3", bp::init< >() )    
        .def( 
            "GetPermeability"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponentChemicalProperties<3>::* )(  )const)( &::AbstractVesselNetworkComponentChemicalProperties< 3 >::GetPermeability ) )    
        .def( 
            "SetPermeability"
            , (void ( ::AbstractVesselNetworkComponentChemicalProperties<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponentChemicalProperties< 3 >::SetPermeability)
            , (void ( AbstractVesselNetworkComponentChemicalProperties_less__3__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponentChemicalProperties_less__3__greater__wrapper::default_SetPermeability)
            , ( bp::arg("permeability") ) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<3>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 3 >::GetOutputData) ) );

    bp::class_< AbstractVesselNetworkComponentFlowProperties_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponentProperties< 2 > >, boost::noncopyable >( "AbstractVesselNetworkComponentFlowProperties2", bp::init< >() )    
        .def( 
            "GetPressure"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponentFlowProperties<2>::* )(  )const)( &::AbstractVesselNetworkComponentFlowProperties< 2 >::GetPressure ) )    
        .def( 
            "SetPressure"
            , (void ( ::AbstractVesselNetworkComponentFlowProperties<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure)
            , (void ( AbstractVesselNetworkComponentFlowProperties_less__2__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponentFlowProperties_less__2__greater__wrapper::default_SetPressure)
            , ( bp::arg("pressure") ) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<2>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 2 >::GetOutputData) ) );

    bp::class_< AbstractVesselNetworkComponentFlowProperties_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponentProperties< 3 > >, boost::noncopyable >( "AbstractVesselNetworkComponentFlowProperties3", bp::init< >() )    
        .def( 
            "GetPressure"
            , (::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( ::AbstractVesselNetworkComponentFlowProperties<3>::* )(  )const)( &::AbstractVesselNetworkComponentFlowProperties< 3 >::GetPressure ) )    
        .def( 
            "SetPressure"
            , (void ( ::AbstractVesselNetworkComponentFlowProperties<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure)
            , (void ( AbstractVesselNetworkComponentFlowProperties_less__3__greater__wrapper::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))(&AbstractVesselNetworkComponentFlowProperties_less__3__greater__wrapper::default_SetPressure)
            , ( bp::arg("pressure") ) )    
        .def( 
            "GetOutputData"
            , bp::pure_virtual( (::std::map< std::string, double > ( ::AbstractVesselNetworkComponentProperties<3>::* )(  )const)(&::AbstractVesselNetworkComponentProperties< 3 >::GetOutputData) ) );

    { //::DensityMap< 2 >
        typedef bp::class_< DensityMap_less__2__greater__wrapper > DensityMap2_exposer_t;
        DensityMap2_exposer_t DensityMap2_exposer = DensityMap2_exposer_t( "DensityMap2", bp::init< >() );
        bp::scope DensityMap2_scope( DensityMap2_exposer );
        { //::DensityMap< 2 >::Create
        
            typedef DensityMap< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DensityMap< 2 > > ( *Create_function_type )(  );
            
            DensityMap2_exposer.def( 
                "Create"
                , Create_function_type( &::DensityMap< 2 >::Create ) );
        
        }
        { //::DensityMap< 2 >::Solve
        
            typedef DensityMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( DensityMap_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            DensityMap2_exposer.def( 
                "Solve"
                , Solve_function_type(&::DensityMap< 2 >::Solve)
                , default_Solve_function_type(&DensityMap_less__2__greater__wrapper::default_Solve) );
        
        }
        DensityMap2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DensityMap<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< DensityMap< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DensityMap< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::DensityMap< 3 >
        typedef bp::class_< DensityMap_less__3__greater__wrapper > DensityMap3_exposer_t;
        DensityMap3_exposer_t DensityMap3_exposer = DensityMap3_exposer_t( "DensityMap3", bp::init< >() );
        bp::scope DensityMap3_scope( DensityMap3_exposer );
        { //::DensityMap< 3 >::Create
        
            typedef DensityMap< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DensityMap< 3 > > ( *Create_function_type )(  );
            
            DensityMap3_exposer.def( 
                "Create"
                , Create_function_type( &::DensityMap< 3 >::Create ) );
        
        }
        { //::DensityMap< 3 >::Solve
        
            typedef DensityMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( DensityMap_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            DensityMap3_exposer.def( 
                "Solve"
                , Solve_function_type(&::DensityMap< 3 >::Solve)
                , default_Solve_function_type(&DensityMap_less__3__greater__wrapper::default_Solve) );
        
        }
        DensityMap3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DensityMap<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< DensityMap< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DensityMap< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::DistanceMap< 2 >
        typedef bp::class_< DistanceMap_less__2__greater__wrapper > DistanceMap2_exposer_t;
        DistanceMap2_exposer_t DistanceMap2_exposer = DistanceMap2_exposer_t( "DistanceMap2", bp::init< >() );
        bp::scope DistanceMap2_scope( DistanceMap2_exposer );
        { //::DistanceMap< 2 >::Create
        
            typedef DistanceMap< 2 > exported_class_t;
            typedef ::boost::shared_ptr< DistanceMap< 2 > > ( *Create_function_type )(  );
            
            DistanceMap2_exposer.def( 
                "Create"
                , Create_function_type( &::DistanceMap< 2 >::Create ) );
        
        }
        { //::DistanceMap< 2 >::SetUseSegmentRadii
        
            typedef DistanceMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSegmentRadii_function_type)( bool ) ;
            
            DistanceMap2_exposer.def( 
                "SetUseSegmentRadii"
                , SetUseSegmentRadii_function_type( &::DistanceMap< 2 >::SetUseSegmentRadii )
                , ( bp::arg("useRadii") ) );
        
        }
        { //::DistanceMap< 2 >::Solve
        
            typedef DistanceMap< 2 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( DistanceMap_less__2__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            DistanceMap2_exposer.def( 
                "Solve"
                , Solve_function_type(&::DistanceMap< 2 >::Solve)
                , default_Solve_function_type(&DistanceMap_less__2__greater__wrapper::default_Solve) );
        
        }
        DistanceMap2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DistanceMap<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< DistanceMap< 2 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DistanceMap< 2 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 2 > > >();
    }

    { //::DistanceMap< 3 >
        typedef bp::class_< DistanceMap_less__3__greater__wrapper > DistanceMap3_exposer_t;
        DistanceMap3_exposer_t DistanceMap3_exposer = DistanceMap3_exposer_t( "DistanceMap3", bp::init< >() );
        bp::scope DistanceMap3_scope( DistanceMap3_exposer );
        { //::DistanceMap< 3 >::Create
        
            typedef DistanceMap< 3 > exported_class_t;
            typedef ::boost::shared_ptr< DistanceMap< 3 > > ( *Create_function_type )(  );
            
            DistanceMap3_exposer.def( 
                "Create"
                , Create_function_type( &::DistanceMap< 3 >::Create ) );
        
        }
        { //::DistanceMap< 3 >::SetUseSegmentRadii
        
            typedef DistanceMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseSegmentRadii_function_type)( bool ) ;
            
            DistanceMap3_exposer.def( 
                "SetUseSegmentRadii"
                , SetUseSegmentRadii_function_type( &::DistanceMap< 3 >::SetUseSegmentRadii )
                , ( bp::arg("useRadii") ) );
        
        }
        { //::DistanceMap< 3 >::Solve
        
            typedef DistanceMap< 3 > exported_class_t;
            typedef void ( exported_class_t::*Solve_function_type)(  ) ;
            typedef void ( DistanceMap_less__3__greater__wrapper::*default_Solve_function_type)(  ) ;
            
            DistanceMap3_exposer.def( 
                "Solve"
                , Solve_function_type(&::DistanceMap< 3 >::Solve)
                , default_Solve_function_type(&DistanceMap_less__3__greater__wrapper::default_Solve) );
        
        }
        DistanceMap3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< DistanceMap<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< DistanceMap< 3 > >, boost::shared_ptr< AbstractRegularGridDiscreteContinuumSolver< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< DistanceMap< 3 > >, boost::shared_ptr< AbstractDiscreteContinuumSolver< 3 > > >();
    }

    { //::NodeFlowProperties< 2 >
        typedef bp::class_< NodeFlowProperties_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 2 > > > NodeFlowProperties2_exposer_t;
        NodeFlowProperties2_exposer_t NodeFlowProperties2_exposer = NodeFlowProperties2_exposer_t( "NodeFlowProperties2", bp::init< >() );
        bp::scope NodeFlowProperties2_scope( NodeFlowProperties2_exposer );
        { //::NodeFlowProperties< 2 >::GetOutputData
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( NodeFlowProperties_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            NodeFlowProperties2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::NodeFlowProperties< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&NodeFlowProperties_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::NodeFlowProperties< 2 >::IsInputNode
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsInputNode_function_type)(  ) const;
            
            NodeFlowProperties2_exposer.def( 
                "IsInputNode"
                , IsInputNode_function_type( &::NodeFlowProperties< 2 >::IsInputNode ) );
        
        }
        { //::NodeFlowProperties< 2 >::IsOutputNode
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsOutputNode_function_type)(  ) const;
            
            NodeFlowProperties2_exposer.def( 
                "IsOutputNode"
                , IsOutputNode_function_type( &::NodeFlowProperties< 2 >::IsOutputNode ) );
        
        }
        { //::NodeFlowProperties< 2 >::SetIsInputNode
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsInputNode_function_type)( bool ) ;
            
            NodeFlowProperties2_exposer.def( 
                "SetIsInputNode"
                , SetIsInputNode_function_type( &::NodeFlowProperties< 2 >::SetIsInputNode )
                , ( bp::arg("isInput") ) );
        
        }
        { //::NodeFlowProperties< 2 >::SetIsOutputNode
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsOutputNode_function_type)( bool ) ;
            
            NodeFlowProperties2_exposer.def( 
                "SetIsOutputNode"
                , SetIsOutputNode_function_type( &::NodeFlowProperties< 2 >::SetIsOutputNode )
                , ( bp::arg("isOutput") ) );
        
        }
        { //::NodeFlowProperties< 2 >::SetUseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetUseVelocityBoundaryCondition_function_type)( bool ) ;
            
            NodeFlowProperties2_exposer.def( 
                "SetUseVelocityBoundaryCondition"
                , SetUseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 2 >::SetUseVelocityBoundaryCondition )
                , ( bp::arg("useVelocity") ) );
        
        }
        { //::NodeFlowProperties< 2 >::UseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef bool ( exported_class_t::*UseVelocityBoundaryCondition_function_type)(  ) ;
            
            NodeFlowProperties2_exposer.def( 
                "UseVelocityBoundaryCondition"
                , UseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 2 >::UseVelocityBoundaryCondition ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure
        
            typedef NodeFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( NodeFlowProperties_less__2__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            NodeFlowProperties2_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure)
                , default_SetPressure_function_type(&NodeFlowProperties_less__2__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< NodeFlowProperties<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< NodeFlowProperties< 2 > > > >();
    }

    { //::NodeFlowProperties< 3 >
        typedef bp::class_< NodeFlowProperties_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 3 > > > NodeFlowProperties3_exposer_t;
        NodeFlowProperties3_exposer_t NodeFlowProperties3_exposer = NodeFlowProperties3_exposer_t( "NodeFlowProperties3", bp::init< >() );
        bp::scope NodeFlowProperties3_scope( NodeFlowProperties3_exposer );
        { //::NodeFlowProperties< 3 >::GetOutputData
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( NodeFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::NodeFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&NodeFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::NodeFlowProperties< 3 >::IsInputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsInputNode_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "IsInputNode"
                , IsInputNode_function_type( &::NodeFlowProperties< 3 >::IsInputNode ) );
        
        }
        { //::NodeFlowProperties< 3 >::IsOutputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsOutputNode_function_type)(  ) const;
            
            NodeFlowProperties3_exposer.def( 
                "IsOutputNode"
                , IsOutputNode_function_type( &::NodeFlowProperties< 3 >::IsOutputNode ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetIsInputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsInputNode_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetIsInputNode"
                , SetIsInputNode_function_type( &::NodeFlowProperties< 3 >::SetIsInputNode )
                , ( bp::arg("isInput") ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetIsOutputNode
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsOutputNode_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetIsOutputNode"
                , SetIsOutputNode_function_type( &::NodeFlowProperties< 3 >::SetIsOutputNode )
                , ( bp::arg("isOutput") ) );
        
        }
        { //::NodeFlowProperties< 3 >::SetUseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetUseVelocityBoundaryCondition_function_type)( bool ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetUseVelocityBoundaryCondition"
                , SetUseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 3 >::SetUseVelocityBoundaryCondition )
                , ( bp::arg("useVelocity") ) );
        
        }
        { //::NodeFlowProperties< 3 >::UseVelocityBoundaryCondition
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*UseVelocityBoundaryCondition_function_type)(  ) ;
            
            NodeFlowProperties3_exposer.def( 
                "UseVelocityBoundaryCondition"
                , UseVelocityBoundaryCondition_function_type( &::NodeFlowProperties< 3 >::UseVelocityBoundaryCondition ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure
        
            typedef NodeFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( NodeFlowProperties_less__3__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            NodeFlowProperties3_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure)
                , default_SetPressure_function_type(&NodeFlowProperties_less__3__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< NodeFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodeFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< NodeFlowProperties< 3 > > > >();
    }

    { //::SegmentFlowProperties< 2 >
        typedef bp::class_< SegmentFlowProperties_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 2 > > > SegmentFlowProperties2_exposer_t;
        SegmentFlowProperties2_exposer_t SegmentFlowProperties2_exposer = SegmentFlowProperties2_exposer_t( "SegmentFlowProperties2", bp::init< >() );
        bp::scope SegmentFlowProperties2_scope( SegmentFlowProperties2_exposer );
        { //::SegmentFlowProperties< 2 >::GetFlowRate
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::SegmentFlowProperties< 2 >::GetFlowRate ) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetGrowthStimulus
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::SegmentFlowProperties< 2 >::GetGrowthStimulus ) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetHaematocrit
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::SegmentFlowProperties< 2 >::GetHaematocrit ) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetImpedance
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::SegmentFlowProperties< 2 >::GetImpedance ) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetOutputData
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( SegmentFlowProperties_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::SegmentFlowProperties< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&SegmentFlowProperties_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetViscosity
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::SegmentFlowProperties< 2 >::GetViscosity ) );
        
        }
        { //::SegmentFlowProperties< 2 >::GetWallShearStress
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            SegmentFlowProperties2_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::SegmentFlowProperties< 2 >::GetWallShearStress ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetFlowRate
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::SegmentFlowProperties< 2 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetGrowthStimulus
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::SegmentFlowProperties< 2 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetHaematocrit
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::SegmentFlowProperties< 2 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetImpedance
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::SegmentFlowProperties< 2 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetViscosity
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::SegmentFlowProperties< 2 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::SegmentFlowProperties< 2 >::SetWallShearStress
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::SegmentFlowProperties< 2 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure
        
            typedef SegmentFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( SegmentFlowProperties_less__2__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties2_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure)
                , default_SetPressure_function_type(&SegmentFlowProperties_less__2__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< SegmentFlowProperties<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< SegmentFlowProperties< 2 > > > >();
    }

    { //::SegmentFlowProperties< 3 >
        typedef bp::class_< SegmentFlowProperties_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 3 > > > SegmentFlowProperties3_exposer_t;
        SegmentFlowProperties3_exposer_t SegmentFlowProperties3_exposer = SegmentFlowProperties3_exposer_t( "SegmentFlowProperties3", bp::init< >() );
        bp::scope SegmentFlowProperties3_scope( SegmentFlowProperties3_exposer );
        { //::SegmentFlowProperties< 3 >::GetFlowRate
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::SegmentFlowProperties< 3 >::GetFlowRate ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetGrowthStimulus
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::SegmentFlowProperties< 3 >::GetGrowthStimulus ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetHaematocrit
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::SegmentFlowProperties< 3 >::GetHaematocrit ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetImpedance
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::SegmentFlowProperties< 3 >::GetImpedance ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetOutputData
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( SegmentFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::SegmentFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&SegmentFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetViscosity
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::SegmentFlowProperties< 3 >::GetViscosity ) );
        
        }
        { //::SegmentFlowProperties< 3 >::GetWallShearStress
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            SegmentFlowProperties3_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::SegmentFlowProperties< 3 >::GetWallShearStress ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetFlowRate
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::SegmentFlowProperties< 3 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetGrowthStimulus
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::SegmentFlowProperties< 3 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetHaematocrit
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::SegmentFlowProperties< 3 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetImpedance
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::SegmentFlowProperties< 3 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetViscosity
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::SegmentFlowProperties< 3 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::SegmentFlowProperties< 3 >::SetWallShearStress
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::SegmentFlowProperties< 3 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure
        
            typedef SegmentFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( SegmentFlowProperties_less__3__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            SegmentFlowProperties3_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure)
                , default_SetPressure_function_type(&SegmentFlowProperties_less__3__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< SegmentFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< SegmentFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< SegmentFlowProperties< 3 > > > >();
    }

    { //::SegmentLocation
        typedef bp::class_< SegmentLocation > SegmentLocation_exposer_t;
        SegmentLocation_exposer_t SegmentLocation_exposer = SegmentLocation_exposer_t( "SegmentLocation" );
        bp::scope SegmentLocation_scope( SegmentLocation_exposer );
        bp::enum_< SegmentLocation::Value>("Value")
            .value("Start", SegmentLocation::Start)
            .value("End", SegmentLocation::End)
            .export_values()
            ;
    }

    { //::Vessel< 2 >
        typedef bp::class_< Vessel_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 2 > >, boost::noncopyable > Vessel2_exposer_t;
        Vessel2_exposer_t Vessel2_exposer = Vessel2_exposer_t( "Vessel2", bp::no_init );
        bp::scope Vessel2_scope( Vessel2_exposer );
        { //::Vessel< 2 >::AddSegment
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddSegment_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > ) ;
            
            Vessel2_exposer.def( 
                "AddSegment"
                , AddSegment_function_type( &::Vessel< 2 >::AddSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 2 >::AddSegments
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<2> > > ) ;
            
            Vessel2_exposer.def( 
                "AddSegments"
                , AddSegments_function_type( &::Vessel< 2 >::AddSegments )
                , ( bp::arg("pSegments") ) );
        
        }
        { //::Vessel< 2 >::CopyDataFromExistingVessel
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > > ) ;
            
            Vessel2_exposer.def( 
                "CopyDataFromExistingVessel"
                , CopyDataFromExistingVessel_function_type( &::Vessel< 2 >::CopyDataFromExistingVessel )
                , ( bp::arg("pTargetVessel") ) );
        
        }
        { //::Vessel< 2 >::Create
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 2 > > );
            
            Vessel2_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 2 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 2 >::Create
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselSegment<2> > > );
            
            Vessel2_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 2 >::Create )
                , ( bp::arg("segments") ) );
        
        }
        { //::Vessel< 2 >::Create
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselNode<2> > > );
            
            Vessel2_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 2 >::Create )
                , ( bp::arg("nodes") ) );
        
        }
        { //::Vessel< 2 >::Create
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 2 > >,::boost::shared_ptr< VesselNode< 2 > > );
            
            Vessel2_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 2 >::Create )
                , ( bp::arg("pStartNode"), bp::arg("pEndNode") ) );
        
        }
        { //::Vessel< 2 >::DivideSegment
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*DivideSegment_function_type)( ::DimensionalChastePoint< 2 > const &,double ) ;
            
            Vessel2_exposer.def( 
                "DivideSegment"
                , DivideSegment_function_type( &::Vessel< 2 >::DivideSegment )
                , ( bp::arg("rLocation"), bp::arg("distanceTolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::Vessel< 2 >::GetClosestEndNodeDistance
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetClosestEndNodeDistance_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            Vessel2_exposer.def( 
                "GetClosestEndNodeDistance"
                , GetClosestEndNodeDistance_function_type( &::Vessel< 2 >::GetClosestEndNodeDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 2 >::GetConnectedVessels
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<2> > > ( exported_class_t::*GetConnectedVessels_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetConnectedVessels"
                , GetConnectedVessels_function_type( &::Vessel< 2 >::GetConnectedVessels ) );
        
        }
        { //::Vessel< 2 >::GetDistance
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 2 > const & ) const;
            
            Vessel2_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::Vessel< 2 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 2 >::GetEndNode
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetEndNode_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetEndNode"
                , GetEndNode_function_type( &::Vessel< 2 >::GetEndNode ) );
        
        }
        { //::Vessel< 2 >::GetFlowProperties
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselFlowProperties< 2 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            Vessel2_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::Vessel< 2 >::GetFlowProperties ) );
        
        }
        { //::Vessel< 2 >::GetLength
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            Vessel2_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::Vessel< 2 >::GetLength ) );
        
        }
        { //::Vessel< 2 >::GetNode
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            Vessel2_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::Vessel< 2 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 2 >::GetNodeAtOppositeEnd
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNodeAtOppositeEnd_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            Vessel2_exposer.def( 
                "GetNodeAtOppositeEnd"
                , GetNodeAtOppositeEnd_function_type( &::Vessel< 2 >::GetNodeAtOppositeEnd )
                , ( bp::arg("pQueryNode") ) );
        
        }
        { //::Vessel< 2 >::GetNodes
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::Vessel< 2 >::GetNodes ) );
        
        }
        { //::Vessel< 2 >::GetNumberOfNodes
        
            typedef Vessel< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::Vessel< 2 >::GetNumberOfNodes ) );
        
        }
        { //::Vessel< 2 >::GetNumberOfSegments
        
            typedef Vessel< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::Vessel< 2 >::GetNumberOfSegments ) );
        
        }
        { //::Vessel< 2 >::GetOutputData
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( Vessel_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::Vessel< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&Vessel_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::Vessel< 2 >::GetRadius
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( Vessel_less__2__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            Vessel2_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::Vessel< 2 >::GetRadius)
                , default_GetRadius_function_type(&Vessel_less__2__greater__wrapper::default_GetRadius) );
        
        }
        { //::Vessel< 2 >::GetSegment
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 2 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) ;
            
            Vessel2_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::Vessel< 2 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 2 >::GetSegments
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<2> > > ( exported_class_t::*GetSegments_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::Vessel< 2 >::GetSegments ) );
        
        }
        { //::Vessel< 2 >::GetStartNode
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetStartNode_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetStartNode"
                , GetStartNode_function_type( &::Vessel< 2 >::GetStartNode ) );
        
        }
        { //::Vessel< 2 >::IsConnectedTo
        
            typedef Vessel< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< Vessel< 2 > > ) ;
            
            Vessel2_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::Vessel< 2 >::IsConnectedTo )
                , ( bp::arg("pOtherVessel") ) );
        
        }
        { //::Vessel< 2 >::Remove
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "Remove"
                , Remove_function_type( &::Vessel< 2 >::Remove ) );
        
        }
        { //::Vessel< 2 >::RemoveSegments
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveSegments_function_type)( ::SegmentLocation::Value ) ;
            
            Vessel2_exposer.def( 
                "RemoveSegments"
                , RemoveSegments_function_type( &::Vessel< 2 >::RemoveSegments )
                , ( bp::arg("location") ) );
        
        }
        { //::Vessel< 2 >::SetFlowProperties
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::VesselFlowProperties< 2 > const & ) ;
            
            Vessel2_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::Vessel< 2 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::Vessel< 2 >::SetRadius
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( Vessel_less__2__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Vessel2_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::Vessel< 2 >::SetRadius)
                , default_SetRadius_function_type(&Vessel_less__2__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        { //::Vessel< 2 >::UpdateNodes
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::Vessel< 2 >::UpdateNodes ) );
        
        }
        { //::Vessel< 2 >::rGetNodes
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > const & ( exported_class_t::*rGetNodes_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "rGetNodes"
                , rGetNodes_function_type( &::Vessel< 2 >::rGetNodes )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetId
        
            typedef Vessel< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( Vessel_less__2__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            Vessel2_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 2 >::GetId)
                , default_GetId_function_type(&Vessel_less__2__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys
        
            typedef Vessel< 2 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( Vessel_less__2__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            Vessel2_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&Vessel_less__2__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue
        
            typedef Vessel< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( Vessel_less__2__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            Vessel2_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&Vessel_less__2__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetId
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( Vessel_less__2__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            Vessel2_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 2 >::SetId)
                , default_SetId_function_type(&Vessel_less__2__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetOutputData
        
            typedef Vessel< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( Vessel_less__2__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            Vessel2_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 2 >::SetOutputData)
                , default_SetOutputData_function_type(&Vessel_less__2__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        Vessel2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Vessel<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< Vessel< 2 > > > >();
    }

    { //::Vessel< 3 >
        typedef bp::class_< Vessel_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > >, boost::noncopyable > Vessel3_exposer_t;
        Vessel3_exposer_t Vessel3_exposer = Vessel3_exposer_t( "Vessel3", bp::no_init );
        bp::scope Vessel3_scope( Vessel3_exposer );
        { //::Vessel< 3 >::AddSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegment"
                , AddSegment_function_type( &::Vessel< 3 >::AddSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::AddSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<3> > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegments"
                , AddSegments_function_type( &::Vessel< 3 >::AddSegments )
                , ( bp::arg("pSegments") ) );
        
        }
        { //::Vessel< 3 >::CopyDataFromExistingVessel
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "CopyDataFromExistingVessel"
                , CopyDataFromExistingVessel_function_type( &::Vessel< 3 >::CopyDataFromExistingVessel )
                , ( bp::arg("pTargetVessel") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselSegment<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("segments") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselNode<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("nodes") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pStartNode"), bp::arg("pEndNode") ) );
        
        }
        { //::Vessel< 3 >::DivideSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*DivideSegment_function_type)( ::DimensionalChastePoint< 3 > const &,double ) ;
            
            Vessel3_exposer.def( 
                "DivideSegment"
                , DivideSegment_function_type( &::Vessel< 3 >::DivideSegment )
                , ( bp::arg("rLocation"), bp::arg("distanceTolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::Vessel< 3 >::GetClosestEndNodeDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetClosestEndNodeDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "GetClosestEndNodeDistance"
                , GetClosestEndNodeDistance_function_type( &::Vessel< 3 >::GetClosestEndNodeDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetConnectedVessels
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*GetConnectedVessels_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetConnectedVessels"
                , GetConnectedVessels_function_type( &::Vessel< 3 >::GetConnectedVessels ) );
        
        }
        { //::Vessel< 3 >::GetDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            Vessel3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::Vessel< 3 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetEndNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetEndNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetEndNode"
                , GetEndNode_function_type( &::Vessel< 3 >::GetEndNode ) );
        
        }
        { //::Vessel< 3 >::GetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::Vessel< 3 >::GetFlowProperties ) );
        
        }
        { //::Vessel< 3 >::GetLength
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::Vessel< 3 >::GetLength ) );
        
        }
        { //::Vessel< 3 >::GetNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::Vessel< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetNodeAtOppositeEnd
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNodeAtOppositeEnd_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "GetNodeAtOppositeEnd"
                , GetNodeAtOppositeEnd_function_type( &::Vessel< 3 >::GetNodeAtOppositeEnd )
                , ( bp::arg("pQueryNode") ) );
        
        }
        { //::Vessel< 3 >::GetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::Vessel< 3 >::GetNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::Vessel< 3 >::GetNumberOfNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::Vessel< 3 >::GetNumberOfSegments ) );
        
        }
        { //::Vessel< 3 >::GetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( Vessel_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::Vessel< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::Vessel< 3 >::GetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( Vessel_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::Vessel< 3 >::GetRadius)
                , default_GetRadius_function_type(&Vessel_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::Vessel< 3 >::GetSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::Vessel< 3 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::Vessel< 3 >::GetSegments ) );
        
        }
        { //::Vessel< 3 >::GetStartNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetStartNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetStartNode"
                , GetStartNode_function_type( &::Vessel< 3 >::GetStartNode ) );
        
        }
        { //::Vessel< 3 >::IsConnectedTo
        
            typedef Vessel< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::Vessel< 3 >::IsConnectedTo )
                , ( bp::arg("pOtherVessel") ) );
        
        }
        { //::Vessel< 3 >::Remove
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "Remove"
                , Remove_function_type( &::Vessel< 3 >::Remove ) );
        
        }
        { //::Vessel< 3 >::RemoveSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveSegments_function_type)( ::SegmentLocation::Value ) ;
            
            Vessel3_exposer.def( 
                "RemoveSegments"
                , RemoveSegments_function_type( &::Vessel< 3 >::RemoveSegments )
                , ( bp::arg("location") ) );
        
        }
        { //::Vessel< 3 >::SetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::VesselFlowProperties< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::Vessel< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::Vessel< 3 >::SetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Vessel3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::Vessel< 3 >::SetRadius)
                , default_SetRadius_function_type(&Vessel_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        { //::Vessel< 3 >::UpdateNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::Vessel< 3 >::UpdateNodes ) );
        
        }
        { //::Vessel< 3 >::rGetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ( exported_class_t::*rGetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "rGetNodes"
                , rGetNodes_function_type( &::Vessel< 3 >::rGetNodes )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( Vessel_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&Vessel_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( Vessel_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef Vessel< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( Vessel_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&Vessel_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            Vessel3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        Vessel3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Vessel<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< Vessel< 3 > > > >();
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_SingleSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_MultiSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_Nodes));
    }

    { //::VesselDistribution
        typedef bp::class_< VesselDistribution > VesselDistribution_exposer_t;
        VesselDistribution_exposer_t VesselDistribution_exposer = VesselDistribution_exposer_t( "VesselDistribution" );
        bp::scope VesselDistribution_scope( VesselDistribution_exposer );
        bp::enum_< VesselDistribution::Value>("Value")
            .value("REGULAR", VesselDistribution::REGULAR)
            .value("UNIFORM", VesselDistribution::UNIFORM)
            .value("TWO_LAYER", VesselDistribution::TWO_LAYER)
            .value("CUSTOM", VesselDistribution::CUSTOM)
            .export_values()
            ;
    }

    { //::VesselFlowProperties< 2 >
        typedef bp::class_< VesselFlowProperties_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 2 > > > VesselFlowProperties2_exposer_t;
        VesselFlowProperties2_exposer_t VesselFlowProperties2_exposer = VesselFlowProperties2_exposer_t( "VesselFlowProperties2", bp::init< >() );
        bp::scope VesselFlowProperties2_scope( VesselFlowProperties2_exposer );
        { //::VesselFlowProperties< 2 >::CheckSegments
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*CheckSegments_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "CheckSegments"
                , CheckSegments_function_type( &::VesselFlowProperties< 2 >::CheckSegments ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetFlowRate
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::VesselFlowProperties< 2 >::GetFlowRate ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetGrowthStimulus
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::VesselFlowProperties< 2 >::GetGrowthStimulus ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetHaematocrit
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::VesselFlowProperties< 2 >::GetHaematocrit ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetImpedance
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::VesselFlowProperties< 2 >::GetImpedance ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetOutputData
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( VesselFlowProperties_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselFlowProperties< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselFlowProperties_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselFlowProperties< 2 >::GetRegressionTime
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRegressionTime_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetRegressionTime"
                , GetRegressionTime_function_type( &::VesselFlowProperties< 2 >::GetRegressionTime ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetViscosity
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::VesselFlowProperties< 2 >::GetViscosity ) );
        
        }
        { //::VesselFlowProperties< 2 >::GetWallShearStress
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            VesselFlowProperties2_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::VesselFlowProperties< 2 >::GetWallShearStress ) );
        
        }
        { //::VesselFlowProperties< 2 >::HasRegressionTimerStarted
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef bool ( exported_class_t::*HasRegressionTimerStarted_function_type)(  ) ;
            
            VesselFlowProperties2_exposer.def( 
                "HasRegressionTimerStarted"
                , HasRegressionTimerStarted_function_type( &::VesselFlowProperties< 2 >::HasRegressionTimerStarted ) );
        
        }
        { //::VesselFlowProperties< 2 >::HasVesselRegressed
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef bool ( exported_class_t::*HasVesselRegressed_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "HasVesselRegressed"
                , HasVesselRegressed_function_type( &::VesselFlowProperties< 2 >::HasVesselRegressed )
                , ( bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 2 >::ResetRegressionTimer
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*ResetRegressionTimer_function_type)(  ) ;
            
            VesselFlowProperties2_exposer.def( 
                "ResetRegressionTimer"
                , ResetRegressionTimer_function_type( &::VesselFlowProperties< 2 >::ResetRegressionTimer ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetFlowRate
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::VesselFlowProperties< 2 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetGrowthStimulus
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::VesselFlowProperties< 2 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetHaematocrit
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::VesselFlowProperties< 2 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetImpedance
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::VesselFlowProperties< 2 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetRegressionTime
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegressionTime_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetRegressionTime"
                , SetRegressionTime_function_type( &::VesselFlowProperties< 2 >::SetRegressionTime )
                , ( bp::arg("time") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetTimeUntilRegression
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetTimeUntilRegression_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetTimeUntilRegression"
                , SetTimeUntilRegression_function_type( &::VesselFlowProperties< 2 >::SetTimeUntilRegression )
                , ( bp::arg("time"), bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetViscosity
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::VesselFlowProperties< 2 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselFlowProperties< 2 >::SetWallShearStress
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::VesselFlowProperties< 2 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        { //::VesselFlowProperties< 2 >::UpdateSegments
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<2> > > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselFlowProperties< 2 >::UpdateSegments )
                , ( bp::arg("segments") ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure
        
            typedef VesselFlowProperties< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselFlowProperties_less__2__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties2_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 2 >::SetPressure)
                , default_SetPressure_function_type(&VesselFlowProperties_less__2__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< VesselFlowProperties<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 2 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselFlowProperties< 2 > > > >();
    }

    { //::VesselFlowProperties< 3 >
        typedef bp::class_< VesselFlowProperties_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponentFlowProperties< 3 > > > VesselFlowProperties3_exposer_t;
        VesselFlowProperties3_exposer_t VesselFlowProperties3_exposer = VesselFlowProperties3_exposer_t( "VesselFlowProperties3", bp::init< >() );
        bp::scope VesselFlowProperties3_scope( VesselFlowProperties3_exposer );
        { //::VesselFlowProperties< 3 >::CheckSegments
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*CheckSegments_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "CheckSegments"
                , CheckSegments_function_type( &::VesselFlowProperties< 3 >::CheckSegments ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetFlowRate
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetFlowRate_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetFlowRate"
                , GetFlowRate_function_type( &::VesselFlowProperties< 3 >::GetFlowRate ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetGrowthStimulus
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetGrowthStimulus_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetGrowthStimulus"
                , GetGrowthStimulus_function_type( &::VesselFlowProperties< 3 >::GetGrowthStimulus ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetHaematocrit
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetHaematocrit_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetHaematocrit"
                , GetHaematocrit_function_type( &::VesselFlowProperties< 3 >::GetHaematocrit ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetImpedance
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetImpedance_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetImpedance"
                , GetImpedance_function_type( &::VesselFlowProperties< 3 >::GetImpedance ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetOutputData
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) const;
            typedef ::std::map< std::string, double > ( VesselFlowProperties_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselFlowProperties< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselFlowProperties_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselFlowProperties< 3 >::GetRegressionTime
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRegressionTime_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetRegressionTime"
                , GetRegressionTime_function_type( &::VesselFlowProperties< 3 >::GetRegressionTime ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetViscosity
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetViscosity_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetViscosity"
                , GetViscosity_function_type( &::VesselFlowProperties< 3 >::GetViscosity ) );
        
        }
        { //::VesselFlowProperties< 3 >::GetWallShearStress
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetWallShearStress_function_type)(  ) const;
            
            VesselFlowProperties3_exposer.def( 
                "GetWallShearStress"
                , GetWallShearStress_function_type( &::VesselFlowProperties< 3 >::GetWallShearStress ) );
        
        }
        { //::VesselFlowProperties< 3 >::HasRegressionTimerStarted
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasRegressionTimerStarted_function_type)(  ) ;
            
            VesselFlowProperties3_exposer.def( 
                "HasRegressionTimerStarted"
                , HasRegressionTimerStarted_function_type( &::VesselFlowProperties< 3 >::HasRegressionTimerStarted ) );
        
        }
        { //::VesselFlowProperties< 3 >::HasVesselRegressed
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasVesselRegressed_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "HasVesselRegressed"
                , HasVesselRegressed_function_type( &::VesselFlowProperties< 3 >::HasVesselRegressed )
                , ( bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 3 >::ResetRegressionTimer
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*ResetRegressionTimer_function_type)(  ) ;
            
            VesselFlowProperties3_exposer.def( 
                "ResetRegressionTimer"
                , ResetRegressionTimer_function_type( &::VesselFlowProperties< 3 >::ResetRegressionTimer ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetFlowRate
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowRate_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetFlowRate"
                , SetFlowRate_function_type( &::VesselFlowProperties< 3 >::SetFlowRate )
                , ( bp::arg("flowRate") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetGrowthStimulus
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGrowthStimulus_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetGrowthStimulus"
                , SetGrowthStimulus_function_type( &::VesselFlowProperties< 3 >::SetGrowthStimulus )
                , ( bp::arg("stimulus") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetHaematocrit
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHaematocrit_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::dimensionless_type, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetHaematocrit"
                , SetHaematocrit_function_type( &::VesselFlowProperties< 3 >::SetHaematocrit )
                , ( bp::arg("haematocrit") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetImpedance
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetImpedance_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -4, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetImpedance"
                , SetImpedance_function_type( &::VesselFlowProperties< 3 >::SetImpedance )
                , ( bp::arg("impedance") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetRegressionTime
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegressionTime_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetRegressionTime"
                , SetRegressionTime_function_type( &::VesselFlowProperties< 3 >::SetRegressionTime )
                , ( bp::arg("time") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetTimeUntilRegression
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetTimeUntilRegression_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetTimeUntilRegression"
                , SetTimeUntilRegression_function_type( &::VesselFlowProperties< 3 >::SetTimeUntilRegression )
                , ( bp::arg("time"), bp::arg("simulationReferenceTime") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetViscosity
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetViscosity"
                , SetViscosity_function_type( &::VesselFlowProperties< 3 >::SetViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselFlowProperties< 3 >::SetWallShearStress
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetWallShearStress_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetWallShearStress"
                , SetWallShearStress_function_type( &::VesselFlowProperties< 3 >::SetWallShearStress )
                , ( bp::arg("wallShear") ) );
        
        }
        { //::VesselFlowProperties< 3 >::UpdateSegments
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<3> > > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselFlowProperties< 3 >::UpdateSegments )
                , ( bp::arg("segments") ) );
        
        }
        { //::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure
        
            typedef VesselFlowProperties< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselFlowProperties_less__3__greater__wrapper::*default_SetPressure_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselFlowProperties3_exposer.def( 
                "SetPressure"
                , SetPressure_function_type(&::AbstractVesselNetworkComponentFlowProperties< 3 >::SetPressure)
                , default_SetPressure_function_type(&VesselFlowProperties_less__3__greater__wrapper::default_SetPressure)
                , ( bp::arg("pressure") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< VesselFlowProperties<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentFlowProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponentProperties< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< AbstractVesselNetworkComponentFlowProperties< 3 > > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselFlowProperties< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselFlowProperties< 3 > > > >();
    }

    { //::VesselNetwork< 2 >
        typedef bp::class_< VesselNetwork_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 2 > > > VesselNetwork2_exposer_t;
        VesselNetwork2_exposer_t VesselNetwork2_exposer = VesselNetwork2_exposer_t( "VesselNetwork2", bp::init< >() );
        bp::scope VesselNetwork2_scope( VesselNetwork2_exposer );
        { //::VesselNetwork< 2 >::AddVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "AddVessel"
                , AddVessel_function_type( &::VesselNetwork< 2 >::AddVessel )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 2 >::AddVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<2> > > ) ;
            
            VesselNetwork2_exposer.def( 
                "AddVessels"
                , AddVessels_function_type( &::VesselNetwork< 2 >::AddVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 2 >::CopySegmentFlowProperties
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*CopySegmentFlowProperties_function_type)( unsigned int ) ;
            
            VesselNetwork2_exposer.def( 
                "CopySegmentFlowProperties"
                , CopySegmentFlowProperties_function_type( &::VesselNetwork< 2 >::CopySegmentFlowProperties )
                , ( bp::arg("index")=(unsigned int)(0) ) );
        
        }
        { //::VesselNetwork< 2 >::CopyVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<2> > > ( exported_class_t::*CopyVessels_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 2 >::CopyVessels ) );
        
        }
        { //::VesselNetwork< 2 >::CopyVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<2> > > ( exported_class_t::*CopyVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<2> > > ) ;
            
            VesselNetwork2_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 2 >::CopyVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 2 >::Create
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 2 > > ( *Create_function_type )(  );
            
            VesselNetwork2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetwork< 2 >::Create ) );
        
        }
        { //::VesselNetwork< 2 >::DivideVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*DivideVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > >,::DimensionalChastePoint< 2 > const & ) ;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( VesselNetwork_less__2__greater__wrapper::*default_DivideVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > >,::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "DivideVessel"
                , DivideVessel_function_type(&::VesselNetwork< 2 >::DivideVessel)
                , default_DivideVessel_function_type(&VesselNetwork_less__2__greater__wrapper::default_DivideVessel)
                , ( bp::arg("pVessel"), bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::ExtendVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*ExtendVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > >,::boost::shared_ptr< VesselNode< 2 > >,::boost::shared_ptr< VesselNode< 2 > > ) ;
            typedef void ( VesselNetwork_less__2__greater__wrapper::*default_ExtendVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > >,::boost::shared_ptr< VesselNode< 2 > >,::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "ExtendVessel"
                , ExtendVessel_function_type(&::VesselNetwork< 2 >::ExtendVessel)
                , default_ExtendVessel_function_type(&VesselNetwork_less__2__greater__wrapper::default_ExtendVessel)
                , ( bp::arg("pVessel"), bp::arg("pEndNode"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselNetwork< 2 >::FormSprout
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( exported_class_t::*FormSprout_function_type)( ::DimensionalChastePoint< 2 > const &,::DimensionalChastePoint< 2 > const & ) ;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( VesselNetwork_less__2__greater__wrapper::*default_FormSprout_function_type)( ::DimensionalChastePoint< 2 > const &,::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "FormSprout"
                , FormSprout_function_type(&::VesselNetwork< 2 >::FormSprout)
                , default_FormSprout_function_type(&VesselNetwork_less__2__greater__wrapper::default_FormSprout)
                , ( bp::arg("sproutBaseLocation"), bp::arg("sproutTipLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::GetDistanceToNearestNode
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistanceToNearestNode_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "GetDistanceToNearestNode"
                , GetDistanceToNearestNode_function_type( &::VesselNetwork< 2 >::GetDistanceToNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::GetExtents
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::pair< DimensionalChastePoint< 2 >, DimensionalChastePoint< 2 > > ( exported_class_t::*GetExtents_function_type)( bool ) ;
            
            VesselNetwork2_exposer.def( 
                "GetExtents"
                , GetExtents_function_type( &::VesselNetwork< 2 >::GetExtents )
                , ( bp::arg("useRadii")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 2 >::GetMaxBranchesOnNode
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetMaxBranchesOnNode_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetMaxBranchesOnNode"
                , GetMaxBranchesOnNode_function_type( &::VesselNetwork< 2 >::GetMaxBranchesOnNode ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestNode
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNearestNode_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 2 >::GetNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestNode
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNearestNode_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 2 >::GetNearestNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestSegment
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 2 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 2 >::GetNearestSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestSegment
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 2 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselNode< 2 > >,bool ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 2 >::GetNearestSegment )
                , ( bp::arg("pNode"), bp::arg("sameVessel")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestSegment
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 2 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 2 >::GetNearestSegment )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNearestVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( exported_class_t::*GetNearestVessel_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNearestVessel"
                , GetNearestVessel_function_type( &::VesselNetwork< 2 >::GetNearestVessel )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNode
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselNetwork< 2 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNodeIndex
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNodeIndex_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNodeIndex"
                , GetNodeIndex_function_type( &::VesselNetwork< 2 >::GetNodeIndex )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselNetwork< 2 >::GetNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselNetwork< 2 >::GetNodes ) );
        
        }
        { //::VesselNetwork< 2 >::GetNumberOfNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::VesselNetwork< 2 >::GetNumberOfNodes ) );
        
        }
        { //::VesselNetwork< 2 >::GetNumberOfVesselNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVesselNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNumberOfVesselNodes"
                , GetNumberOfVesselNodes_function_type( &::VesselNetwork< 2 >::GetNumberOfVesselNodes ) );
        
        }
        { //::VesselNetwork< 2 >::GetNumberOfVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVessels_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetNumberOfVessels"
                , GetNumberOfVessels_function_type( &::VesselNetwork< 2 >::GetNumberOfVessels ) );
        
        }
        { //::VesselNetwork< 2 >::GetOutputData
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNetwork_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNetwork< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNetwork_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNetwork< 2 >::GetVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( exported_class_t::*GetVessel_function_type)( unsigned int ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselNetwork< 2 >::GetVessel )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 2 >::GetVesselEndNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<2> > > ( exported_class_t::*GetVesselEndNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVesselEndNodes"
                , GetVesselEndNodes_function_type( &::VesselNetwork< 2 >::GetVesselEndNodes ) );
        
        }
        { //::VesselNetwork< 2 >::GetVesselIndex
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselIndex_function_type)( ::boost::shared_ptr< Vessel< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVesselIndex"
                , GetVesselIndex_function_type( &::VesselNetwork< 2 >::GetVesselIndex )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 2 >::GetVesselSegmentIndex
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselSegmentIndex_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVesselSegmentIndex"
                , GetVesselSegmentIndex_function_type( &::VesselNetwork< 2 >::GetVesselSegmentIndex )
                , ( bp::arg("pVesselSegment") ) );
        
        }
        { //::VesselNetwork< 2 >::GetVesselSegments
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<2> > > ( exported_class_t::*GetVesselSegments_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVesselSegments"
                , GetVesselSegments_function_type( &::VesselNetwork< 2 >::GetVesselSegments ) );
        
        }
        { //::VesselNetwork< 2 >::GetVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<2> > > ( exported_class_t::*GetVessels_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetVessels"
                , GetVessels_function_type( &::VesselNetwork< 2 >::GetVessels ) );
        
        }
        { //::VesselNetwork< 2 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( double ) ;
            
            VesselNetwork2_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 2 >::MergeCoincidentNodes )
                , ( bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 2 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<Vessel<2> > >,double ) ;
            
            VesselNetwork2_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 2 >::MergeCoincidentNodes )
                , ( bp::arg("pVessels"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 2 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > >,double ) ;
            
            VesselNetwork2_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 2 >::MergeCoincidentNodes )
                , ( bp::arg("nodes"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 2 >::MergeShortVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*MergeShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork2_exposer.def( 
                "MergeShortVessels"
                , MergeShortVessels_function_type( &::VesselNetwork< 2 >::MergeShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNetwork< 2 >::NodeIsInNetwork
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef bool ( exported_class_t::*NodeIsInNetwork_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "NodeIsInNetwork"
                , NodeIsInNetwork_function_type( &::VesselNetwork< 2 >::NodeIsInNetwork )
                , ( bp::arg("pSourceNode") ) );
        
        }
        { //::VesselNetwork< 2 >::NumberOfNodesNearLocation
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*NumberOfNodesNearLocation_function_type)( ::DimensionalChastePoint< 2 > const &,double ) ;
            
            VesselNetwork2_exposer.def( 
                "NumberOfNodesNearLocation"
                , NumberOfNodesNearLocation_function_type( &::VesselNetwork< 2 >::NumberOfNodesNearLocation )
                , ( bp::arg("rLocation"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 2 >::RemoveShortVessels
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool ) ;
            
            VesselNetwork2_exposer.def( 
                "RemoveShortVessels"
                , RemoveShortVessels_function_type( &::VesselNetwork< 2 >::RemoveShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres, bp::arg("endsOnly")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 2 >::RemoveVessel
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveVessel_function_type)( ::boost::shared_ptr< Vessel< 2 > >,bool ) ;
            
            VesselNetwork2_exposer.def( 
                "RemoveVessel"
                , RemoveVessel_function_type( &::VesselNetwork< 2 >::RemoveVessel )
                , ( bp::arg("pVessel"), bp::arg("deleteVessel")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 2 >::SetNodeRadii
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork2_exposer.def( 
                "SetNodeRadii"
                , SetNodeRadii_function_type( &::VesselNetwork< 2 >::SetNodeRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 2 >::SetNodeRadiiFromSegments
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadiiFromSegments_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "SetNodeRadiiFromSegments"
                , SetNodeRadiiFromSegments_function_type( &::VesselNetwork< 2 >::SetNodeRadiiFromSegments ) );
        
        }
        { //::VesselNetwork< 2 >::SetSegmentProperties
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentProperties_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > ) ;
            
            VesselNetwork2_exposer.def( 
                "SetSegmentProperties"
                , SetSegmentProperties_function_type( &::VesselNetwork< 2 >::SetSegmentProperties )
                , ( bp::arg("prototype") ) );
        
        }
        { //::VesselNetwork< 2 >::SetSegmentRadii
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork2_exposer.def( 
                "SetSegmentRadii"
                , SetSegmentRadii_function_type( &::VesselNetwork< 2 >::SetSegmentRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 2 >::SetSegmentViscosity
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork2_exposer.def( 
                "SetSegmentViscosity"
                , SetSegmentViscosity_function_type( &::VesselNetwork< 2 >::SetSegmentViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselNetwork< 2 >::Translate
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 2 > ) ;
            
            VesselNetwork2_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 2 >::Translate )
                , ( bp::arg("rTranslationVector") ) );
        
        }
        { //::VesselNetwork< 2 >::Translate
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 2 >,::std::vector< boost::shared_ptr<Vessel<2> > > ) ;
            
            VesselNetwork2_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 2 >::Translate )
                , ( bp::arg("rTranslationVector"), bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 2 >::UpdateAll
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateAll_function_type)( bool ) ;
            
            VesselNetwork2_exposer.def( 
                "UpdateAll"
                , UpdateAll_function_type( &::VesselNetwork< 2 >::UpdateAll )
                , ( bp::arg("merge")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 2 >::UpdateNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::VesselNetwork< 2 >::UpdateNodes ) );
        
        }
        { //::VesselNetwork< 2 >::UpdateSegments
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselNetwork< 2 >::UpdateSegments ) );
        
        }
        { //::VesselNetwork< 2 >::UpdateVesselIds
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselIds_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "UpdateVesselIds"
                , UpdateVesselIds_function_type( &::VesselNetwork< 2 >::UpdateVesselIds ) );
        
        }
        { //::VesselNetwork< 2 >::UpdateVesselNodes
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselNodes_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "UpdateVesselNodes"
                , UpdateVesselNodes_function_type( &::VesselNetwork< 2 >::UpdateVesselNodes ) );
        
        }
        { //::VesselNetwork< 2 >::VesselCrossesLineSegment
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef bool ( exported_class_t::*VesselCrossesLineSegment_function_type)( ::DimensionalChastePoint< 2 > const &,::DimensionalChastePoint< 2 > const &,double ) ;
            
            VesselNetwork2_exposer.def( 
                "VesselCrossesLineSegment"
                , VesselCrossesLineSegment_function_type( &::VesselNetwork< 2 >::VesselCrossesLineSegment )
                , ( bp::arg("rCoord1"), bp::arg("rCoord2"), bp::arg("tolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::VesselNetwork< 2 >::Write
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)( ::std::string const & ) ;
            
            VesselNetwork2_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetwork< 2 >::Write )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetId
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNetwork_less__2__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNetwork2_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 2 >::GetId)
                , default_GetId_function_type(&VesselNetwork_less__2__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNetwork_less__2__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNetwork2_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNetwork_less__2__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNetwork_less__2__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNetwork2_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNetwork_less__2__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetRadius
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNetwork_less__2__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNetwork2_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::GetRadius)
                , default_GetRadius_function_type(&VesselNetwork_less__2__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetId
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNetwork_less__2__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNetwork2_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 2 >::SetId)
                , default_SetId_function_type(&VesselNetwork_less__2__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetOutputData
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNetwork_less__2__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNetwork2_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 2 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNetwork_less__2__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetRadius
        
            typedef VesselNetwork< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNetwork_less__2__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork2_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::SetRadius)
                , default_SetRadius_function_type(&VesselNetwork_less__2__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNetwork2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetwork<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNetwork< 2 > > > >();
    }

    { //::VesselNetwork< 3 >
        typedef bp::class_< VesselNetwork_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselNetwork3_exposer_t;
        VesselNetwork3_exposer_t VesselNetwork3_exposer = VesselNetwork3_exposer_t( "VesselNetwork3", bp::init< >() );
        bp::scope VesselNetwork3_scope( VesselNetwork3_exposer );
        { //::VesselNetwork< 3 >::AddVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "AddVessel"
                , AddVessel_function_type( &::VesselNetwork< 3 >::AddVessel )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 3 >::AddVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "AddVessels"
                , AddVessels_function_type( &::VesselNetwork< 3 >::AddVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::CopySegmentFlowProperties
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopySegmentFlowProperties_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "CopySegmentFlowProperties"
                , CopySegmentFlowProperties_function_type( &::VesselNetwork< 3 >::CopySegmentFlowProperties )
                , ( bp::arg("index")=(unsigned int)(0) ) );
        
        }
        { //::VesselNetwork< 3 >::CopyVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*CopyVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 3 >::CopyVessels ) );
        
        }
        { //::VesselNetwork< 3 >::CopyVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*CopyVessels_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "CopyVessels"
                , CopyVessels_function_type( &::VesselNetwork< 3 >::CopyVessels )
                , ( bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::Create
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 3 > > ( *Create_function_type )(  );
            
            VesselNetwork3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetwork< 3 >::Create ) );
        
        }
        { //::VesselNetwork< 3 >::DivideVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*DivideVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::DimensionalChastePoint< 3 > const & ) ;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( VesselNetwork_less__3__greater__wrapper::*default_DivideVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "DivideVessel"
                , DivideVessel_function_type(&::VesselNetwork< 3 >::DivideVessel)
                , default_DivideVessel_function_type(&VesselNetwork_less__3__greater__wrapper::default_DivideVessel)
                , ( bp::arg("pVessel"), bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::ExtendVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*ExtendVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_ExtendVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "ExtendVessel"
                , ExtendVessel_function_type(&::VesselNetwork< 3 >::ExtendVessel)
                , default_ExtendVessel_function_type(&VesselNetwork_less__3__greater__wrapper::default_ExtendVessel)
                , ( bp::arg("pVessel"), bp::arg("pEndNode"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselNetwork< 3 >::FormSprout
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*FormSprout_function_type)( ::DimensionalChastePoint< 3 > const &,::DimensionalChastePoint< 3 > const & ) ;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( VesselNetwork_less__3__greater__wrapper::*default_FormSprout_function_type)( ::DimensionalChastePoint< 3 > const &,::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "FormSprout"
                , FormSprout_function_type(&::VesselNetwork< 3 >::FormSprout)
                , default_FormSprout_function_type(&VesselNetwork_less__3__greater__wrapper::default_FormSprout)
                , ( bp::arg("sproutBaseLocation"), bp::arg("sproutTipLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetDistanceToNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistanceToNearestNode_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetDistanceToNearestNode"
                , GetDistanceToNearestNode_function_type( &::VesselNetwork< 3 >::GetDistanceToNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetExtents
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< DimensionalChastePoint< 3 >, DimensionalChastePoint< 3 > > ( exported_class_t::*GetExtents_function_type)( bool ) ;
            
            VesselNetwork3_exposer.def( 
                "GetExtents"
                , GetExtents_function_type( &::VesselNetwork< 3 >::GetExtents )
                , ( bp::arg("useRadii")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::GetMaxBranchesOnNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetMaxBranchesOnNode_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetMaxBranchesOnNode"
                , GetMaxBranchesOnNode_function_type( &::VesselNetwork< 3 >::GetMaxBranchesOnNode ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNearestNode_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 3 >::GetNearestNode )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNearestNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestNode"
                , GetNearestNode_function_type( &::VesselNetwork< 3 >::GetNearestNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::boost::shared_ptr< VesselNode< 3 > >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("pNode"), bp::arg("sameVessel")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselSegment< 3 > >, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > > ( exported_class_t::*GetNearestSegment_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestSegment"
                , GetNearestSegment_function_type( &::VesselNetwork< 3 >::GetNearestSegment )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNearestVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetNearestVessel_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNearestVessel"
                , GetNearestVessel_function_type( &::VesselNetwork< 3 >::GetNearestVessel )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNode
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselNetwork< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNodeIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNodeIndex_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNodeIndex"
                , GetNodeIndex_function_type( &::VesselNetwork< 3 >::GetNodeIndex )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselNetwork< 3 >::GetNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselNetwork< 3 >::GetNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::VesselNetwork< 3 >::GetNumberOfNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfVesselNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVesselNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfVesselNodes"
                , GetNumberOfVesselNodes_function_type( &::VesselNetwork< 3 >::GetNumberOfVesselNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetNumberOfVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetNumberOfVessels"
                , GetNumberOfVessels_function_type( &::VesselNetwork< 3 >::GetNumberOfVessels ) );
        
        }
        { //::VesselNetwork< 3 >::GetOutputData
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNetwork< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNetwork< 3 >::GetVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetVessel_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselNetwork< 3 >::GetVessel )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselEndNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetVesselEndNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselEndNodes"
                , GetVesselEndNodes_function_type( &::VesselNetwork< 3 >::GetVesselEndNodes ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselIndex_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselIndex"
                , GetVesselIndex_function_type( &::VesselNetwork< 3 >::GetVesselIndex )
                , ( bp::arg("pVessel") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselSegmentIndex
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVesselSegmentIndex_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselSegmentIndex"
                , GetVesselSegmentIndex_function_type( &::VesselNetwork< 3 >::GetVesselSegmentIndex )
                , ( bp::arg("pVesselSegment") ) );
        
        }
        { //::VesselNetwork< 3 >::GetVesselSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetVesselSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVesselSegments"
                , GetVesselSegments_function_type( &::VesselNetwork< 3 >::GetVesselSegments ) );
        
        }
        { //::VesselNetwork< 3 >::GetVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*GetVessels_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetVessels"
                , GetVessels_function_type( &::VesselNetwork< 3 >::GetVessels ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<Vessel<3> > >,double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("pVessels"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeCoincidentNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeCoincidentNodes_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > >,double ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeCoincidentNodes"
                , MergeCoincidentNodes_function_type( &::VesselNetwork< 3 >::MergeCoincidentNodes )
                , ( bp::arg("nodes"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::MergeShortVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*MergeShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "MergeShortVessels"
                , MergeShortVessels_function_type( &::VesselNetwork< 3 >::MergeShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNetwork< 3 >::NodeIsInNetwork
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef bool ( exported_class_t::*NodeIsInNetwork_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "NodeIsInNetwork"
                , NodeIsInNetwork_function_type( &::VesselNetwork< 3 >::NodeIsInNetwork )
                , ( bp::arg("pSourceNode") ) );
        
        }
        { //::VesselNetwork< 3 >::NumberOfNodesNearLocation
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*NumberOfNodesNearLocation_function_type)( ::DimensionalChastePoint< 3 > const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "NumberOfNodesNearLocation"
                , NumberOfNodesNearLocation_function_type( &::VesselNetwork< 3 >::NumberOfNodesNearLocation )
                , ( bp::arg("rLocation"), bp::arg("tolerance")=0. ) );
        
        }
        { //::VesselNetwork< 3 >::RemoveShortVessels
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveShortVessels_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "RemoveShortVessels"
                , RemoveShortVessels_function_type( &::VesselNetwork< 3 >::RemoveShortVessels )
                , ( bp::arg("cutoff")=10. * 9.9999999999999995E-7 * unit::metres, bp::arg("endsOnly")=(bool)(true) ) );
        
        }
        { //::VesselNetwork< 3 >::RemoveVessel
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > >,bool ) ;
            
            VesselNetwork3_exposer.def( 
                "RemoveVessel"
                , RemoveVessel_function_type( &::VesselNetwork< 3 >::RemoveVessel )
                , ( bp::arg("pVessel"), bp::arg("deleteVessel")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::SetNodeRadii
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetNodeRadii"
                , SetNodeRadii_function_type( &::VesselNetwork< 3 >::SetNodeRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 3 >::SetNodeRadiiFromSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNodeRadiiFromSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "SetNodeRadiiFromSegments"
                , SetNodeRadiiFromSegments_function_type( &::VesselNetwork< 3 >::SetNodeRadiiFromSegments ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentProperties
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentProperties_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentProperties"
                , SetSegmentProperties_function_type( &::VesselNetwork< 3 >::SetSegmentProperties )
                , ( bp::arg("prototype") ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentRadii
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentRadii_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentRadii"
                , SetSegmentRadii_function_type( &::VesselNetwork< 3 >::SetSegmentRadii )
                , ( bp::arg("radius") ) );
        
        }
        { //::VesselNetwork< 3 >::SetSegmentViscosity
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetSegmentViscosity_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::list< boost::units::dim< boost::units::mass_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::list< boost::units::dim< boost::units::time_base_dimension, boost::units::static_rational< -1, 1 > >, boost::units::dimensionless_type > > >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetSegmentViscosity"
                , SetSegmentViscosity_function_type( &::VesselNetwork< 3 >::SetSegmentViscosity )
                , ( bp::arg("viscosity") ) );
        
        }
        { //::VesselNetwork< 3 >::Translate
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 3 > ) ;
            
            VesselNetwork3_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 3 >::Translate )
                , ( bp::arg("rTranslationVector") ) );
        
        }
        { //::VesselNetwork< 3 >::Translate
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::DimensionalChastePoint< 3 >,::std::vector< boost::shared_ptr<Vessel<3> > > ) ;
            
            VesselNetwork3_exposer.def( 
                "Translate"
                , Translate_function_type( &::VesselNetwork< 3 >::Translate )
                , ( bp::arg("rTranslationVector"), bp::arg("vessels") ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateAll
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateAll_function_type)( bool ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateAll"
                , UpdateAll_function_type( &::VesselNetwork< 3 >::UpdateAll )
                , ( bp::arg("merge")=(bool)(false) ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::VesselNetwork< 3 >::UpdateNodes ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateSegments
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateSegments_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateSegments"
                , UpdateSegments_function_type( &::VesselNetwork< 3 >::UpdateSegments ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateVesselIds
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselIds_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateVesselIds"
                , UpdateVesselIds_function_type( &::VesselNetwork< 3 >::UpdateVesselIds ) );
        
        }
        { //::VesselNetwork< 3 >::UpdateVesselNodes
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateVesselNodes_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "UpdateVesselNodes"
                , UpdateVesselNodes_function_type( &::VesselNetwork< 3 >::UpdateVesselNodes ) );
        
        }
        { //::VesselNetwork< 3 >::VesselCrossesLineSegment
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef bool ( exported_class_t::*VesselCrossesLineSegment_function_type)( ::DimensionalChastePoint< 3 > const &,::DimensionalChastePoint< 3 > const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "VesselCrossesLineSegment"
                , VesselCrossesLineSegment_function_type( &::VesselNetwork< 3 >::VesselCrossesLineSegment )
                , ( bp::arg("rCoord1"), bp::arg("rCoord2"), bp::arg("tolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::VesselNetwork< 3 >::Write
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)( ::std::string const & ) ;
            
            VesselNetwork3_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetwork< 3 >::Write )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNetwork_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNetwork3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNetwork_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNetwork3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNetwork_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNetwork3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselNetwork_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNetwork3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNetwork3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselNetwork< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNetwork_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetwork3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselNetwork_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNetwork3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetwork<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNetwork< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNetwork< 3 > > > >();
    }

    bp::class_< VesselNetworkCellPopulationInteractor< 2 > >( "VesselNetworkCellPopulationInteractor2", bp::init< >() )    
        .def( 
            "KillNonVesselOverlappingCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 2 >::KillNonVesselOverlappingCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "KillOverlappingVesselCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 2 >::KillOverlappingVesselCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "LabelVesselsInCellPopulation"
            , (void ( ::VesselNetworkCellPopulationInteractor<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::shared_ptr< AbstractCellMutationState >,::boost::shared_ptr< AbstractCellMutationState >,double ))( &::VesselNetworkCellPopulationInteractor< 2 >::LabelVesselsInCellPopulation )
            , ( bp::arg("cellPopulation"), bp::arg("cellLengthScale"), bp::arg("pTipMutationState"), bp::arg("pStalkState"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "PartitionNetworkOverCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<2>::* )( ::AbstractCellPopulation< 2, 2 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 2 >::PartitionNetworkOverCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::VesselNetworkCellPopulationInteractor<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > > ))( &::VesselNetworkCellPopulationInteractor< 2 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) );

    bp::class_< VesselNetworkCellPopulationInteractor< 3 > >( "VesselNetworkCellPopulationInteractor3", bp::init< >() )    
        .def( 
            "KillNonVesselOverlappingCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 3 >::KillNonVesselOverlappingCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "KillOverlappingVesselCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 3 >::KillOverlappingVesselCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "LabelVesselsInCellPopulation"
            , (void ( ::VesselNetworkCellPopulationInteractor<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::shared_ptr< AbstractCellMutationState >,::boost::shared_ptr< AbstractCellMutationState >,double ))( &::VesselNetworkCellPopulationInteractor< 3 >::LabelVesselsInCellPopulation )
            , ( bp::arg("cellPopulation"), bp::arg("cellLengthScale"), bp::arg("pTipMutationState"), bp::arg("pStalkState"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "PartitionNetworkOverCells"
            , (void ( ::VesselNetworkCellPopulationInteractor<3>::* )( ::AbstractCellPopulation< 3, 3 > &,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double ))( &::VesselNetworkCellPopulationInteractor< 3 >::PartitionNetworkOverCells )
            , ( bp::arg("rCellPopulation"), bp::arg("cellLengthScale"), bp::arg("threshold")=1.2500000000000001E-6 ) )    
        .def( 
            "SetVesselNetwork"
            , (void ( ::VesselNetworkCellPopulationInteractor<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > > ))( &::VesselNetworkCellPopulationInteractor< 3 >::SetVesselNetwork )
            , ( bp::arg("pNetwork") ) );

    bp::class_< VesselNetworkGenerator< 2 > >( "VesselNetworkGenerator2", bp::init< >() )    
        .def( 
            "Generate3dNetwork"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::shared_ptr< Part< 2 > >,::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-2, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >,::VesselDistribution::Value,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool,::std::vector< boost::shared_ptr<DimensionalChastePoint<2> > > ))( &::VesselNetworkGenerator< 2 >::Generate3dNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance"), bp::arg("useBbox"), bp::arg("seeds") ) )    
        .def( 
            "GenerateBifurcationUnit"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 2 > ))( &::VesselNetworkGenerator< 2 >::GenerateBifurcationUnit )
            , ( bp::arg("vesselLength"), bp::arg("startPosition") ) )    
        .def( 
            "GenerateFromPart"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::shared_ptr< Part< 2 > > ))( &::VesselNetworkGenerator< 2 >::GenerateFromPart )
            , ( bp::arg("part") ) )    
        .def( 
            "GenerateHexagonalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 2 >::GenerateHexagonalNetwork )
            , ( bp::arg("width"), bp::arg("height"), bp::arg("vesselLength") ) )    
        .def( 
            "GenerateHexagonalUnit"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 2 >::GenerateHexagonalUnit )
            , ( bp::arg("vesselLength") ) )    
        .def( 
            "GenerateOvalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int,double,double ))( &::VesselNetworkGenerator< 2 >::GenerateOvalNetwork )
            , ( bp::arg("scaleFactor"), bp::arg("num_increments"), bp::arg("a_param"), bp::arg("b_param") ) )    
        .def( 
            "GenerateParrallelNetwork"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::shared_ptr< Part< 2 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::VesselDistribution::Value,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool,::std::vector< boost::shared_ptr<DimensionalChastePoint<2> > > ))( &::VesselNetworkGenerator< 2 >::GenerateParrallelNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance"), bp::arg("useBbox"), bp::arg("seeds") ) )    
        .def( 
            "GenerateSingleVessel"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 2 >,unsigned int,unsigned int ))( &::VesselNetworkGenerator< 2 >::GenerateSingleVessel )
            , ( bp::arg("vesselLength"), bp::arg("startPosition"), bp::arg("divisions"), bp::arg("axis") ) )    
        .def( 
            "GenerateVoronoiNetwork"
            , (::boost::shared_ptr< VesselNetwork< 2 > > ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int ))( &::VesselNetworkGenerator< 2 >::GenerateVoronoiNetwork )
            , ( bp::arg("cubeX"), bp::arg("cubeY"), bp::arg("cubeZ"), bp::arg("numPoints") ) )    
        .def( 
            "MapToSphere"
            , (void ( ::VesselNetworkGenerator<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double,double ))( &::VesselNetworkGenerator< 2 >::MapToSphere )
            , ( bp::arg("pInputUnit"), bp::arg("radius"), bp::arg("thickess"), bp::arg("azimuthExtent"), bp::arg("polarExtent") ) )    
        .def( 
            "PatternUnitByTranslation"
            , (void ( ::VesselNetworkGenerator<2>::* )( ::boost::shared_ptr< VesselNetwork< 2 > >,::std::vector< unsigned int > ))( &::VesselNetworkGenerator< 2 >::PatternUnitByTranslation )
            , ( bp::arg("pInputUnit"), bp::arg("numberOfUnits") ) )    
        .def( 
            "SetReferenceLengthScale"
            , (void ( ::VesselNetworkGenerator<2>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 2 >::SetReferenceLengthScale )
            , ( bp::arg("rReferenceLength") ) );

    bp::class_< VesselNetworkGenerator< 3 > >( "VesselNetworkGenerator3", bp::init< >() )    
        .def( 
            "Generate3dNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > >,::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<-2, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> >,::VesselDistribution::Value,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool,::std::vector< boost::shared_ptr<DimensionalChastePoint<3> > > ))( &::VesselNetworkGenerator< 3 >::Generate3dNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance"), bp::arg("useBbox"), bp::arg("seeds") ) )    
        .def( 
            "GenerateBifurcationUnit"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 3 > ))( &::VesselNetworkGenerator< 3 >::GenerateBifurcationUnit )
            , ( bp::arg("vesselLength"), bp::arg("startPosition") ) )    
        .def( 
            "GenerateFromPart"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > > ))( &::VesselNetworkGenerator< 3 >::GenerateFromPart )
            , ( bp::arg("part") ) )    
        .def( 
            "GenerateHexagonalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::GenerateHexagonalNetwork )
            , ( bp::arg("width"), bp::arg("height"), bp::arg("vesselLength") ) )    
        .def( 
            "GenerateHexagonalUnit"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::GenerateHexagonalUnit )
            , ( bp::arg("vesselLength") ) )    
        .def( 
            "GenerateOvalNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int,double,double ))( &::VesselNetworkGenerator< 3 >::GenerateOvalNetwork )
            , ( bp::arg("scaleFactor"), bp::arg("num_increments"), bp::arg("a_param"), bp::arg("b_param") ) )    
        .def( 
            "GenerateParrallelNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< Part< 3 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< -2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::VesselDistribution::Value,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,bool,::std::vector< boost::shared_ptr<DimensionalChastePoint<3> > > ))( &::VesselNetworkGenerator< 3 >::GenerateParrallelNetwork )
            , ( bp::arg("domain"), bp::arg("targetDensity"), bp::arg("distrbutionType"), bp::arg("exclusionDistance"), bp::arg("useBbox"), bp::arg("seeds") ) )    
        .def( 
            "GenerateSingleVessel"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::DimensionalChastePoint< 3 >,unsigned int,unsigned int ))( &::VesselNetworkGenerator< 3 >::GenerateSingleVessel )
            , ( bp::arg("vesselLength"), bp::arg("startPosition"), bp::arg("divisions"), bp::arg("axis") ) )    
        .def( 
            "GenerateVoronoiNetwork"
            , (::boost::shared_ptr< VesselNetwork< 3 > > ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,unsigned int ))( &::VesselNetworkGenerator< 3 >::GenerateVoronoiNetwork )
            , ( bp::arg("cubeX"), bp::arg("cubeY"), bp::arg("cubeZ"), bp::arg("numPoints") ) )    
        .def( 
            "MapToSphere"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double >,double,double ))( &::VesselNetworkGenerator< 3 >::MapToSphere )
            , ( bp::arg("pInputUnit"), bp::arg("radius"), bp::arg("thickess"), bp::arg("azimuthExtent"), bp::arg("polarExtent") ) )    
        .def( 
            "PatternUnitByTranslation"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::shared_ptr< VesselNetwork< 3 > >,::std::vector< unsigned int > ))( &::VesselNetworkGenerator< 3 >::PatternUnitByTranslation )
            , ( bp::arg("pInputUnit"), bp::arg("numberOfUnits") ) )    
        .def( 
            "SetReferenceLengthScale"
            , (void ( ::VesselNetworkGenerator<3>::* )( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ))( &::VesselNetworkGenerator< 3 >::SetReferenceLengthScale )
            , ( bp::arg("rReferenceLength") ) );

    { //::VesselNetworkGeometryCalculator< 2 >
        typedef bp::class_< VesselNetworkGeometryCalculator< 2 > > VesselNetworkGeometryCalculator2_exposer_t;
        VesselNetworkGeometryCalculator2_exposer_t VesselNetworkGeometryCalculator2_exposer = VesselNetworkGeometryCalculator2_exposer_t( "VesselNetworkGeometryCalculator2", bp::init< >() );
        bp::scope VesselNetworkGeometryCalculator2_scope( VesselNetworkGeometryCalculator2_exposer );
        { //::VesselNetworkGeometryCalculator< 2 >::Create
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkGeometryCalculator< 2 > > ( *Create_function_type )(  );
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkGeometryCalculator< 2 >::Create ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetAverageInterSegmentDistance
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetAverageInterSegmentDistance_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetAverageInterSegmentDistance"
                , GetAverageInterSegmentDistance_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetAverageInterSegmentDistance ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetAverageVesselLength
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetAverageVesselLength_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetAverageVesselLength"
                , GetAverageVesselLength_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetAverageVesselLength ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetInterCapillaryDistances
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetInterCapillaryDistances_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetInterCapillaryDistances"
                , GetInterCapillaryDistances_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetInterCapillaryDistances ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetTotalLength
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalLength_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetTotalLength"
                , GetTotalLength_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetTotalLength ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetTotalSurfaceArea
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalSurfaceArea_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetTotalSurfaceArea"
                , GetTotalSurfaceArea_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetTotalSurfaceArea ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetTotalVolume
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalVolume_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetTotalVolume"
                , GetTotalVolume_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetTotalVolume ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::GetVesselLengthDistribution
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef ::std::vector< unsigned int > ( exported_class_t::*GetVesselLengthDistribution_function_type)( double,unsigned int ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "GetVesselLengthDistribution"
                , GetVesselLengthDistribution_function_type( &::VesselNetworkGeometryCalculator< 2 >::GetVesselLengthDistribution )
                , ( bp::arg("binSpacing")=10., bp::arg("numberOfBins")=(unsigned int)(10) ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 2 >::SetVesselNetwork
        
            typedef VesselNetworkGeometryCalculator< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            VesselNetworkGeometryCalculator2_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkGeometryCalculator< 2 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        VesselNetworkGeometryCalculator2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkGeometryCalculator<2> > >();
    }

    { //::VesselNetworkGeometryCalculator< 3 >
        typedef bp::class_< VesselNetworkGeometryCalculator< 3 > > VesselNetworkGeometryCalculator3_exposer_t;
        VesselNetworkGeometryCalculator3_exposer_t VesselNetworkGeometryCalculator3_exposer = VesselNetworkGeometryCalculator3_exposer_t( "VesselNetworkGeometryCalculator3", bp::init< >() );
        bp::scope VesselNetworkGeometryCalculator3_scope( VesselNetworkGeometryCalculator3_exposer );
        { //::VesselNetworkGeometryCalculator< 3 >::Create
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkGeometryCalculator< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkGeometryCalculator< 3 >::Create ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetAverageInterSegmentDistance
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetAverageInterSegmentDistance_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetAverageInterSegmentDistance"
                , GetAverageInterSegmentDistance_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetAverageInterSegmentDistance ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetAverageVesselLength
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetAverageVesselLength_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetAverageVesselLength"
                , GetAverageVesselLength_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetAverageVesselLength ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetInterCapillaryDistances
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::std::vector< boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension, boost::units::static_rational<1, 1> >, boost::units::dimensionless_type>, boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >, void>, double> > ( exported_class_t::*GetInterCapillaryDistances_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetInterCapillaryDistances"
                , GetInterCapillaryDistances_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetInterCapillaryDistances ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetTotalLength
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalLength_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetTotalLength"
                , GetTotalLength_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetTotalLength ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetTotalSurfaceArea
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 2, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalSurfaceArea_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetTotalSurfaceArea"
                , GetTotalSurfaceArea_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetTotalSurfaceArea ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetTotalVolume
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 3, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetTotalVolume_function_type)(  ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetTotalVolume"
                , GetTotalVolume_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetTotalVolume ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::GetVesselLengthDistribution
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef ::std::vector< unsigned int > ( exported_class_t::*GetVesselLengthDistribution_function_type)( double,unsigned int ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "GetVesselLengthDistribution"
                , GetVesselLengthDistribution_function_type( &::VesselNetworkGeometryCalculator< 3 >::GetVesselLengthDistribution )
                , ( bp::arg("binSpacing")=10., bp::arg("numberOfBins")=(unsigned int)(10) ) );
        
        }
        { //::VesselNetworkGeometryCalculator< 3 >::SetVesselNetwork
        
            typedef VesselNetworkGeometryCalculator< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            VesselNetworkGeometryCalculator3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkGeometryCalculator< 3 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        VesselNetworkGeometryCalculator3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkGeometryCalculator<3> > >();
    }

    { //::VesselNetworkGraphCalculator< 2 >
        typedef bp::class_< VesselNetworkGraphCalculator< 2 > > VesselNetworkGraphCalculator2_exposer_t;
        VesselNetworkGraphCalculator2_exposer_t VesselNetworkGraphCalculator2_exposer = VesselNetworkGraphCalculator2_exposer_t( "VesselNetworkGraphCalculator2", bp::init< >() );
        bp::scope VesselNetworkGraphCalculator2_scope( VesselNetworkGraphCalculator2_exposer );
        { //::VesselNetworkGraphCalculator< 2 >::Create
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkGraphCalculator< 2 > > ( *Create_function_type )(  );
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkGraphCalculator< 2 >::Create ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::GetNodeNodeConnectivity
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef ::std::vector< std::vector< unsigned int > > ( exported_class_t::*GetNodeNodeConnectivity_function_type)(  ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "GetNodeNodeConnectivity"
                , GetNodeNodeConnectivity_function_type( &::VesselNetworkGraphCalculator< 2 >::GetNodeNodeConnectivity ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::GetNodeVesselConnectivity
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef ::std::vector< std::vector< unsigned int > > ( exported_class_t::*GetNodeVesselConnectivity_function_type)(  ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "GetNodeVesselConnectivity"
                , GetNodeVesselConnectivity_function_type( &::VesselNetworkGraphCalculator< 2 >::GetNodeVesselConnectivity ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::IsConnected
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnected_function_type)( ::boost::shared_ptr< VesselNode< 2 > >,::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "IsConnected"
                , IsConnected_function_type( &::VesselNetworkGraphCalculator< 2 >::IsConnected )
                , ( bp::arg("pSourceNode"), bp::arg("pQueryNode") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::IsConnected
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef ::std::vector< bool > ( exported_class_t::*IsConnected_function_type)( ::std::vector< boost::shared_ptr<VesselNode<2> > >,::std::vector< boost::shared_ptr<VesselNode<2> > > ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "IsConnected"
                , IsConnected_function_type( &::VesselNetworkGraphCalculator< 2 >::IsConnected )
                , ( bp::arg("sourceNodes"), bp::arg("queryNodes") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::SetVesselNetwork
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkGraphCalculator< 2 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 2 >::WriteConnectivity
        
            typedef VesselNetworkGraphCalculator< 2 > exported_class_t;
            typedef void ( exported_class_t::*WriteConnectivity_function_type)( ::std::string const & ) ;
            
            VesselNetworkGraphCalculator2_exposer.def( 
                "WriteConnectivity"
                , WriteConnectivity_function_type( &::VesselNetworkGraphCalculator< 2 >::WriteConnectivity )
                , ( bp::arg("rFilename") ) );
        
        }
        VesselNetworkGraphCalculator2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkGraphCalculator<2> > >();
    }

    { //::VesselNetworkGraphCalculator< 3 >
        typedef bp::class_< VesselNetworkGraphCalculator< 3 > > VesselNetworkGraphCalculator3_exposer_t;
        VesselNetworkGraphCalculator3_exposer_t VesselNetworkGraphCalculator3_exposer = VesselNetworkGraphCalculator3_exposer_t( "VesselNetworkGraphCalculator3", bp::init< >() );
        bp::scope VesselNetworkGraphCalculator3_scope( VesselNetworkGraphCalculator3_exposer );
        { //::VesselNetworkGraphCalculator< 3 >::Create
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkGraphCalculator< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkGraphCalculator< 3 >::Create ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::GetNodeNodeConnectivity
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef ::std::vector< std::vector< unsigned int > > ( exported_class_t::*GetNodeNodeConnectivity_function_type)(  ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "GetNodeNodeConnectivity"
                , GetNodeNodeConnectivity_function_type( &::VesselNetworkGraphCalculator< 3 >::GetNodeNodeConnectivity ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::GetNodeVesselConnectivity
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef ::std::vector< std::vector< unsigned int > > ( exported_class_t::*GetNodeVesselConnectivity_function_type)(  ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "GetNodeVesselConnectivity"
                , GetNodeVesselConnectivity_function_type( &::VesselNetworkGraphCalculator< 3 >::GetNodeVesselConnectivity ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::IsConnected
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnected_function_type)( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "IsConnected"
                , IsConnected_function_type( &::VesselNetworkGraphCalculator< 3 >::IsConnected )
                , ( bp::arg("pSourceNode"), bp::arg("pQueryNode") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::IsConnected
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef ::std::vector< bool > ( exported_class_t::*IsConnected_function_type)( ::std::vector< boost::shared_ptr<VesselNode<3> > >,::std::vector< boost::shared_ptr<VesselNode<3> > > ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "IsConnected"
                , IsConnected_function_type( &::VesselNetworkGraphCalculator< 3 >::IsConnected )
                , ( bp::arg("sourceNodes"), bp::arg("queryNodes") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::SetVesselNetwork
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkGraphCalculator< 3 >::SetVesselNetwork )
                , ( bp::arg("pVesselNetwork") ) );
        
        }
        { //::VesselNetworkGraphCalculator< 3 >::WriteConnectivity
        
            typedef VesselNetworkGraphCalculator< 3 > exported_class_t;
            typedef void ( exported_class_t::*WriteConnectivity_function_type)( ::std::string const & ) ;
            
            VesselNetworkGraphCalculator3_exposer.def( 
                "WriteConnectivity"
                , WriteConnectivity_function_type( &::VesselNetworkGraphCalculator< 3 >::WriteConnectivity )
                , ( bp::arg("rFilename") ) );
        
        }
        VesselNetworkGraphCalculator3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkGraphCalculator<3> > >();
    }

    { //::VesselNetworkReader< 2 >
        typedef bp::class_< VesselNetworkReader< 2 > > VesselNetworkReader2_exposer_t;
        VesselNetworkReader2_exposer_t VesselNetworkReader2_exposer = VesselNetworkReader2_exposer_t( "VesselNetworkReader2", bp::init< >() );
        bp::scope VesselNetworkReader2_scope( VesselNetworkReader2_exposer );
        { //::VesselNetworkReader< 2 >::Create
        
            typedef VesselNetworkReader< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkReader< 2 > > ( *Create_function_type )(  );
            
            VesselNetworkReader2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkReader< 2 >::Create ) );
        
        }
        { //::VesselNetworkReader< 2 >::Read
        
            typedef VesselNetworkReader< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 2 > > ( exported_class_t::*Read_function_type)(  ) ;
            
            VesselNetworkReader2_exposer.def( 
                "Read"
                , Read_function_type( &::VesselNetworkReader< 2 >::Read ) );
        
        }
        { //::VesselNetworkReader< 2 >::SetFileName
        
            typedef VesselNetworkReader< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader2_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkReader< 2 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkReader< 2 >::SetRadiusArrayName
        
            typedef VesselNetworkReader< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadiusArrayName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader2_exposer.def( 
                "SetRadiusArrayName"
                , SetRadiusArrayName_function_type( &::VesselNetworkReader< 2 >::SetRadiusArrayName )
                , ( bp::arg("rRadius") ) );
        
        }
        { //::VesselNetworkReader< 2 >::SetReferenceLengthScale
        
            typedef VesselNetworkReader< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkReader2_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkReader< 2 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        VesselNetworkReader2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkReader<2> > >();
    }

    { //::VesselNetworkReader< 3 >
        typedef bp::class_< VesselNetworkReader< 3 > > VesselNetworkReader3_exposer_t;
        VesselNetworkReader3_exposer_t VesselNetworkReader3_exposer = VesselNetworkReader3_exposer_t( "VesselNetworkReader3", bp::init< >() );
        bp::scope VesselNetworkReader3_scope( VesselNetworkReader3_exposer );
        { //::VesselNetworkReader< 3 >::Create
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkReader< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkReader3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkReader< 3 >::Create ) );
        
        }
        { //::VesselNetworkReader< 3 >::Read
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetwork< 3 > > ( exported_class_t::*Read_function_type)(  ) ;
            
            VesselNetworkReader3_exposer.def( 
                "Read"
                , Read_function_type( &::VesselNetworkReader< 3 >::Read ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetFileName
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkReader< 3 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetRadiusArrayName
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadiusArrayName_function_type)( ::std::string const & ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetRadiusArrayName"
                , SetRadiusArrayName_function_type( &::VesselNetworkReader< 3 >::SetRadiusArrayName )
                , ( bp::arg("rRadius") ) );
        
        }
        { //::VesselNetworkReader< 3 >::SetReferenceLengthScale
        
            typedef VesselNetworkReader< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkReader3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkReader< 3 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        VesselNetworkReader3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkReader<3> > >();
    }

    { //::VesselNetworkWriter< 2 >
        typedef bp::class_< VesselNetworkWriter< 2 > > VesselNetworkWriter2_exposer_t;
        VesselNetworkWriter2_exposer_t VesselNetworkWriter2_exposer = VesselNetworkWriter2_exposer_t( "VesselNetworkWriter2", bp::init< >() );
        bp::scope VesselNetworkWriter2_scope( VesselNetworkWriter2_exposer );
        { //::VesselNetworkWriter< 2 >::Create
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkWriter< 2 > > ( *Create_function_type )(  );
            
            VesselNetworkWriter2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkWriter< 2 >::Create ) );
        
        }
        { //::VesselNetworkWriter< 2 >::GetOutput
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef ::vtkSmartPointer< vtkPolyData > ( exported_class_t::*GetOutput_function_type)(  ) ;
            
            VesselNetworkWriter2_exposer.def( 
                "GetOutput"
                , GetOutput_function_type( &::VesselNetworkWriter< 2 >::GetOutput ) );
        
        }
        { //::VesselNetworkWriter< 2 >::SetFileName
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkWriter2_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkWriter< 2 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkWriter< 2 >::SetReferenceLengthScale
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkWriter2_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkWriter< 2 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        { //::VesselNetworkWriter< 2 >::SetVesselNetwork
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 2 > > ) ;
            
            VesselNetworkWriter2_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkWriter< 2 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::VesselNetworkWriter< 2 >::Write
        
            typedef VesselNetworkWriter< 2 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            
            VesselNetworkWriter2_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetworkWriter< 2 >::Write ) );
        
        }
        VesselNetworkWriter2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkWriter<2> > >();
    }

    { //::VesselNetworkWriter< 3 >
        typedef bp::class_< VesselNetworkWriter< 3 > > VesselNetworkWriter3_exposer_t;
        VesselNetworkWriter3_exposer_t VesselNetworkWriter3_exposer = VesselNetworkWriter3_exposer_t( "VesselNetworkWriter3", bp::init< >() );
        bp::scope VesselNetworkWriter3_scope( VesselNetworkWriter3_exposer );
        { //::VesselNetworkWriter< 3 >::Create
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNetworkWriter< 3 > > ( *Create_function_type )(  );
            
            VesselNetworkWriter3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNetworkWriter< 3 >::Create ) );
        
        }
        { //::VesselNetworkWriter< 3 >::GetOutput
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef ::vtkSmartPointer< vtkPolyData > ( exported_class_t::*GetOutput_function_type)(  ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "GetOutput"
                , GetOutput_function_type( &::VesselNetworkWriter< 3 >::GetOutput ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetFileName
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFileName_function_type)( ::std::string const & ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetFileName"
                , SetFileName_function_type( &::VesselNetworkWriter< 3 >::SetFileName )
                , ( bp::arg("rFileName") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetReferenceLengthScale
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNetworkWriter< 3 >::SetReferenceLengthScale )
                , ( bp::arg("rReferenceLength") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::SetVesselNetwork
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetVesselNetwork_function_type)( ::boost::shared_ptr< VesselNetwork< 3 > > ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "SetVesselNetwork"
                , SetVesselNetwork_function_type( &::VesselNetworkWriter< 3 >::SetVesselNetwork )
                , ( bp::arg("pNetwork") ) );
        
        }
        { //::VesselNetworkWriter< 3 >::Write
        
            typedef VesselNetworkWriter< 3 > exported_class_t;
            typedef void ( exported_class_t::*Write_function_type)(  ) ;
            
            VesselNetworkWriter3_exposer.def( 
                "Write"
                , Write_function_type( &::VesselNetworkWriter< 3 >::Write ) );
        
        }
        VesselNetworkWriter3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNetworkWriter<3> > >();
    }

    { //::VesselNode< 2 >
        typedef bp::class_< VesselNode_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 2 > > > VesselNode2_exposer_t;
        VesselNode2_exposer_t VesselNode2_exposer = VesselNode2_exposer_t( "VesselNode2", bp::init< double, double, double, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >(( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") )) );
        bp::scope VesselNode2_scope( VesselNode2_exposer );
        VesselNode2_exposer.def( bp::init< bp::optional< double, double, double > >(( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. )) );
        bp::implicitly_convertible< double, VesselNode< 2 > >();
        VesselNode2_exposer.def( bp::init< DimensionalChastePoint< 2 > const & >(( bp::arg("location") )) );
        bp::implicitly_convertible< DimensionalChastePoint< 2 > const &, VesselNode< 2 > >();
        VesselNode2_exposer.def( bp::init< VesselNode< 2 > const & >(( bp::arg("rExistingNode") )) );
        { //::VesselNode< 2 >::Create
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( *Create_function_type )( double,double,double );
            
            VesselNode2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 2 >::Create )
                , ( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. ) );
        
        }
        { //::VesselNode< 2 >::Create
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( *Create_function_type )( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > );
            
            VesselNode2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 2 >::Create )
                , ( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") ) );
        
        }
        { //::VesselNode< 2 >::Create
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( *Create_function_type )( ::DimensionalChastePoint< 2 > const & );
            
            VesselNode2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 2 >::Create )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselNode< 2 >::Create
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( *Create_function_type )( ::VesselNode< 2 > const & );
            
            VesselNode2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 2 >::Create )
                , ( bp::arg("rExistingNode") ) );
        
        }
        { //::VesselNode< 2 >::Create
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 2 > > );
            
            VesselNode2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 2 >::Create )
                , ( bp::arg("pExistingNode") ) );
        
        }
        { //::VesselNode< 2 >::GetComparisonId
        
            typedef VesselNode< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetComparisonId_function_type)(  ) ;
            
            VesselNode2_exposer.def( 
                "GetComparisonId"
                , GetComparisonId_function_type( &::VesselNode< 2 >::GetComparisonId ) );
        
        }
        { //::VesselNode< 2 >::GetDistance
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 2 > const & ) const;
            
            VesselNode2_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselNode< 2 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 2 >::GetFlowProperties
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< NodeFlowProperties< 2 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselNode< 2 >::GetFlowProperties ) );
        
        }
        { //::VesselNode< 2 >::GetNumberOfSegments
        
            typedef VesselNode< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::VesselNode< 2 >::GetNumberOfSegments ) );
        
        }
        { //::VesselNode< 2 >::GetOutputData
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNode_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNode2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNode< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNode_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNode< 2 >::GetReferenceLengthScale
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetReferenceLengthScale_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetReferenceLengthScale"
                , GetReferenceLengthScale_function_type( &::VesselNode< 2 >::GetReferenceLengthScale ) );
        
        }
        { //::VesselNode< 2 >::GetSegment
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 2 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) const;
            
            VesselNode2_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::VesselNode< 2 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNode< 2 >::GetSegments
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<2> > > ( exported_class_t::*GetSegments_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::VesselNode< 2 >::GetSegments ) );
        
        }
        { //::VesselNode< 2 >::IsAttachedTo
        
            typedef VesselNode< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsAttachedTo_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > const ) const;
            
            VesselNode2_exposer.def( 
                "IsAttachedTo"
                , IsAttachedTo_function_type( &::VesselNode< 2 >::IsAttachedTo )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNode< 2 >::IsCoincident
        
            typedef VesselNode< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsCoincident_function_type)( ::DimensionalChastePoint< 2 > const & ) const;
            
            VesselNode2_exposer.def( 
                "IsCoincident"
                , IsCoincident_function_type( &::VesselNode< 2 >::IsCoincident )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 2 >::IsMigrating
        
            typedef VesselNode< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsMigrating_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "IsMigrating"
                , IsMigrating_function_type( &::VesselNode< 2 >::IsMigrating ) );
        
        }
        { //::VesselNode< 2 >::SetComparisonId
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetComparisonId_function_type)( unsigned int ) ;
            
            VesselNode2_exposer.def( 
                "SetComparisonId"
                , SetComparisonId_function_type( &::VesselNode< 2 >::SetComparisonId )
                , ( bp::arg("id") ) );
        
        }
        { //::VesselNode< 2 >::SetFlowProperties
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::NodeFlowProperties< 2 > const & ) ;
            
            VesselNode2_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselNode< 2 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::VesselNode< 2 >::SetIsMigrating
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsMigrating_function_type)( bool ) ;
            
            VesselNode2_exposer.def( 
                "SetIsMigrating"
                , SetIsMigrating_function_type( &::VesselNode< 2 >::SetIsMigrating )
                , ( bp::arg("isMigrating") ) );
        
        }
        { //::VesselNode< 2 >::SetLocation
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( ::DimensionalChastePoint< 2 > const & ) ;
            
            VesselNode2_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 2 >::SetLocation )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 2 >::SetLocation
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode2_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 2 >::SetLocation )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z")=0., bp::arg("referenceLength")=9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNode< 2 >::SetReferenceLengthScale
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode2_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNode< 2 >::SetReferenceLengthScale )
                , ( bp::arg("lenthScale") ) );
        
        }
        { //::VesselNode< 2 >::rGetLocation
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::DimensionalChastePoint< 2 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::VesselNode< 2 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetId
        
            typedef VesselNode< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNode_less__2__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 2 >::GetId)
                , default_GetId_function_type(&VesselNode_less__2__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNode_less__2__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNode2_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNode_less__2__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue
        
            typedef VesselNode< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNode_less__2__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNode2_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNode_less__2__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetRadius
        
            typedef VesselNode< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNode_less__2__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNode2_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::GetRadius)
                , default_GetRadius_function_type(&VesselNode_less__2__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetId
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNode_less__2__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNode2_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 2 >::SetId)
                , default_SetId_function_type(&VesselNode_less__2__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetOutputData
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNode_less__2__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNode2_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 2 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNode_less__2__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetRadius
        
            typedef VesselNode< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNode_less__2__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode2_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::SetRadius)
                , default_SetRadius_function_type(&VesselNode_less__2__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNode2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNode<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNode< 2 > > > >();
    }

    { //::VesselNode< 3 >
        typedef bp::class_< VesselNode_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselNode3_exposer_t;
        VesselNode3_exposer_t VesselNode3_exposer = VesselNode3_exposer_t( "VesselNode3", bp::init< double, double, double, boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > >(( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") )) );
        bp::scope VesselNode3_scope( VesselNode3_exposer );
        VesselNode3_exposer.def( bp::init< bp::optional< double, double, double > >(( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. )) );
        bp::implicitly_convertible< double, VesselNode< 3 > >();
        VesselNode3_exposer.def( bp::init< DimensionalChastePoint< 3 > const & >(( bp::arg("location") )) );
        bp::implicitly_convertible< DimensionalChastePoint< 3 > const &, VesselNode< 3 > >();
        VesselNode3_exposer.def( bp::init< VesselNode< 3 > const & >(( bp::arg("rExistingNode") )) );
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( double,double,double );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("v1")=0., bp::arg("v2")=0., bp::arg("v3")=0. ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("referenceLength") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::DimensionalChastePoint< 3 > const & );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::VesselNode< 3 > const & );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("rExistingNode") ) );
        
        }
        { //::VesselNode< 3 >::Create
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > > );
            
            VesselNode3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselNode< 3 >::Create )
                , ( bp::arg("pExistingNode") ) );
        
        }
        { //::VesselNode< 3 >::GetComparisonId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetComparisonId_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetComparisonId"
                , GetComparisonId_function_type( &::VesselNode< 3 >::GetComparisonId ) );
        
        }
        { //::VesselNode< 3 >::GetDistance
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselNode3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselNode< 3 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::GetFlowProperties
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< NodeFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselNode< 3 >::GetFlowProperties ) );
        
        }
        { //::VesselNode< 3 >::GetNumberOfSegments
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::VesselNode< 3 >::GetNumberOfSegments ) );
        
        }
        { //::VesselNode< 3 >::GetOutputData
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselNode_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselNode< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselNode< 3 >::GetReferenceLengthScale
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetReferenceLengthScale_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetReferenceLengthScale"
                , GetReferenceLengthScale_function_type( &::VesselNode< 3 >::GetReferenceLengthScale ) );
        
        }
        { //::VesselNode< 3 >::GetSegment
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) const;
            
            VesselNode3_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::VesselNode< 3 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselNode< 3 >::GetSegments
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetSegments_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::VesselNode< 3 >::GetSegments ) );
        
        }
        { //::VesselNode< 3 >::IsAttachedTo
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsAttachedTo_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > const ) const;
            
            VesselNode3_exposer.def( 
                "IsAttachedTo"
                , IsAttachedTo_function_type( &::VesselNode< 3 >::IsAttachedTo )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselNode< 3 >::IsCoincident
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsCoincident_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselNode3_exposer.def( 
                "IsCoincident"
                , IsCoincident_function_type( &::VesselNode< 3 >::IsCoincident )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::IsMigrating
        
            typedef VesselNode< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsMigrating_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "IsMigrating"
                , IsMigrating_function_type( &::VesselNode< 3 >::IsMigrating ) );
        
        }
        { //::VesselNode< 3 >::SetComparisonId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetComparisonId_function_type)( unsigned int ) ;
            
            VesselNode3_exposer.def( 
                "SetComparisonId"
                , SetComparisonId_function_type( &::VesselNode< 3 >::SetComparisonId )
                , ( bp::arg("id") ) );
        
        }
        { //::VesselNode< 3 >::SetFlowProperties
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::NodeFlowProperties< 3 > const & ) ;
            
            VesselNode3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselNode< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::VesselNode< 3 >::SetIsMigrating
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsMigrating_function_type)( bool ) ;
            
            VesselNode3_exposer.def( 
                "SetIsMigrating"
                , SetIsMigrating_function_type( &::VesselNode< 3 >::SetIsMigrating )
                , ( bp::arg("isMigrating") ) );
        
        }
        { //::VesselNode< 3 >::SetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            VesselNode3_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 3 >::SetLocation )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::VesselNode< 3 >::SetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLocation_function_type)( double,double,double,::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetLocation"
                , SetLocation_function_type( &::VesselNode< 3 >::SetLocation )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z")=0., bp::arg("referenceLength")=9.9999999999999995E-7 * unit::metres ) );
        
        }
        { //::VesselNode< 3 >::SetReferenceLengthScale
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetReferenceLengthScale_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetReferenceLengthScale"
                , SetReferenceLengthScale_function_type( &::VesselNode< 3 >::SetReferenceLengthScale )
                , ( bp::arg("lenthScale") ) );
        
        }
        { //::VesselNode< 3 >::rGetLocation
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::VesselNode< 3 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselNode_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselNode_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselNode_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselNode< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselNode_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselNode3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselNode_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselNode< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselNode_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselNode3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselNode_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselNode3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselNode_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselNode3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselNode_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselNode< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselNode_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselNode3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselNode_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselNode3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselNode<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselNode< 3 > > > >();
    }

    { //::VesselSegment< 2 >
        typedef bp::class_< VesselSegment_less__2__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 2 > > > VesselSegment2_exposer_t;
        VesselSegment2_exposer_t VesselSegment2_exposer = VesselSegment2_exposer_t( "VesselSegment2", bp::no_init );
        bp::scope VesselSegment2_scope( VesselSegment2_exposer );
        VesselSegment2_exposer.def( bp::init< VesselSegment< 2 > const & >(( bp::arg("rSegment") )) );
        { //::VesselSegment< 2 >::CopyDataFromExistingSegment
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingSegment_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > const ) ;
            
            VesselSegment2_exposer.def( 
                "CopyDataFromExistingSegment"
                , CopyDataFromExistingSegment_function_type( &::VesselSegment< 2 >::CopyDataFromExistingSegment )
                , ( bp::arg("pTargetSegment") ) );
        
        }
        { //::VesselSegment< 2 >::Create
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 2 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 2 > >,::boost::shared_ptr< VesselNode< 2 > > );
            
            VesselSegment2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 2 >::Create )
                , ( bp::arg("pNode1"), bp::arg("pNode2") ) );
        
        }
        { //::VesselSegment< 2 >::Create
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 2 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 2 > > );
            
            VesselSegment2_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 2 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselSegment< 2 >::GetDistance
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 2 > const & ) const;
            
            VesselSegment2_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselSegment< 2 >::GetDistance )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselSegment< 2 >::GetFlowProperties
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< SegmentFlowProperties< 2 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselSegment< 2 >::GetFlowProperties ) );
        
        }
        { //::VesselSegment< 2 >::GetLength
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::VesselSegment< 2 >::GetLength ) );
        
        }
        { //::VesselSegment< 2 >::GetMidPoint
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::DimensionalChastePoint< 2 > ( exported_class_t::*GetMidPoint_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetMidPoint"
                , GetMidPoint_function_type( &::VesselSegment< 2 >::GetMidPoint ) );
        
        }
        { //::VesselSegment< 2 >::GetNode
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) const;
            
            VesselSegment2_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselSegment< 2 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselSegment< 2 >::GetNodes
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselNode< 2 > >, boost::shared_ptr< VesselNode< 2 > > > ( exported_class_t::*GetNodes_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselSegment< 2 >::GetNodes ) );
        
        }
        { //::VesselSegment< 2 >::GetOppositeNode
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 2 > > ( exported_class_t::*GetOppositeNode_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) const;
            
            VesselSegment2_exposer.def( 
                "GetOppositeNode"
                , GetOppositeNode_function_type( &::VesselSegment< 2 >::GetOppositeNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselSegment< 2 >::GetOutputData
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselSegment_less__2__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselSegment2_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselSegment< 2 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselSegment_less__2__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselSegment< 2 >::GetPointProjection
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::DimensionalChastePoint< 2 > ( exported_class_t::*GetPointProjection_function_type)( ::DimensionalChastePoint< 2 > const &,bool ) const;
            
            VesselSegment2_exposer.def( 
                "GetPointProjection"
                , GetPointProjection_function_type( &::VesselSegment< 2 >::GetPointProjection )
                , ( bp::arg("location"), bp::arg("projectToEnds")=(bool)(false) ) );
        
        }
        { //::VesselSegment< 2 >::GetUnitTangent
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetUnitTangent_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetUnitTangent"
                , GetUnitTangent_function_type( &::VesselSegment< 2 >::GetUnitTangent ) );
        
        }
        { //::VesselSegment< 2 >::GetVessel
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 2 > > ( exported_class_t::*GetVessel_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselSegment< 2 >::GetVessel ) );
        
        }
        { //::VesselSegment< 2 >::HasNode
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef bool ( exported_class_t::*HasNode_function_type)( ::boost::shared_ptr< VesselNode< 2 > > ) const;
            
            VesselSegment2_exposer.def( 
                "HasNode"
                , HasNode_function_type( &::VesselSegment< 2 >::HasNode )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselSegment< 2 >::IsConnectedTo
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< VesselSegment< 2 > > ) const;
            
            VesselSegment2_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::VesselSegment< 2 >::IsConnectedTo )
                , ( bp::arg("pOtherSegment") ) );
        
        }
        { //::VesselSegment< 2 >::Remove
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            VesselSegment2_exposer.def( 
                "Remove"
                , Remove_function_type( &::VesselSegment< 2 >::Remove ) );
        
        }
        { //::VesselSegment< 2 >::ReplaceNode
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*ReplaceNode_function_type)( unsigned int,::boost::shared_ptr< VesselNode< 2 > > ) ;
            
            VesselSegment2_exposer.def( 
                "ReplaceNode"
                , ReplaceNode_function_type( &::VesselSegment< 2 >::ReplaceNode )
                , ( bp::arg("oldNodeIndex"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselSegment< 2 >::SetFlowProperties
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::SegmentFlowProperties< 2 > const & ) ;
            
            VesselSegment2_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselSegment< 2 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetId
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselSegment_less__2__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 2 >::GetId)
                , default_GetId_function_type(&VesselSegment_less__2__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselSegment_less__2__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselSegment2_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselSegment_less__2__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselSegment_less__2__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselSegment2_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 2 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselSegment_less__2__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::GetRadius
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselSegment_less__2__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselSegment2_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::GetRadius)
                , default_GetRadius_function_type(&VesselSegment_less__2__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetId
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselSegment_less__2__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselSegment2_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 2 >::SetId)
                , default_SetId_function_type(&VesselSegment_less__2__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetOutputData
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselSegment_less__2__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselSegment2_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 2 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselSegment_less__2__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 2 >::SetRadius
        
            typedef VesselSegment< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselSegment_less__2__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselSegment2_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 2 >::SetRadius)
                , default_SetRadius_function_type(&VesselSegment_less__2__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselSegment2_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselSegment<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 2 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 2 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselSegment< 2 > > > >();
    }

    { //::VesselSegment< 3 >
        typedef bp::class_< VesselSegment_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > > > VesselSegment3_exposer_t;
        VesselSegment3_exposer_t VesselSegment3_exposer = VesselSegment3_exposer_t( "VesselSegment3", bp::no_init );
        bp::scope VesselSegment3_scope( VesselSegment3_exposer );
        VesselSegment3_exposer.def( bp::init< VesselSegment< 3 > const & >(( bp::arg("rSegment") )) );
        { //::VesselSegment< 3 >::CopyDataFromExistingSegment
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > const ) ;
            
            VesselSegment3_exposer.def( 
                "CopyDataFromExistingSegment"
                , CopyDataFromExistingSegment_function_type( &::VesselSegment< 3 >::CopyDataFromExistingSegment )
                , ( bp::arg("pTargetSegment") ) );
        
        }
        { //::VesselSegment< 3 >::Create
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > );
            
            VesselSegment3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 3 >::Create )
                , ( bp::arg("pNode1"), bp::arg("pNode2") ) );
        
        }
        { //::VesselSegment< 3 >::Create
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 3 > > );
            
            VesselSegment3_exposer.def( 
                "Create"
                , Create_function_type( &::VesselSegment< 3 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::VesselSegment< 3 >::GetDistance
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            VesselSegment3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::VesselSegment< 3 >::GetDistance )
                , ( bp::arg("location") ) );
        
        }
        { //::VesselSegment< 3 >::GetFlowProperties
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< SegmentFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::VesselSegment< 3 >::GetFlowProperties ) );
        
        }
        { //::VesselSegment< 3 >::GetLength
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::VesselSegment< 3 >::GetLength ) );
        
        }
        { //::VesselSegment< 3 >::GetMidPoint
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > ( exported_class_t::*GetMidPoint_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetMidPoint"
                , GetMidPoint_function_type( &::VesselSegment< 3 >::GetMidPoint ) );
        
        }
        { //::VesselSegment< 3 >::GetNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) const;
            
            VesselSegment3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::VesselSegment< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::VesselSegment< 3 >::GetNodes
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::pair< boost::shared_ptr< VesselNode< 3 > >, boost::shared_ptr< VesselNode< 3 > > > ( exported_class_t::*GetNodes_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::VesselSegment< 3 >::GetNodes ) );
        
        }
        { //::VesselSegment< 3 >::GetOppositeNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetOppositeNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "GetOppositeNode"
                , GetOppositeNode_function_type( &::VesselSegment< 3 >::GetOppositeNode )
                , ( bp::arg("pInputNode") ) );
        
        }
        { //::VesselSegment< 3 >::GetOutputData
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( VesselSegment_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::VesselSegment< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::VesselSegment< 3 >::GetPointProjection
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::DimensionalChastePoint< 3 > ( exported_class_t::*GetPointProjection_function_type)( ::DimensionalChastePoint< 3 > const &,bool ) const;
            
            VesselSegment3_exposer.def( 
                "GetPointProjection"
                , GetPointProjection_function_type( &::VesselSegment< 3 >::GetPointProjection )
                , ( bp::arg("location"), bp::arg("projectToEnds")=(bool)(false) ) );
        
        }
        { //::VesselSegment< 3 >::GetUnitTangent
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetUnitTangent_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetUnitTangent"
                , GetUnitTangent_function_type( &::VesselSegment< 3 >::GetUnitTangent ) );
        
        }
        { //::VesselSegment< 3 >::GetVessel
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( exported_class_t::*GetVessel_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetVessel"
                , GetVessel_function_type( &::VesselSegment< 3 >::GetVessel ) );
        
        }
        { //::VesselSegment< 3 >::HasNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasNode_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "HasNode"
                , HasNode_function_type( &::VesselSegment< 3 >::HasNode )
                , ( bp::arg("pNode") ) );
        
        }
        { //::VesselSegment< 3 >::IsConnectedTo
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) const;
            
            VesselSegment3_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::VesselSegment< 3 >::IsConnectedTo )
                , ( bp::arg("pOtherSegment") ) );
        
        }
        { //::VesselSegment< 3 >::Remove
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "Remove"
                , Remove_function_type( &::VesselSegment< 3 >::Remove ) );
        
        }
        { //::VesselSegment< 3 >::ReplaceNode
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*ReplaceNode_function_type)( unsigned int,::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            VesselSegment3_exposer.def( 
                "ReplaceNode"
                , ReplaceNode_function_type( &::VesselSegment< 3 >::ReplaceNode )
                , ( bp::arg("oldNodeIndex"), bp::arg("pNewNode") ) );
        
        }
        { //::VesselSegment< 3 >::SetFlowProperties
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::SegmentFlowProperties< 3 > const & ) ;
            
            VesselSegment3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::VesselSegment< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( VesselSegment_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&VesselSegment_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( VesselSegment_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( VesselSegment_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            VesselSegment3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&VesselSegment_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetRadius
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( VesselSegment_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            VesselSegment3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::GetRadius)
                , default_GetRadius_function_type(&VesselSegment_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            VesselSegment3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&VesselSegment_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            VesselSegment3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&VesselSegment_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetRadius
        
            typedef VesselSegment< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( VesselSegment_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            VesselSegment3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::AbstractVesselNetworkComponent< 3 >::SetRadius)
                , default_SetRadius_function_type(&VesselSegment_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        VesselSegment3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< VesselSegment<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< VesselSegment< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< VesselSegment< 3 > > > >();
        VesselSegment3_exposer.def("__init__", bp::make_constructor(VS3_Nodes));
        VesselSegment3_exposer.def("__init__", bp::make_constructor(VS3_Copy));
    }
}
