// This file has been generated by Py++.


/*

Copyright (c) 2005-2017, University of Oxford.
All rights reserved.

University of Oxford means the Chancellor, Masters and Scholars of the
University of Oxford, having an administrative office at Wellington
Square, Oxford OX1 2JD, UK.

This file is part of Chaste.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 * Neither the name of the University of Oxford nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include "boost/python.hpp"
#include "wrapper_header_collection.hpp"
#include "Vessel3.pypp.hpp"

namespace bp = boost::python;

struct Vessel_less__3__greater__wrapper : Vessel< 3 >, bp::wrapper< Vessel< 3 > > {

    virtual ::std::map< std::string, double > GetOutputData(  ) {
        if( bp::override func_GetOutputData = this->get_override( "GetOutputData" ) )
            return func_GetOutputData(  );
        else{
            return this->Vessel< 3 >::GetOutputData(  );
        }
    }
    
    ::std::map< std::string, double > default_GetOutputData(  ) {
        return Vessel< 3 >::GetOutputData( );
    }

    virtual ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > GetRadius(  ) const  {
        if( bp::override func_GetRadius = this->get_override( "GetRadius" ) )
            return func_GetRadius(  );
        else{
            return this->Vessel< 3 >::GetRadius(  );
        }
    }
    
    ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > default_GetRadius(  ) const  {
        return Vessel< 3 >::GetRadius( );
    }

    virtual void SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        if( bp::override func_SetRadius = this->get_override( "SetRadius" ) )
            func_SetRadius( radius );
        else{
            this->Vessel< 3 >::SetRadius( radius );
        }
    }
    
    void default_SetRadius( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > radius ) {
        Vessel< 3 >::SetRadius( radius );
    }

    virtual unsigned int GetId(  ) const  {
        if( bp::override func_GetId = this->get_override( "GetId" ) )
            return func_GetId(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetId(  );
        }
    }
    
    unsigned int default_GetId(  ) const  {
        return AbstractVesselNetworkComponent< 3 >::GetId( );
    }

    virtual ::std::vector< std::string > GetOutputDataKeys(  ) {
        if( bp::override func_GetOutputDataKeys = this->get_override( "GetOutputDataKeys" ) )
            return func_GetOutputDataKeys(  );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys(  );
        }
    }
    
    ::std::vector< std::string > default_GetOutputDataKeys(  ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys( );
    }

    virtual double GetOutputDataValue( ::std::string const & rKey ) {
        if( bp::override func_GetOutputDataValue = this->get_override( "GetOutputDataValue" ) )
            return func_GetOutputDataValue( rKey );
        else{
            return this->AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
        }
    }
    
    double default_GetOutputDataValue( ::std::string const & rKey ) {
        return AbstractVesselNetworkComponent< 3 >::GetOutputDataValue( rKey );
    }

    virtual void SetId( unsigned int id ) {
        if( bp::override func_SetId = this->get_override( "SetId" ) )
            func_SetId( id );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetId( id );
        }
    }
    
    void default_SetId( unsigned int id ) {
        AbstractVesselNetworkComponent< 3 >::SetId( id );
    }

    virtual void SetOutputData( ::std::string const & rKey, double value ) {
        if( bp::override func_SetOutputData = this->get_override( "SetOutputData" ) )
            func_SetOutputData( rKey, value );
        else{
            this->AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
        }
    }
    
    void default_SetOutputData( ::std::string const & rKey, double value ) {
        AbstractVesselNetworkComponent< 3 >::SetOutputData( rKey, value );
    }

};

boost::shared_ptr<Vessel<3> > (*V3_SingleSegment)(boost::shared_ptr<VesselSegment<3> >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_MultiSegment)(std::vector<boost::shared_ptr<VesselSegment<3> > >) = &Vessel<3>::Create;

boost::shared_ptr<Vessel<3> > (*V3_Nodes)(std::vector<boost::shared_ptr<VesselNode<3> > >) = &Vessel<3>::Create;

void register_Vessel3_class(){

    { //::Vessel< 3 >
        typedef bp::class_< Vessel_less__3__greater__wrapper, bp::bases< AbstractVesselNetworkComponent< 3 > >, boost::noncopyable > Vessel3_exposer_t;
        Vessel3_exposer_t Vessel3_exposer = Vessel3_exposer_t( "Vessel3", bp::no_init );
        bp::scope Vessel3_scope( Vessel3_exposer );
        { //::Vessel< 3 >::AddSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegment_function_type)( ::boost::shared_ptr< VesselSegment< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegment"
                , AddSegment_function_type( &::Vessel< 3 >::AddSegment )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::AddSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddSegments_function_type)( ::std::vector< boost::shared_ptr<VesselSegment<3> > > ) ;
            
            Vessel3_exposer.def( 
                "AddSegments"
                , AddSegments_function_type( &::Vessel< 3 >::AddSegments )
                , ( bp::arg("pSegments") ) );
        
        }
        { //::Vessel< 3 >::CopyDataFromExistingVessel
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*CopyDataFromExistingVessel_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "CopyDataFromExistingVessel"
                , CopyDataFromExistingVessel_function_type( &::Vessel< 3 >::CopyDataFromExistingVessel )
                , ( bp::arg("pTargetVessel") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselSegment< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pSegment") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselSegment<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("segments") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::std::vector< boost::shared_ptr<VesselNode<3> > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("nodes") ) );
        
        }
        { //::Vessel< 3 >::Create
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< Vessel< 3 > > ( *Create_function_type )( ::boost::shared_ptr< VesselNode< 3 > >,::boost::shared_ptr< VesselNode< 3 > > );
            
            Vessel3_exposer.def( 
                "Create"
                , Create_function_type( &::Vessel< 3 >::Create )
                , ( bp::arg("pStartNode"), bp::arg("pEndNode") ) );
        
        }
        { //::Vessel< 3 >::DivideSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*DivideSegment_function_type)( ::DimensionalChastePoint< 3 > const &,double ) ;
            
            Vessel3_exposer.def( 
                "DivideSegment"
                , DivideSegment_function_type( &::Vessel< 3 >::DivideSegment )
                , ( bp::arg("rLocation"), bp::arg("distanceTolerance")=9.9999999999999995E-7 ) );
        
        }
        { //::Vessel< 3 >::GetClosestEndNodeDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetClosestEndNodeDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "GetClosestEndNodeDistance"
                , GetClosestEndNodeDistance_function_type( &::Vessel< 3 >::GetClosestEndNodeDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetConnectedVessels
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<Vessel<3> > > ( exported_class_t::*GetConnectedVessels_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetConnectedVessels"
                , GetConnectedVessels_function_type( &::Vessel< 3 >::GetConnectedVessels ) );
        
        }
        { //::Vessel< 3 >::GetDistance
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetDistance_function_type)( ::DimensionalChastePoint< 3 > const & ) const;
            
            Vessel3_exposer.def( 
                "GetDistance"
                , GetDistance_function_type( &::Vessel< 3 >::GetDistance )
                , ( bp::arg("rLocation") ) );
        
        }
        { //::Vessel< 3 >::GetEndNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetEndNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetEndNode"
                , GetEndNode_function_type( &::Vessel< 3 >::GetEndNode ) );
        
        }
        { //::Vessel< 3 >::GetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselFlowProperties< 3 > > ( exported_class_t::*GetFlowProperties_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetFlowProperties"
                , GetFlowProperties_function_type( &::Vessel< 3 >::GetFlowProperties ) );
        
        }
        { //::Vessel< 3 >::GetGlobalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetGlobalIndex_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetGlobalIndex"
                , GetGlobalIndex_function_type( &::Vessel< 3 >::GetGlobalIndex ) );
        
        }
        { //::Vessel< 3 >::GetLength
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetLength_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetLength"
                , GetLength_function_type( &::Vessel< 3 >::GetLength ) );
        
        }
        { //::Vessel< 3 >::GetLocalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetLocalIndex_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetLocalIndex"
                , GetLocalIndex_function_type( &::Vessel< 3 >::GetLocalIndex ) );
        
        }
        { //::Vessel< 3 >::GetMaturity
        
            typedef Vessel< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetMaturity_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetMaturity"
                , GetMaturity_function_type( &::Vessel< 3 >::GetMaturity ) );
        
        }
        { //::Vessel< 3 >::GetNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNode_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetNode"
                , GetNode_function_type( &::Vessel< 3 >::GetNode )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetNodeAtOppositeEnd
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetNodeAtOppositeEnd_function_type)( ::boost::shared_ptr< VesselNode< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "GetNodeAtOppositeEnd"
                , GetNodeAtOppositeEnd_function_type( &::Vessel< 3 >::GetNodeAtOppositeEnd )
                , ( bp::arg("pQueryNode") ) );
        
        }
        { //::Vessel< 3 >::GetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > ( exported_class_t::*GetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNodes"
                , GetNodes_function_type( &::Vessel< 3 >::GetNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfNodes"
                , GetNumberOfNodes_function_type( &::Vessel< 3 >::GetNumberOfNodes ) );
        
        }
        { //::Vessel< 3 >::GetNumberOfSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumberOfSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetNumberOfSegments"
                , GetNumberOfSegments_function_type( &::Vessel< 3 >::GetNumberOfSegments ) );
        
        }
        { //::Vessel< 3 >::GetOtherProcessorLocalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetOtherProcessorLocalIndex_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOtherProcessorLocalIndex"
                , GetOtherProcessorLocalIndex_function_type( &::Vessel< 3 >::GetOtherProcessorLocalIndex ) );
        
        }
        { //::Vessel< 3 >::GetOtherProcessorRank
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetOtherProcessorRank_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOtherProcessorRank"
                , GetOtherProcessorRank_function_type( &::Vessel< 3 >::GetOtherProcessorRank ) );
        
        }
        { //::Vessel< 3 >::GetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::map< std::string, double > ( exported_class_t::*GetOutputData_function_type)(  ) ;
            typedef ::std::map< std::string, double > ( Vessel_less__3__greater__wrapper::*default_GetOutputData_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputData"
                , GetOutputData_function_type(&::Vessel< 3 >::GetOutputData)
                , default_GetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputData) );
        
        }
        { //::Vessel< 3 >::GetOwnerRank
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetOwnerRank_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOwnerRank"
                , GetOwnerRank_function_type( &::Vessel< 3 >::GetOwnerRank ) );
        
        }
        { //::Vessel< 3 >::GetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( exported_class_t::*GetRadius_function_type)(  ) const;
            typedef ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ( Vessel_less__3__greater__wrapper::*default_GetRadius_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type(&::Vessel< 3 >::GetRadius)
                , default_GetRadius_function_type(&Vessel_less__3__greater__wrapper::default_GetRadius) );
        
        }
        { //::Vessel< 3 >::GetSegment
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselSegment< 3 > > ( exported_class_t::*GetSegment_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "GetSegment"
                , GetSegment_function_type( &::Vessel< 3 >::GetSegment )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::GetSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselSegment<3> > > ( exported_class_t::*GetSegments_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetSegments"
                , GetSegments_function_type( &::Vessel< 3 >::GetSegments ) );
        
        }
        { //::Vessel< 3 >::GetStartNode
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::boost::shared_ptr< VesselNode< 3 > > ( exported_class_t::*GetStartNode_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetStartNode"
                , GetStartNode_function_type( &::Vessel< 3 >::GetStartNode ) );
        
        }
        { //::Vessel< 3 >::HasHalo
        
            typedef Vessel< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasHalo_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "HasHalo"
                , HasHalo_function_type( &::Vessel< 3 >::HasHalo ) );
        
        }
        { //::Vessel< 3 >::IsConnectedTo
        
            typedef Vessel< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsConnectedTo_function_type)( ::boost::shared_ptr< Vessel< 3 > > ) ;
            
            Vessel3_exposer.def( 
                "IsConnectedTo"
                , IsConnectedTo_function_type( &::Vessel< 3 >::IsConnectedTo )
                , ( bp::arg("pOtherVessel") ) );
        
        }
        { //::Vessel< 3 >::IsHalo
        
            typedef Vessel< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsHalo_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "IsHalo"
                , IsHalo_function_type( &::Vessel< 3 >::IsHalo ) );
        
        }
        { //::Vessel< 3 >::Remove
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*Remove_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "Remove"
                , Remove_function_type( &::Vessel< 3 >::Remove ) );
        
        }
        { //::Vessel< 3 >::RemoveSegments
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveSegments_function_type)( ::SegmentLocation::Value ) ;
            
            Vessel3_exposer.def( 
                "RemoveSegments"
                , RemoveSegments_function_type( &::Vessel< 3 >::RemoveSegments )
                , ( bp::arg("location") ) );
        
        }
        { //::Vessel< 3 >::SetFlowProperties
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetFlowProperties_function_type)( ::VesselFlowProperties< 3 > const & ) ;
            
            Vessel3_exposer.def( 
                "SetFlowProperties"
                , SetFlowProperties_function_type( &::Vessel< 3 >::SetFlowProperties )
                , ( bp::arg("rFlowProperties") ) );
        
        }
        { //::Vessel< 3 >::SetGlobalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetGlobalIndex_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetGlobalIndex"
                , SetGlobalIndex_function_type( &::Vessel< 3 >::SetGlobalIndex )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::SetHasHalo
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetHasHalo_function_type)( bool ) ;
            
            Vessel3_exposer.def( 
                "SetHasHalo"
                , SetHasHalo_function_type( &::Vessel< 3 >::SetHasHalo )
                , ( bp::arg("hasHalo") ) );
        
        }
        { //::Vessel< 3 >::SetIsHalo
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsHalo_function_type)( bool ) ;
            
            Vessel3_exposer.def( 
                "SetIsHalo"
                , SetIsHalo_function_type( &::Vessel< 3 >::SetIsHalo )
                , ( bp::arg("isHalo") ) );
        
        }
        { //::Vessel< 3 >::SetLocalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetLocalIndex_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetLocalIndex"
                , SetLocalIndex_function_type( &::Vessel< 3 >::SetLocalIndex )
                , ( bp::arg("index") ) );
        
        }
        { //::Vessel< 3 >::SetOtherProcessorLocalIndex
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOtherProcessorLocalIndex_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetOtherProcessorLocalIndex"
                , SetOtherProcessorLocalIndex_function_type( &::Vessel< 3 >::SetOtherProcessorLocalIndex )
                , ( bp::arg("otherIndex") ) );
        
        }
        { //::Vessel< 3 >::SetOtherProcessorRank
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOtherProcessorRank_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetOtherProcessorRank"
                , SetOtherProcessorRank_function_type( &::Vessel< 3 >::SetOtherProcessorRank )
                , ( bp::arg("otherRank") ) );
        
        }
        { //::Vessel< 3 >::SetOwnerRank
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOwnerRank_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetOwnerRank"
                , SetOwnerRank_function_type( &::Vessel< 3 >::SetOwnerRank )
                , ( bp::arg("rank") ) );
        
        }
        { //::Vessel< 3 >::SetRadius
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetRadius_function_type)( ::boost::units::quantity< boost::units::unit< boost::units::list< boost::units::dim< boost::units::length_base_dimension, boost::units::static_rational< 1, 1 > >, boost::units::dimensionless_type >, boost::units::homogeneous_system< boost::units::list< boost::units::si::meter_base_unit, boost::units::list< boost::units::scaled_base_unit< boost::units::cgs::gram_base_unit, boost::units::scale< 10, boost::units::static_rational< 3 > > >, boost::units::list< boost::units::si::second_base_unit, boost::units::list< boost::units::si::ampere_base_unit, boost::units::list< boost::units::si::kelvin_base_unit, boost::units::list< boost::units::si::mole_base_unit, boost::units::list< boost::units::si::candela_base_unit, boost::units::list< boost::units::angle::radian_base_unit, boost::units::list< boost::units::angle::steradian_base_unit, boost::units::dimensionless_type > > > > > > > > > >, void >, double > ) ;
            
            Vessel3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type(&::Vessel< 3 >::SetRadius)
                , default_SetRadius_function_type(&Vessel_less__3__greater__wrapper::default_SetRadius)
                , ( bp::arg("radius") ) );
        
        }
        { //::Vessel< 3 >::UpdateNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*UpdateNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "UpdateNodes"
                , UpdateNodes_function_type( &::Vessel< 3 >::UpdateNodes ) );
        
        }
        { //::Vessel< 3 >::rGetNodes
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< boost::shared_ptr<VesselNode<3> > > const & ( exported_class_t::*rGetNodes_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "rGetNodes"
                , rGetNodes_function_type( &::Vessel< 3 >::rGetNodes )
                , bp::return_internal_reference< >() );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetId_function_type)(  ) const;
            typedef unsigned int ( Vessel_less__3__greater__wrapper::*default_GetId_function_type)(  ) const;
            
            Vessel3_exposer.def( 
                "GetId"
                , GetId_function_type(&::AbstractVesselNetworkComponent< 3 >::GetId)
                , default_GetId_function_type(&Vessel_less__3__greater__wrapper::default_GetId) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys
        
            typedef Vessel< 3 > exported_class_t;
            typedef ::std::vector< std::string > ( exported_class_t::*GetOutputDataKeys_function_type)(  ) ;
            typedef ::std::vector< std::string > ( Vessel_less__3__greater__wrapper::*default_GetOutputDataKeys_function_type)(  ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataKeys"
                , GetOutputDataKeys_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataKeys)
                , default_GetOutputDataKeys_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataKeys) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue
        
            typedef Vessel< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetOutputDataValue_function_type)( ::std::string const & ) ;
            typedef double ( Vessel_less__3__greater__wrapper::*default_GetOutputDataValue_function_type)( ::std::string const & ) ;
            
            Vessel3_exposer.def( 
                "GetOutputDataValue"
                , GetOutputDataValue_function_type(&::AbstractVesselNetworkComponent< 3 >::GetOutputDataValue)
                , default_GetOutputDataValue_function_type(&Vessel_less__3__greater__wrapper::default_GetOutputDataValue)
                , ( bp::arg("rKey") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetId
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetId_function_type)( unsigned int ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetId_function_type)( unsigned int ) ;
            
            Vessel3_exposer.def( 
                "SetId"
                , SetId_function_type(&::AbstractVesselNetworkComponent< 3 >::SetId)
                , default_SetId_function_type(&Vessel_less__3__greater__wrapper::default_SetId)
                , ( bp::arg("id") ) );
        
        }
        { //::AbstractVesselNetworkComponent< 3 >::SetOutputData
        
            typedef Vessel< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetOutputData_function_type)( ::std::string const &,double ) ;
            typedef void ( Vessel_less__3__greater__wrapper::*default_SetOutputData_function_type)( ::std::string const &,double ) ;
            
            Vessel3_exposer.def( 
                "SetOutputData"
                , SetOutputData_function_type(&::AbstractVesselNetworkComponent< 3 >::SetOutputData)
                , default_SetOutputData_function_type(&Vessel_less__3__greater__wrapper::default_SetOutputData)
                , ( bp::arg("rKey"), bp::arg("value") ) );
        
        }
        Vessel3_exposer.staticmethod( "Create" );
        bp::register_ptr_to_python< boost::shared_ptr< Vessel<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< AbstractVesselNetworkComponent< 3 > > >();
        bp::implicitly_convertible< boost::shared_ptr< Vessel< 3 > >, boost::shared_ptr< boost::enable_shared_from_this< Vessel< 3 > > > >();
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_SingleSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_MultiSegment));
        Vessel3_exposer.def("__init__", bp::make_constructor(V3_Nodes));
    }

}
