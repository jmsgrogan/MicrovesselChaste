<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.scala-lang.org/</id>
  <title type="text" xml:lang="en">Microvessel Chaste :: News</title>
  <link type="application/atom+xml" href="http://www.scala-lang.org/feed/index.xml" rel="self"/>
  <link type="text/html" href="http://www.scala-lang.org/news/" rel="alternate"/>

  <updated>2016-12-06T18:36:11+00:00</updated>
  <author>
    <name>École Polytechnique Fédérale de Lausanne</name>
  </author>
  <rights>Copyright (c) 2002-2016 École Polytechnique Fédérale de Lausanne (EPFL), Lausanne, Switzerland</rights>

  
  <entry>
    <title>Scala 2.12.0 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0"/>
    <updated>2016-11-03T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0</id>
    <content type="html">&lt;p&gt;We are very happy to announce the availability of Scala 2.12.0!&lt;/p&gt;

&lt;h2&gt;Headline features&lt;/h2&gt;

&lt;p&gt;The Scala 2.12 compiler has been completely overhauled to make use of the new VM features available in Java 8:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A trait &lt;a href=&quot;#traits-compile-to-interfaces&quot;&gt;compiles directly to an interface&lt;/a&gt; with default methods. This improves binary compatibility and Java interoperability.&lt;/li&gt;
&lt;li&gt;Scala and Java 8 interop is also improved for functional code, as methods that take functions can easily be called in both directions using lambda syntax. The  &lt;code&gt;FunctionN&lt;/code&gt; classes in Scala&amp;#39;s standard library are now Single Abstract Method (SAM) types, and all &lt;a href=&quot;#lambda-syntax-for-sam-types&quot;&gt;SAM types&lt;/a&gt; are treated uniformly -- from type checking through code generation. No class file is generated for a lambda; &lt;code&gt;invokedynamic&lt;/code&gt; is used instead.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This release ships with a powerful &lt;a href=&quot;#new-optimizer&quot;&gt;new optimizer&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining: many more (effectively) final methods, including those defined in objects and traits, are now inlined.&lt;/li&gt;
&lt;li&gt;Closure allocations, dead code, and box/unbox pairs are eliminated more often.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For additional features, read on.&lt;/p&gt;

&lt;h2&gt;Compatibility&lt;/h2&gt;

&lt;p&gt;Although Scala 2.11 and 2.12 are mostly source compatible to facilitate cross-building, they are not &lt;em&gt;binary&lt;/em&gt; compatible.  This allows us to keep improving the Scala compiler and standard library.&lt;/p&gt;

&lt;p&gt;All 2.12.x releases will be fully binary compatible with 2.12.0, in according with &lt;a href=&quot;http://docs.scala-lang.org/overviews/core/binary-compatibility-of-scala-releases.html&quot;&gt;the policy&lt;/a&gt; we have followed since 2.10.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of open-source libraries&lt;/a&gt; released for Scala 2.12 is growing quickly!&lt;/p&gt;

&lt;p&gt;This release is identical to 2.12.0-RC2.&lt;/p&gt;

&lt;h2&gt;Coming soon&lt;/h2&gt;

&lt;p&gt;Our &lt;a href=&quot;https://github.com/scala/scala/milestones&quot;&gt;roadmap&lt;/a&gt; lists the following upcoming releases for 2016:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2.12.1 will be out shortly (by the end of November) to address some known (but rare) issues in 2.12.0.&lt;/li&gt;
&lt;li&gt;2.11.9 will be the last planned 2.11.x release (due by mid December)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next few weeks, we at Lightbend will share our plans for Scala 2.13.&lt;/p&gt;

&lt;h2&gt;Known issues&lt;/h2&gt;

&lt;p&gt;There are some &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-10009?jql=project%20%3D%20SI%20AND%20affectedVersion%20%3D%20%22Scala%202.12.0%22&quot;&gt;known issues&lt;/a&gt; with this release that &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+milestone%3A2.12.1+label%3Arelease-notes&quot;&gt;will be resolved&lt;/a&gt; in 2.12.1, due later in November.&lt;/p&gt;

&lt;p&gt;The heavy use of default methods for compiling traits caused some performance regressions in the startup time of Scala applications. Note that steady-state performance is not affected according to our measurements.&lt;/p&gt;

&lt;p&gt;The regression was mitigated 2.12.0-RC2 (and the final release) by generating forwarder methods in classes that inherit concrete methods from traits, which unfortunately &lt;a href=&quot;https://github.com/scala/scala/pull/5429&quot;&gt;increases bytecode size&lt;/a&gt; while improving JVM startup performance.&lt;/p&gt;

&lt;p&gt;Please let us know if you notice any performance regressions. We will continue to tweak the bytecode during the 2.12.x cycle to get the best performance out of the JVM.&lt;/p&gt;

&lt;p&gt;We hope to address the following in a later 2.12.x release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9824&quot;&gt;SI-9824&lt;/a&gt;: Parallel collections are prone to deadlock in the REPL and in object initializers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;h3&gt;Java 8 runtime&lt;/h3&gt;

&lt;p&gt;Install a recent build of the Java 8 Platform, such as &lt;a href=&quot;http://openjdk.java.net/install/&quot;&gt;OpenJDK&lt;/a&gt; or &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle Java&lt;/a&gt;. Any Java 8 compliant runtime will do.&lt;/p&gt;

&lt;p&gt;We are planning to add (some) support for Java 9 in the near future. Full Java 9 support will be part of the 2.13 roadmap discussions.&lt;/p&gt;

&lt;h3&gt;Build tool&lt;/h3&gt;

&lt;p&gt;We recommend using &lt;a href=&quot;http://www.scala-sbt.org/download.html&quot;&gt;sbt 0.13.13&lt;/a&gt;. Simply bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your existing project, or start a new project using &lt;code&gt;sbt new scala/scala-seed.g8&lt;/code&gt;. We strongly recommend upgrading to sbt 0.13.13 for &lt;a href=&quot;https://github.com/sbt/sbt/pull/2705&quot;&gt;templating support using the new command&lt;/a&gt;, &lt;a href=&quot;https://github.com/sbt/sbt/pull/2754&quot;&gt;faster compilation&lt;/a&gt;, and &lt;a href=&quot;http://www.scala-sbt.org/0.13/docs/sbt-0.13-Tech-Previews.html#sbt+0.13.13&quot;&gt;much more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please head over to the &lt;a href=&quot;https://github.com/scala/scala-seed.g8&quot;&gt;scala-seed repo&lt;/a&gt; to extend this &lt;a href=&quot;https://github.com/foundweekends/giter8&quot;&gt;giter8 template&lt;/a&gt; with an example of your favorite 2.12 feature!&lt;/p&gt;

&lt;p&gt;Scala also works with &lt;a href=&quot;http://docs.scala-lang.org/tutorials/scala-with-maven.html&quot;&gt;Maven&lt;/a&gt;, &lt;a href=&quot;https://docs.gradle.org/current/userguide/scala_plugin.html&quot;&gt;Gradle&lt;/a&gt;, and Ant.&lt;/p&gt;

&lt;p&gt;You can also download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0.html&quot;&gt;scala-lang.org&lt;/a&gt;, or obtain the JARs yourself from &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0%22&quot;&gt;Maven Central&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, kindly helping others on forums and at meetups, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;Scala 2.12.0 is the result of merging over &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Amerged%20label%3A2.12%20&quot;&gt;500 pull requests&lt;/a&gt; out of about &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr%20label%3A2.12%20&quot;&gt;600 received PRs&lt;/a&gt;. The &lt;a href=&quot;https://github.com/scala/scala/graphs/contributors?from=2014-11-01&amp;amp;to=2016-10-29&amp;amp;type=c&quot;&gt;contributions to 2.12.x&lt;/a&gt; over the last 2 years &lt;a href=&quot;https://docs.google.com/spreadsheets/d/16zVViCpJEZn_x2RlYFh-xAOiHJG3SrYYpfetRr5cu_Y/edit#gid=912693440&quot;&gt;were split&lt;/a&gt; 64/32/4 between the Scala team at Lightbend (&lt;a href=&quot;https://github.com/lrytz&quot;&gt;lrytz&lt;/a&gt;, &lt;a href=&quot;https://github.com/retronym&quot;&gt;retronym&lt;/a&gt;, &lt;a href=&quot;https://github.com/adriaanm&quot;&gt;adriaanm&lt;/a&gt;, &lt;a href=&quot;https://github.com/SethTisue&quot;&gt;SethTisue&lt;/a&gt;, &lt;a href=&quot;https://github.com/szeiger&quot;&gt;szeiger&lt;/a&gt;), the community, and EPFL.&lt;/p&gt;

&lt;p&gt;The new encodings of traits, lambdas, and lazy vals were developed in fruitful collaboration with the Dotty team at EPFL.&lt;/p&gt;

&lt;p&gt;The new compiler back end and the new optimizer are based on earlier work by Miguel Garcia at EPFL.&lt;/p&gt;

&lt;h2&gt;Scala 2.12 overview&lt;/h2&gt;

&lt;p&gt;Scala 2.12 is all about making optimal use of Java 8&amp;#39;s new features. Thus, it generates code that requires a Java 8 runtime.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Traits (&lt;a href=&quot;https://github.com/scala/scala/pull/5003&quot;&gt;#5003&lt;/a&gt;) and functions are compiled to their Java 8 equivalents. The compiler no longer generates trait implementation classes (&lt;code&gt;T$class.class&lt;/code&gt;) and anonymous function classes (&lt;code&gt;C$$anonfun$1.class&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;We treat Single Abstract Method types and Scala&amp;#39;s built-in function types uniformly from type checking to the back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;We use &lt;code&gt;invokedynamic&lt;/code&gt; for compiling functions. It also now provides a more natural encoding of other language features (&lt;a href=&quot;https://github.com/scala/scala/pull/4896&quot;&gt;#4896&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;We&amp;#39;ve standardized on the GenBCode back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;) and the flat classpath implementation is now the default (&lt;a href=&quot;https://github.com/scala/scala/pull/5057&quot;&gt;#5057&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;The optimizer has been completely overhauled for 2.12.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The new encodings for traits and lambdas lead to significantly smaller JAR files. For example, for ScalaTest 3.0.0, the jar size dropped from 9.9M to 6.7M.&lt;/p&gt;

&lt;p&gt;Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x, unless you use experimental APIs such as reflection.  If you find incompatibilities that are not &lt;a href=&quot;#breaking-changes&quot;&gt;listed below&lt;/a&gt;, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to source compatibility, cross-building is a one-line change to most sbt builds. Where needed, sbt provides support for &lt;a href=&quot;http://www.scala-sbt.org/0.13/docs/sbt-0.13-Tech-Previews.html#Cross-version+support+for+Scala+sources&quot;&gt;version-specific source folders&lt;/a&gt; out of the box.&lt;/p&gt;

&lt;h3&gt;New language features&lt;/h3&gt;

&lt;p&gt;The next sections introduce new features and breaking changes in Scala 2.12 in more detail. To understand more technicalities and review past discussions, you can also take a look at the full list of &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=%20is%3Amerged%20label%3A2.12%20label%3Arelease-notes%20&quot;&gt;noteworthy pull request&lt;/a&gt; that went into this release.&lt;/p&gt;

&lt;h4&gt;Traits compile to interfaces&lt;/h4&gt;

&lt;p&gt;Because Java 8 allows concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface classfile. Before, a trait was represented as an interface and a class that held the method implementations (&lt;code&gt;T$class.class&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Additional magic is still involved, so care must be taken if a trait is meant to be implemented in Java. Briefly, if a trait does any of the following, its subclasses require synthetic code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;defining fields (&lt;code&gt;val&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;, but a constant is ok -- &lt;code&gt;final val&lt;/code&gt; without result type)&lt;/li&gt;
&lt;li&gt;calling super&lt;/li&gt;
&lt;li&gt;initializer statements in the body&lt;/li&gt;
&lt;li&gt;extending a class&lt;/li&gt;
&lt;li&gt;relying on linearization to find implementations in the right supertrait&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Lambda syntax for SAM types&lt;/h4&gt;

&lt;p&gt;The Scala 2.12 type checker accepts a function literal as a valid expression for any Single Abstract Method (SAM) type, in addition to the &lt;code&gt;FunctionN&lt;/code&gt; types from standard library. This improves the experience of using libraries written for Java 8 from Scala code. Here is a REPL example using &lt;code&gt;java.lang.Runnable&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scala&amp;gt; val r: Runnable = () =&amp;gt; println(&quot;Run!&quot;)
r: Runnable = $$Lambda$1073/754978432@7cf283e1

scala&amp;gt; r.run()
Run!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that only lambda expressions are converted to SAM type instances, not arbitrary expressions of &lt;code&gt;FunctionN&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scala&amp;gt; val f = () =&amp;gt; println(&quot;Faster!&quot;)

scala&amp;gt; val fasterRunnable: Runnable = f
&amp;lt;console&amp;gt;:12: error: type mismatch;
 found   : () =&amp;gt; Unit
 required: Runnable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The language specification has the &lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#sam-conversion&quot;&gt;full list of requirements for SAM conversion&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With the use of default methods, Scala&amp;#39;s built-in &lt;code&gt;FunctionN&lt;/code&gt; traits are compiled to SAM interfaces. This allows creating Scala functions from Java using Java&amp;#39;s own lambda syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;public class A {
  scala.Function1&amp;lt;String, String&amp;gt; f = s -&amp;gt; s.trim();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Specialized function classes are also SAM interfaces and can be found in the package &lt;code&gt;scala.runtime.java8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to an improvement in type checking, the parameter type in a lambda expression can be omitted even when the invoked method is overloaded.  See &lt;a href=&quot;https://github.com/scala/scala/pull/5307&quot;&gt;#5307&lt;/a&gt; for details. In the following example, the compiler infers parameter type &lt;code&gt;Int&lt;/code&gt; for the lambda:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scala&amp;gt; trait MyFun { def apply(x: Int): String }

scala&amp;gt; object T {
     |   def m(f: Int =&amp;gt; String) = 0
     |   def m(f: MyFun) = 1
     | }

scala&amp;gt; T.m(x =&amp;gt; x.toString)
res0: Int = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that though both methods are applicable, overloading resolution selects the one with the &lt;code&gt;Function1&lt;/code&gt; argument type, as &lt;a href=&quot;#sam-conversion-in-overloading-resolution&quot;&gt;explained in more detail below&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Java 8-style bytecode for lambdas&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits bytecode for functions in the same style as Java 8, whether they target a &lt;code&gt;FunctionN&lt;/code&gt; class from the standard library or a user-defined Single Abstract Method (SAM) type.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body, and emits an &lt;code&gt;invokedynamic&lt;/code&gt; that will spin up a lightweight class for this closure using the JDK&amp;#39;s &lt;code&gt;LambdaMetaFactory&lt;/code&gt;. Note that in the following situations, an anonymous function class is still synthesized at compile time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the SAM type is not a simple interface, for example an abstract class or a trait with a field definition (see &lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;If the abstract method is specialized -- except for &lt;code&gt;scala.FunctionN&lt;/code&gt;, whose specialized variants can be instantiated using &lt;code&gt;LambdaMetaFactory&lt;/code&gt; (see &lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;If the function literal is defined in a constructor or super call (&lt;a href=&quot;https://github.com/scala/scala/pull/3616&quot;&gt;#3616&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure.&lt;/p&gt;

&lt;p&gt;Our backend support for &lt;code&gt;invokedynamic&lt;/code&gt; is also available to macro authors, as shown in &lt;a href=&quot;https://github.com/scala/scala/blob/v2.12.0/test/files/run/indy-via-macro-with-dynamic-args/macro_1.scala&quot;&gt;this test case&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Partial unification for type constructor inference&lt;/h4&gt;

&lt;p&gt;Compiling with &lt;code&gt;-Ypartial-unification&lt;/code&gt; improves type constructor inference with support for partial unification, fixing the notorious &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-2712&quot;&gt;SI-2712&lt;/a&gt;. Thank you, &lt;a href=&quot;https://github.com/milessabin&quot;&gt;Miles Sabin&lt;/a&gt; for contributing &lt;a href=&quot;https://github.com/scala/scala/pull/5102&quot;&gt;your implementation&lt;/a&gt; (and &lt;a href=&quot;https://github.com/scala/scala/pull/5343&quot;&gt;backporting to 2.11.9&lt;/a&gt;)!&lt;/p&gt;

&lt;p&gt;Also, hat tip to Daniel Spiewak for &lt;a href=&quot;https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2&quot;&gt;a great explanation of this feature&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We recommend enabling this with &lt;code&gt;-Ypartial-unification&lt;/code&gt; rather than &lt;code&gt;-Xexperimental&lt;/code&gt;, as the latter enables some surprising features that will not ship with a future release of Scala.&lt;/p&gt;

&lt;h4&gt;New representation and locking scope for local lazy vals&lt;/h4&gt;

&lt;p&gt;Local lazy vals and objects, i.e., those defined in methods, now use a more efficient representation (implemented in &lt;a href=&quot;https://github.com/scala/scala/pull/5294&quot;&gt;#5294&lt;/a&gt; and &lt;a href=&quot;https://github.com/scala/scala/pull/5374&quot;&gt;#5374&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In Scala 2.11, a local lazy val was encoded using two heap-allocated objects (one for the value, a second for the initialized flag). Initialization was synchronized on the enclosing class instance.&lt;/p&gt;

&lt;p&gt;In 2.12, with the new &lt;a href=&quot;#java-8-style-bytecode-for-lambdas&quot;&gt;representation for lambdas&lt;/a&gt;, which emits the lambda body as a method in the enclosing class, new deadlocks can arise for lazy vals or objects defined in the lambda body.&lt;/p&gt;

&lt;p&gt;This has been fixed by creating a single heap-allocated object that is used for init locking and holds both the value and the initialized flag. (A similar implementation already existed in Dotty.)&lt;/p&gt;

&lt;h4&gt;Better type inference for Scala.js&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&quot;#lambda-syntax-for-sam-types&quot;&gt;improved type inference for lambda parameters&lt;/a&gt; also benefits &lt;code&gt;js.Function&lt;/code&gt;s. For example, you can now write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;dom.window.requestAnimationFrame { now =&amp;gt; // inferred as Double
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;without having to specify &lt;code&gt;(now: Double)&lt;/code&gt; explicitly.&lt;/p&gt;

&lt;p&gt;In a similar spirit, the &lt;a href=&quot;#inferred-types-for-fields&quot;&gt;new inference for overriding &lt;code&gt;val&lt;/code&gt;s&lt;/a&gt; allows to more easily implement Scala.js-defined JS traits with anonymous objects. For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;@ScalaJSDefined
trait SomeOptions extends js.Object {
  val width: Double | String // e.g., &quot;300px&quot;
}
val options = new SomeOptions {
  // implicitly converted from Int to the inferred Double | String
  val width = 200
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Tooling improvements&lt;/h3&gt;

&lt;h4&gt;New back end&lt;/h4&gt;

&lt;p&gt;Scala 2.12 standardizes on the &amp;quot;GenBCode&amp;quot; back end, which emits code more quickly because it directly generates bytecode from Scala compiler trees. (The old back end used an intermediate representation.) The old back ends (GenASM and GenIcode) have been removed (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;).&lt;/p&gt;

&lt;h4&gt;New optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode back end includes a new inliner and bytecode optimizer. The optimizer is configured using the &lt;code&gt;-opt&lt;/code&gt; compiler option. By default it only removes unreachable code within a method. Check &lt;code&gt;-opt:help&lt;/code&gt; to see the list of available options for the optimizer.&lt;/p&gt;

&lt;p&gt;The following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;li&gt;Box/unbox elimination &lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;: primitive boxes and tuples that are created and used within some method without escaping are eliminated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, the following code&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;def f(a: Int, b: Boolean) = (a, b) match {
  case (0, true) =&amp;gt; -1
  case _ if a &amp;lt; 0 =&amp;gt; -a
  case _ =&amp;gt; a
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produces, when compiled with &lt;code&gt;-opt:l:method&lt;/code&gt;, the following bytecode (decompiled using &lt;a href=&quot;http://www.benf.org/other/cfr/&quot;&gt;cfr&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;public int f(int a, boolean b) {
  int n = 0 == a &amp;amp;&amp;amp; true == b ? -1 : (a &amp;lt; 0 ? - a : a);
  return n;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The optimizer supports inlining (disabled by default). With &lt;code&gt;-opt:l:project&lt;/code&gt; code from source files currently being compiled is inlined, while &lt;code&gt;-opt:l:classpath&lt;/code&gt; enables inlining code from libraries on the compiler&amp;#39;s classpath. Other than methods marked &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/inline.html&quot;&gt;&lt;code&gt;@inline&lt;/code&gt;&lt;/a&gt;, higher-order methods are inlined if the function argument is a lambda, or a parameter of the caller.&lt;/p&gt;

&lt;p&gt;Note that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We recommend enabling inlining only in production builds, as sbt&amp;#39;s incremental compilation does not track dependencies introduced by inlining.&lt;/li&gt;
&lt;li&gt;When inlining code from the classpath, you must ensure that all dependencies have exactly the same versions at compile time and run time.&lt;/li&gt;
&lt;li&gt;If you are building a library to publish on Maven Central, you should not inline code from dependencies. Users of your library might have different versions of those dependencies on the classpath, which breaks binary compatibility.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Scala distribution is built using &lt;code&gt;-opt:l:classpath&lt;/code&gt;, which improves the performance of the Scala compiler by roughly 5% (hot and cold, measured using our &lt;a href=&quot;https://github.com/scala/compiler-benchmark/blob/master/compilation/src/main/scala/scala/tools/nsc/ScalacBenchmark.scala&quot;&gt;JMH-based benchmark suite&lt;/a&gt;) compared to a non-optimized build.&lt;/p&gt;

&lt;h4&gt;Scaladoc look-and-feel overhauled&lt;/h4&gt;

&lt;p&gt;Scaladoc&amp;#39;s output is now more attractive, more modern, and easier to use. Take a look at the &lt;a href=&quot;http://www.scala-lang.org/api/2.12.0&quot;&gt;Scala Standard Library API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/felixmulder&quot;&gt;Felix Mulder&lt;/a&gt;, for leading this effort.&lt;/p&gt;

&lt;h4&gt;Scaladoc can be used to document Java sources&lt;/h4&gt;

&lt;p&gt;This fix for &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-4826&quot;&gt;SI-4826&lt;/a&gt; simplifies generating comprehensive documentation for projects with both Scala and Java sources. Thank you for your contribution, &lt;a href=&quot;https://github.com/jodersky&quot;&gt;Jakob Odersky&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;This feature is enabled by default, but can be disabled with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scalacOptions in (Compile, doc) += &quot;-no-java-comments&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some projects with very large Javadoc comments may run into a stack overflow in the Javadoc scanner, which &lt;a href=&quot;https://github.com/scala/scala/pull/5469&quot;&gt;will be fixed in 2.12.1&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Scala shell (&lt;a href=&quot;https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop&quot;&gt;REPL&lt;/a&gt;)&lt;/h4&gt;

&lt;p&gt;Scala&amp;#39;s interactive shell ships with several spiffy improvements. To try it out, launch it from the command line with the &lt;code&gt;scala&lt;/code&gt; script or in sbt using the &lt;code&gt;console&lt;/code&gt; task. If you like color (who doesn&amp;#39;t!), use &lt;code&gt;scala -Dscala.color&lt;/code&gt; instead, until &lt;a href=&quot;https://github.com/scala/scala-dev/issues/256&quot;&gt;it&amp;#39;s turned on by default&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since 2.11.8, the REPL uses the same tab completion logic as ScalaIDE and ENSIME, which greatly improves the experience. Check out &lt;a href=&quot;https://github.com/scala/scala/pull/4725&quot;&gt;PR 4725&lt;/a&gt; for some tips and tricks.&lt;/p&gt;

&lt;h4&gt;sbt builds Scala&lt;/h4&gt;

&lt;p&gt;Scala itself is now completely built, tested and published with sbt!&lt;/p&gt;

&lt;p&gt;This makes it easier to get started hacking on the compiler and standard library. All you need on your machine is JDK 8 and sbt - no ant, no environment variables to set, no shell scripts to run. You can &lt;a href=&quot;https://github.com/scala/scala/blob/2.12.x/README.md#using-the-sbt-build&quot;&gt;build, use, test and publish&lt;/a&gt; Scala like any other sbt-based project.&lt;/p&gt;

&lt;p&gt;Due to Scala&amp;#39;s bootstrapped nature, IntelliJ cannot yet import our sbt build directly. Use the &lt;code&gt;intellij&lt;/code&gt; task instead to generate suitable project files.&lt;/p&gt;

&lt;h3&gt;Library improvements&lt;/h3&gt;

&lt;h4&gt;Either is now right-biased&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Either&lt;/code&gt; now supports operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;toOption&lt;/code&gt;, and so forth, which operate on the right-hand side. The &lt;code&gt;.left&lt;/code&gt; and &lt;code&gt;.right&lt;/code&gt; methods may be deprecated in favor of &lt;code&gt;.swap&lt;/code&gt; in a later release.
The changes are source-compatible with existing code (except in the presence of conflicting extension methods).&lt;/p&gt;

&lt;p&gt;This change has allowed other libraries, such as &lt;a href=&quot;http://typelevel.org/cats/&quot;&gt;cats&lt;/a&gt; to standardize on &lt;code&gt;Either&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/soc&quot;&gt;Simon Ochsenreither&lt;/a&gt;, for this contribution.&lt;/p&gt;

&lt;h4&gt;Futures improved&lt;/h4&gt;

&lt;p&gt;A number of improvements to &lt;code&gt;scala.concurrent.Future&lt;/code&gt; were made for Scala 2.12. This &lt;a href=&quot;https://github.com/viktorklang/blog&quot;&gt;blog post series&lt;/a&gt; by Viktor Klang explores them in detail.&lt;/p&gt;

&lt;h4&gt;scala-java8-compat&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/scala/scala-java8-compat&quot;&gt;Java 8 compatibility module for Scala&lt;/a&gt; has received an overhaul for Scala 2.12. Even though interoperability of Java 8 SAMs and Scala functions is now baked into the language, this module provides additional convenience for working with Java 8 SAMs. Java 8 streams support was also added during the development cycle of Scala 2.12. Releases are available for both Scala 2.11 and Scala 2.12.&lt;/p&gt;

&lt;h3&gt;Other changes and deprecations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For comprehension desugaring requires &lt;code&gt;withFilter&lt;/code&gt; now, never falls back to &lt;code&gt;filter&lt;/code&gt; (&lt;a href=&quot;https://github.com/scala/scala/pull/5252&quot;&gt;#5252&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;A &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/mutable/TreeMap.html&quot;&gt;mutable TreeMap&lt;/a&gt; implementation was added (&lt;a href=&quot;https://github.com/scala/scala/pull/4504&quot;&gt;#4504&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/immutable/ListSet.html&quot;&gt;ListSet&lt;/a&gt; and &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/immutable/ListMap.html&quot;&gt;ListMap&lt;/a&gt; now ensure insertion-order traversal (in 2.11.x, traversal was in reverse order), and their performance has been improved (&lt;a href=&quot;https://github.com/scala/scala/pull/5103&quot;&gt;#5103&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/deprecatedInheritance.html&quot;&gt;&lt;code&gt;@deprecatedInheritance&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/deprecatedOverriding.html&quot;&gt;&lt;code&gt;@deprecatedOverriding&lt;/code&gt;&lt;/a&gt; are now public and available to library authors.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;@hideImplicitConversion&lt;/code&gt; Scaladoc annotation allows customizing which implicit conversions are hidden (&lt;a href=&quot;https://github.com/scala/scala/pull/4952&quot;&gt;#4952&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;@shortDescription&lt;/code&gt; Scaladoc annotation customizes the method summary on entity pages (&lt;a href=&quot;https://github.com/scala/scala/pull/4991&quot;&gt;#4991&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;JavaConversions, providing implicit conversions between Scala and Java collection types, has been deprecated. We recommend using &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/JavaConverters$.html&quot;&gt;JavaConverters&lt;/a&gt; and explicit &lt;code&gt;.asJava&lt;/code&gt; / &lt;code&gt;.asScala&lt;/code&gt; conversions.&lt;/li&gt;
&lt;li&gt;Eta-expansion (conversion of a method to a function value) of zero-args methods has been deprecated, as this can lead to surprising behavior (&lt;a href=&quot;https://github.com/scala/scala/pull/5327&quot;&gt;#5327&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;The Scala library is now &lt;a href=&quot;https://github.com/scala/scala/pull/4443&quot;&gt;free&lt;/a&gt; of &lt;a href=&quot;https://github.com/scala/scala/pull/4712&quot;&gt;references&lt;/a&gt; to &lt;code&gt;sun.misc.Unsafe&lt;/code&gt;, and &lt;a href=&quot;https://github.com/scala/scala/pull/4629&quot;&gt;no longer ships&lt;/a&gt; with a fork of the forkjoin library.&lt;/li&gt;
&lt;li&gt;Exhaustiveness analysis in the pattern matcher has been improved (&lt;a href=&quot;https://github.com/scala/scala/pull/4919&quot;&gt;#4919&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;We emit parameter names according to &lt;a href=&quot;http://openjdk.java.net/jeps/118&quot;&gt;JEP-118&lt;/a&gt;, which makes them available to Java tools and exposes them through Java reflection.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Breaking changes&lt;/h2&gt;

&lt;h3&gt;Object initialization locks and lambdas&lt;/h3&gt;

&lt;p&gt;In Scala 2.11, the body of a lambda was in the &lt;code&gt;apply&lt;/code&gt; method of the anonymous function class generated at compile time. The new lambda encoding in 2.12 lifts the lambda body into a method in the enclosing class. An invocation of the lambda therefore involves the enclosing class, which can cause deadlocks that did not happen before.&lt;/p&gt;

&lt;p&gt;For example, the following code&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;import scala.concurrent._
import scala.concurrent.duration._
import ExecutionContext.Implicits.global
object O { Await.result(Future(1), 5.seconds) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compiles to (simplified):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;public final class O$ {
  public static O$ MODULE$;
  public static final int $anonfun$new$1() { return 1; }
  public static { new O$(); }
  private O$() {
    MODULE$ = this;
    Await.result(Future.apply(LambdaMetaFactory(Function0, $anonfun$new$1)), DurationInt(5).seconds);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Accessing &lt;code&gt;O&lt;/code&gt; for the first time initializes the &lt;code&gt;O$&lt;/code&gt; class and executes the static initializer (which invokes the instance constructor). Class initialization is guarded by an initialization lock (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5&quot;&gt;Chapter 5.5 in the JVM specification&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The main thread locks class initialization and spawns the Future. The Future, executed on a different thread, attempts to execute the static lambda body method &lt;code&gt;$anonfun$new$1&lt;/code&gt;, which also requires initialization of the class &lt;code&gt;O$&lt;/code&gt;. Because initialization is locked by the main thread, the thread running the future will block. In the meantime, the main thread continues to run &lt;code&gt;Await.result&lt;/code&gt;, which will block until the future completes, causing the deadlock.&lt;/p&gt;

&lt;p&gt;One example of this &lt;a href=&quot;https://github.com/rickynils/scalacheck/issues/290&quot;&gt;surprised the authors of ScalaCheck&lt;/a&gt; -- now &lt;a href=&quot;https://github.com/rickynils/scalacheck/pull/294&quot;&gt;fixed&lt;/a&gt; in version 1.13.4.&lt;/p&gt;

&lt;h3&gt;Lambdas capturing outer instances&lt;/h3&gt;

&lt;p&gt;Because lambda bodies are emitted as methods in the enclosing class, a lambda can capture the outer instance in cases where this did not happen in 2.11. This can affect serialization.&lt;/p&gt;

&lt;p&gt;The Scala compiler analyzes classes and methods to prevent unnecessary outer captures: unused outer parameters are removed from classes (&lt;a href=&quot;https://github.com/scala/scala/pull/4652&quot;&gt;#4652&lt;/a&gt;), and methods not accessing any instance members are made static (&lt;a href=&quot;https://github.com/scala/scala/pull/5099&quot;&gt;#5099&lt;/a&gt;). One known limitation is that the analysis is local to a class and does not cover subclasses.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class C {
  def f = () =&amp;gt; {
    class A extends Serializable
    class B extends A
    serialize(new A)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, the classes &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are first lifted into &lt;code&gt;C&lt;/code&gt;. When flattening the classes to the package level, the &lt;code&gt;A&lt;/code&gt; obtains an outer pointer to capture the &lt;code&gt;A&lt;/code&gt; instance. Because &lt;code&gt;A&lt;/code&gt; has a subclass &lt;code&gt;B&lt;/code&gt;, the class-level analysis of &lt;code&gt;A&lt;/code&gt; cannot conclude that the outer parameter is unused (it might be used in &lt;code&gt;B&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Serializing the &lt;code&gt;A&lt;/code&gt; instance attempts to serialize the outer field, which causes a &lt;code&gt;NotSerializableException: C&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;SAM conversion precedes implicits&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#sam-conversion&quot;&gt;SAM conversion&lt;/a&gt; built into the type system takes priority over implicit conversion of function types to SAM types. This can change the semantics of existing code relying on implicit conversion to SAM types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;trait MySam { def i(): Int }
implicit def convert(fun: () =&amp;gt; Int): MySam = new MySam { def i() = 1 }
val sam1: MySam = () =&amp;gt; 2 // Uses SAM conversion, not the implicit
sam1.i()                  // Returns 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To retain the old behavior, your choices are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;compile under &lt;code&gt;-Xsource:2.11&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use an explicit call to the conversion method&lt;/li&gt;
&lt;li&gt;disqualify the type from being a SAM (e.g. by adding a second abstract method).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that SAM conversion only applies to lambda expressions, not to arbitrary expressions with Scala &lt;code&gt;FunctionN&lt;/code&gt; types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;val fun = () =&amp;gt; 2     // Type Function0[Int]
val sam2: MySam = fun // Uses implicit conversion
sam2.i()              // Returns 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SAM conversion in overloading resolution&lt;/h3&gt;

&lt;p&gt;In order to improve source compatibility, overloading resolution has been adapted to prefer methods with &lt;code&gt;Function&lt;/code&gt;-typed arguments over methods with parameters of SAM types. The following example is identical in Scala 2.11 and 2.12:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scala&amp;gt; object T {
     |   def m(f: () =&amp;gt; Unit) = 0
     |   def m(r: Runnable) = 1
     | }

scala&amp;gt; val f = () =&amp;gt; ()

scala&amp;gt; T.m(f)
res0: Int = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Scala 2.11, the first alternative was chosen because it is the only applicable method. In Scala 2.12, both methods are applicable, therefore &lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#overloading-resolution&quot;&gt;overloading resolution&lt;/a&gt; needs to pick the most specific alternative. The specification for &lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#compatibility&quot;&gt;type compatibility&lt;/a&gt; has been updated to consider SAM conversion, so that the first alternative is more specific.&lt;/p&gt;

&lt;p&gt;Note that SAM conversion in overloading resolution is always considered, also if the argument expression is not a function literal (like in the example). This is unlike SAM conversions of expressions themselves; see the previous section. See also the discussion in &lt;a href=&quot;https://github.com/scala/scala-dev/issues/158&quot;&gt;scala-dev#158&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While the adjustment to overloading resolution improves compatibility overall, code does exist that compiles in 2.11 but is ambiguous in 2.12, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;scala&amp;gt; object T {
     |   def m(f: () =&amp;gt; Unit, o: Object) = 0
     |   def m(r: Runnable, s: String) = 1
     | }
defined object T

scala&amp;gt; T.m(() =&amp;gt; (), &quot;&quot;)
&amp;lt;console&amp;gt;:13: error: ambiguous reference to overloaded definition
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Inferred types for fields&lt;/h3&gt;

&lt;p&gt;Type inference for &lt;code&gt;val&lt;/code&gt;, and &lt;code&gt;lazy val&lt;/code&gt; has been aligned with &lt;code&gt;def&lt;/code&gt;, fixing assorted corner cases and inconsistencies (&lt;a href=&quot;https://github.com/scala/scala/pull/5141&quot;&gt;#5141&lt;/a&gt; and &lt;a href=&quot;https://github.com/scala/scala/pull/5294&quot;&gt;#5294&lt;/a&gt;). Concretely, when computing the type of an overriding field, the type of the overridden field is used as the expected type. As a result, the inferred type of a &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;lazy val&lt;/code&gt; may change in Scala 2.12.&lt;/p&gt;

&lt;p&gt;In particular, an &lt;code&gt;implicit val&lt;/code&gt; that did not need an explicitly declared type in 2.11 may need one now. (Type-annotating implicits is always good practice anyway.)&lt;/p&gt;

&lt;p&gt;You can get the old behavior with &lt;code&gt;-Xsource:2.11&lt;/code&gt;. This may be useful for testing whether these changes are responsible if your code fails to compile.&lt;/p&gt;

&lt;h3&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h3&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Improving these notes&lt;/h2&gt;

&lt;p&gt;Improvements to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;are welcome!&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We again thank our contributors and the entire Scala community. May you find Scala 2.12 a pleasure to code in.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Erik Osheim receives community award</title>
    <link href="http://www.scala-lang.org/news/2016/10/26/bagwell-award-2016.html"/>
    <updated>2016-10-26T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/2016/10/26/bagwell-award-2016</id>
    <content type="html">&lt;p&gt;We are pleased to announce that the Phil Bagwell Memorial Scala Community Award for 2016 has been awarded to &lt;a href=&quot;https://twitter.com/d6&quot;&gt;Erik Osheim&lt;/a&gt;.  The award was presented in Lake District, UK at &lt;a href=&quot;https://scala.world&quot;&gt;Scala World 2016&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Erik is known to Scala users as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;creator of &lt;a href=&quot;https://github.com/non/spire&quot;&gt;Spire&lt;/a&gt;, a leading library for numerics in Scala&lt;/li&gt;
&lt;li&gt;creator of other tools and libraries such as &lt;a href=&quot;https://github.com/non/kind-projector&quot;&gt;kind-projector&lt;/a&gt; (a compiler plugin for type lambdas) and &lt;a href=&quot;https://github.com/non/jawn/&quot;&gt;jawn&lt;/a&gt; (a very fast JSON parser)&lt;/li&gt;
&lt;li&gt;leader of the &lt;a href=&quot;https://github.com/typelevel/cats&quot;&gt;Cats&lt;/a&gt; project, which provides abstractions for functional programming in Scala (&amp;quot;cats&amp;quot; being short for &amp;quot;category&amp;quot;, as in category theory)&lt;/li&gt;
&lt;li&gt;cofounder of &lt;a href=&quot;http://typelevel.org&quot;&gt;Typelevel&lt;/a&gt;, a Scala community organization dedicated to furthering pure, typeful functional programming in Scala&lt;/li&gt;
&lt;li&gt;a friendly and tireless conference-goer and presenter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Erik&amp;#39;s 2015 Scala World presentation, &amp;quot;Principles for approachable,
modular, functional libraries&amp;quot;
(&lt;a href=&quot;http://plastic-idolatry.com/erik/sw2015-inv.pdf&quot;&gt;slides&lt;/a&gt;,
&lt;a href=&quot;https://www.youtube.com/watch?v=iKyIKozv8a8&quot;&gt;video&lt;/a&gt;) is a classic on
the subject of open-source library design, not only from a technical
perspective, but with attention to how sofwtare communities and
ecosystems operate.&lt;/p&gt;

&lt;p&gt;The Bagwell Award is named in honor of Phil Bagwell, who passed away in 2012.  In a &lt;a href=&quot;https://www.typesafe.com/blog/rip-phil-bagwell&quot;&gt;2012 blog post&lt;/a&gt;, Martin Odersky remembers Phil and his special place in the Scala community.&lt;/p&gt;

&lt;p&gt;Past winners of the award:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2015: &lt;a href=&quot;http://scala-lang.org/news/2015/06/25/bagwell-award-2015.html&quot;&gt;Bill Venners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2014: &lt;a href=&quot;https://kojoenv.wordpress.com/2014/09/27/phil-bagwell-award/&quot;&gt;Lalit Pant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013: &lt;a href=&quot;https://twitter.com/dickwall&quot;&gt;Dick Wall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-RC2 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-RC2"/>
    <updated>2016-10-18T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-RC2</id>
    <content type="html">&lt;p&gt;We are happy to announce the availability of Scala 2.12.0-RC2!&lt;/p&gt;

&lt;p&gt;This RC fixes all reported regressions since 2.11.
It will become the final by October 28th, unless we hear of any issues that block your upgrade to 2.12 before then!&lt;/p&gt;

&lt;p&gt;Here are the &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-RC2+label%3Arelease-notes&quot;&gt;most noteworthy fixes&lt;/a&gt; since RC1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5429&quot;&gt;#5429&lt;/a&gt; Default &lt;code&gt;-Xmixin-force-forwarders&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; (regression in performance of generated code);&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5398&quot;&gt;#5398&lt;/a&gt; &lt;a href=&quot;https://github.com/scala/scala-dev/issues/225&quot;&gt;SD-225&lt;/a&gt; Use a &lt;code&gt;lzycompute&lt;/code&gt; method for module initialization. Address a performance regression;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5417&quot;&gt;#5417&lt;/a&gt; &lt;a href=&quot;https://github.com/scala/scala-dev/issues/233&quot;&gt;SD-233&lt;/a&gt; &lt;code&gt;synchronized&lt;/code&gt; blocks are JIT-friendly again;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5433&quot;&gt;#5433&lt;/a&gt; Don&amp;#39;t deprecate &lt;code&gt;Either.left&lt;/code&gt; and &lt;code&gt;Either.right&lt;/code&gt; yet;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5392&quot;&gt;#5392&lt;/a&gt; &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9918&quot;&gt;SI-9918&lt;/a&gt; Don&amp;#39;t crash on &lt;code&gt;object&lt;/code&gt; in &lt;code&gt;trait&lt;/code&gt; mixed into package object;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5397&quot;&gt;#5397&lt;/a&gt; &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9920&quot;&gt;SI-9920&lt;/a&gt; Avoid linkage errors with captured local objects + self types;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5430&quot;&gt;#5430&lt;/a&gt; Emit &lt;code&gt;object&lt;/code&gt; in method like &lt;code&gt;lazy val&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5442&quot;&gt;#5442&lt;/a&gt; &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9943&quot;&gt;SI-9943&lt;/a&gt; &lt;code&gt;sealed&lt;/code&gt; class does not yield SAM type;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.12.0-RC1&quot;&gt;RC1 release notes&lt;/a&gt; have a list of important changes since M5.&lt;/p&gt;

&lt;p&gt;In total, we merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-RC2&quot;&gt;29 pull requests&lt;/a&gt;.
This milestone resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%20%3D%20CLOSED%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-RC2%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;6 JIRA tickets&lt;/a&gt; and &lt;a href=&quot;https://github.com/scala/scala-dev/milestone/9?closed=1&quot;&gt;9 scala-dev issues&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual for Scala pre-releases, 2.12.0-RC2 is not guaranteed to be binary compatible with any other Scala version, including any 2.12 milestones and release candidates.&lt;/p&gt;

&lt;h3&gt;Known issues&lt;/h3&gt;

&lt;p&gt;As with previous 2.12 builds, the new trait encoding may make some
trait-based code run slower. We&amp;#39;ve investigated this issue in depth,
and have implemented important improvements in RC2.
Compile times may still be longer in 2.12 than 2.11. Please let us know
if you notice any performance regressions. We will continue to tweak
the bytecode we emit during the 2.12.x cycle to get the best performance out of the JVM.&lt;/p&gt;

&lt;p&gt;We welcome feedback from the Scala community helping to isolate unusual slowdowns.&lt;/p&gt;

&lt;p&gt;We hope to address the following in a future 2.12.x release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9824&quot;&gt;SI-9824&lt;/a&gt;:
Parallel collections are prone to deadlock in the REPL and
in object initializers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Scala 2.12&lt;/h2&gt;

&lt;p&gt;Scala 2.12 requires a Java 8 runtime.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is all about making optimal use of Java 8&amp;#39;s new features. Traits (&lt;a href=&quot;https://github.com/scala/scala/pull/5003&quot;&gt;#5003&lt;/a&gt;) and functions are compiled to their Java 8 equivalents, and we treat Single Abstract Method types and Scala&amp;#39;s builtin function types uniformly from type checking to the back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;). We also use &lt;code&gt;invokedynamic&lt;/code&gt; for a more natural encoding of other language features (&lt;a href=&quot;https://github.com/scala/scala/pull/4896&quot;&gt;#4896&lt;/a&gt;). We&amp;#39;ve standardized on the GenBCode back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;) and the flat classpath implementation is now the default (&lt;a href=&quot;https://github.com/scala/scala/pull/5057&quot;&gt;#5057&lt;/a&gt;). The optimizer has been completely overhauled for 2.12.&lt;/p&gt;

&lt;p&gt;Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;With this release candidate, we consider 2.12.x to be feature complete.&lt;/p&gt;

&lt;p&gt;For 2.12.0, we will try to remain binary compatible with RC2,
and we won&amp;#39;t risk regressions except for the most critical bugs.&lt;/p&gt;

&lt;h4&gt;Trait compiles to an interface&lt;/h4&gt;

&lt;p&gt;With Java 8 allowing concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface. Before, a trait was represented as a class that held the method implementations and an interface. Note that the compiler still has quite a bit of magic to perform behind the scenes, so that care must be taken if a trait is meant to be implemented in Java. (Briefly, if a trait does any of the following its subclasses require synthetic code: defining fields, calling super, initializer statements in the body, extending a class, relying on linearization to find implementations in the right super trait.)&lt;/p&gt;

&lt;h4&gt;Java 8-style lambdas&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8, whether they target a &lt;code&gt;FunctionN&lt;/code&gt; class from the standard library or a user-defined Single Abstract Method (SAM) type. The type checker accepts a function literal as a valid expression for either kind of &amp;quot;function-like&amp;quot; type (built-in or SAM). This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body, and emits an &lt;code&gt;invokedynamic&lt;/code&gt; that will spin up a lightweight class for this closure using the JDK&amp;#39;s &lt;code&gt;LambdaMetaFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure. This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;New back end&lt;/h4&gt;

&lt;p&gt;Scala 2.12 standardizes on the &amp;quot;GenBCode&amp;quot; back end, which emits code more quickly because it directly generates ASM bytecode from Scala compiler trees, while the previous back end used an intermediate representation called &amp;quot;ICode&amp;quot;. The old back ends (GenASM and GenIcode) have been removed (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;).&lt;/p&gt;

&lt;h4&gt;New optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode back end includes a new inliner and bytecode optimizer.
The optimizer is enabled using &lt;code&gt;-opt&lt;/code&gt; compiler option, which defaults
to &lt;code&gt;-opt:l:classpath&lt;/code&gt;.  Check &lt;code&gt;-opt:help&lt;/code&gt; to see the full list of
available options for the optimizer.&lt;/p&gt;

&lt;p&gt;The following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;li&gt;Box/unbox elimination &lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Either is now right-biased&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Either&lt;/code&gt; now supports operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;,
&lt;code&gt;toOption&lt;/code&gt;, and so forth, which operate on the right-hand side.&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;.left&lt;/code&gt; and &lt;code&gt;.right&lt;/code&gt; may be deprecated in favor of &lt;code&gt;.swap&lt;/code&gt; in a later release.)&lt;/p&gt;

&lt;p&gt;The changes are source-compatible with old code (except in the
presence of conflicting extension methods).&lt;/p&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/soc&quot;&gt;Simon Ochsenreither&lt;/a&gt;, for this
contribution.&lt;/p&gt;

&lt;h4&gt;Futures improved&lt;/h4&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/viktorklang/blog&quot;&gt;blog post series&lt;/a&gt;
by Viktor Klang explores the diverse improvements made to
&lt;code&gt;scala.concurrent.Future&lt;/code&gt; for 2.12.&lt;/p&gt;

&lt;h4&gt;Scaladoc now supports doc comments in Java sources&lt;/h4&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/jodersky&quot;&gt;Jakob Odersky&lt;/a&gt;, for this fix to &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-4826&quot;&gt;SI-4826&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Partial unification of type constructors (SI-2712)&lt;/h4&gt;

&lt;p&gt;Compiling with &lt;code&gt;-Ypartial-unification&lt;/code&gt; adds partial unification of type constructors, fixing the notorious &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-2712&quot;&gt;SI-2712&lt;/a&gt;, thanks to &lt;a href=&quot;https://github.com/milessabin&quot;&gt;Miles Sabin&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Breaking changes&lt;/h3&gt;

&lt;h4&gt;SAM types&lt;/h4&gt;

&lt;p&gt;Implicit conversion of function types to SAM types won&amp;#39;t kick in as often now, since the compiler&amp;#39;s own SAM conversion takes priority:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;trait MySam { def apply(x: Int): String }
implicit def unused(fun: Int =&amp;gt; String): MySam =
  new MySam { def apply(x: Int) = fun(x) }
// uses SAM conversion, not the `unused` implicit
val sammy: MySam = (_: Int).toString
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To retain the old behavior, you may compile under &lt;code&gt;-Xsource:2.11&lt;/code&gt;, or disqualify the type from being a SAM (e.g. by adding a second abstract method).&lt;/p&gt;

&lt;h4&gt;Inferred types for &lt;code&gt;val&lt;/code&gt; (and &lt;code&gt;lazy val&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5141&quot;&gt;#5141&lt;/a&gt; and
&lt;a href=&quot;https://github.com/scala/scala/pull/5294&quot;&gt;#5294&lt;/a&gt; align type
inference for &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;val&lt;/code&gt;, and &lt;code&gt;lazy val&lt;/code&gt;, fixing assorted
corner cases and inconsistencies.  As a result, the inferred type
of a &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;lazy val&lt;/code&gt; may change.&lt;/p&gt;

&lt;p&gt;In particular, &lt;code&gt;implicit val&lt;/code&gt;s that didn&amp;#39;t need explicitly declared
types before may need them now.  (This is always good practice
anyway.)&lt;/p&gt;

&lt;p&gt;You can get the old behavior with &lt;code&gt;-Xsource:2.11&lt;/code&gt;.  This may be
useful for testing whether these changes are responsible if your
code fails to compile.&lt;/p&gt;

&lt;h4&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h4&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Binary compatibility&lt;/h2&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestones and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies apply to 2.12 as well.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.12.0-RC1..v2.12.0-RC2&lt;/code&gt;, the following contributors helped to realize this release candidate: Adriaan Moors, Jason Zaugg, Lukas Rytz, Seth Tisue, Stefan Zeiger, Antoine Gourlay, Raphael Jolly. Thank you!&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;Improvements to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;are welcome!&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-RC2.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your sbt-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-RC2%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-RC1 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-RC1"/>
    <updated>2016-09-06T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-RC1</id>
    <content type="html">&lt;p&gt;We are happy to announce the availability of Scala 2.12.0-RC1!&lt;/p&gt;

&lt;p&gt;Note, however, that Scala 2.12.0-RC2 will follow, due to known
regressions detailed below.&lt;/p&gt;

&lt;p&gt;The most notable changes since M5 are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5135&quot;&gt;#5135&lt;/a&gt;: Either is now
right-biased&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-4826&quot;&gt;SI-4826&lt;/a&gt;: Scaladoc now
supports doc comments in Java sources&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7187&quot;&gt;SI-7187&lt;/a&gt;: Eta-expansion of
zero-argument method values is now deprecated&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5307&quot;&gt;#5307&lt;/a&gt;: Reduced interference
from SAMs when inferring function types in the presence of overload&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5141&quot;&gt;#5141&lt;/a&gt; /
&lt;a href=&quot;https://github.com/scala/scala/pull/5294&quot;&gt;#5294&lt;/a&gt;: Refactoring
of &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;val&lt;/code&gt;, and &lt;code&gt;lazy val&lt;/code&gt; handling, fixing assorted corner
cases and inconsistencies&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5311&quot;&gt;#5311&lt;/a&gt;: Scala is now built with
sbt instead of Ant (affects only contributors, not users)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In total, we merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-RC1&quot;&gt;82 pull requests&lt;/a&gt;, of which &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr%20is%3Amerged%20milestone%3A2.12.0-RC1%20label%3Awelcome&quot;&gt;6 are by new contributors&lt;/a&gt; -- welcome!
This milestone resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%20%3D%20CLOSED%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-RC1%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;25 JIRA tickets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual for Scala pre-releases, 2.12.0-RC1 is not binary compatible with any other Scala version, including any 2.12 milestones.&lt;/p&gt;

&lt;h3&gt;Known issues&lt;/h3&gt;

&lt;p&gt;As with previous 2.12 builds, the new trait encoding may make some
trait-based code run slower. As a result, compile times may also be
longer in 2.12 than 2.11.  We welcome feedback from the Scala
community helping to isolate unusual slowdowns.&lt;/p&gt;

&lt;p&gt;The following known regressions will be fixed in 2.12.0-RC2:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala-dev/issues/225&quot;&gt;SD-225&lt;/a&gt;
may cause drastically longer compile times for certain
kinds of code.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9918&quot;&gt;SI-9918&lt;/a&gt; may
cause &lt;code&gt;scala.reflect.internal.Types$TypeError&lt;/code&gt;s in code
involving package objects.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9920&quot;&gt;SI-9920&lt;/a&gt; may
cause &lt;code&gt;java.lang.NoSuchMethodError&lt;/code&gt;s at runtime.&lt;/li&gt;
&lt;li&gt;A regression may cause &lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;s in
&lt;code&gt;scala.tools.nsc.backend.jvm.BCodeSkelBuilder&lt;/code&gt;; see
&lt;a href=&quot;https://github.com/scala/scala/pull/5395&quot;&gt;#5395&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of the last-mentioned regression,
&lt;a href=&quot;https://github.com/milessabin/shapeless&quot;&gt;Shapeless&lt;/a&gt; will not be
published for 2.12.0-RC1.&lt;/p&gt;

&lt;p&gt;We hope to address the following in a future 2.12.x release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9824&quot;&gt;SI-9824&lt;/a&gt;:
Parallel collections are prone to deadlock in the REPL and
in object initializers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Scala 2.12&lt;/h2&gt;

&lt;p&gt;Scala 2.12 requires a Java 8 runtime.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is all about making optimal use of Java 8&amp;#39;s new features. Traits (&lt;a href=&quot;https://github.com/scala/scala/pull/5003&quot;&gt;#5003&lt;/a&gt;) and functions are compiled to their Java 8 equivalents, and we treat Single Abstract Method types and Scala&amp;#39;s builtin function types uniformly from type checking to the back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;). We also use &lt;code&gt;invokedynamic&lt;/code&gt; for a more natural encoding of other language features (&lt;a href=&quot;https://github.com/scala/scala/pull/4896&quot;&gt;#4896&lt;/a&gt;). We&amp;#39;ve standardized on the GenBCode back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;) and the flat classpath implementation is now the default (&lt;a href=&quot;https://github.com/scala/scala/pull/5057&quot;&gt;#5057&lt;/a&gt;). The optimizer has been completely overhauled for 2.12.&lt;/p&gt;

&lt;p&gt;Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;With this release candidate, we consider 2.12.x to be feature complete.&lt;/p&gt;

&lt;p&gt;For 2.12.0, we will try to remain binary compatible with RC1,
and we won&amp;#39;t risk regressions except for the most critical bugs.&lt;/p&gt;

&lt;h4&gt;Trait compiles to an interface&lt;/h4&gt;

&lt;p&gt;With Java 8 allowing concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface. Before, a trait was represented as a class that held the method implementations and an interface. Note that the compiler still has quite a bit of magic to perform behind the scenes, so that care must be taken if a trait is meant to be implemented in Java. (Briefly, if a trait does any of the following its subclasses require synthetic code: defining fields, calling super, initializer statements in the body, extending a class, relying on linearization to find implementations in the right super trait.)&lt;/p&gt;

&lt;h4&gt;Java 8-style lambdas&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8, whether they target a FunctionN class from the standard library or a user-defined Single Abstract Method type. The type checker accepts a function literal as a valid expression for either kind of &amp;quot;function-like&amp;quot; type (built-in or SAM). This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body, and emits an &lt;code&gt;invokedynamic&lt;/code&gt; that will spin up a lightweight class for this closure using the JDK&amp;#39;s &lt;code&gt;LambdaMetaFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure. This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;New back end&lt;/h4&gt;

&lt;p&gt;Scala 2.12 standardizes on the &amp;quot;GenBCode&amp;quot; back end, which emits code more quickly because it directly generates ASM bytecode from Scala compiler trees, while the previous back end used an intermediate representation called &amp;quot;ICode&amp;quot;. The old back ends (GenASM and GenIcode) have been removed (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;).&lt;/p&gt;

&lt;h4&gt;New optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode back end includes a new inliner and bytecode optimizer.
The optimizer is enabled using &lt;code&gt;-opt&lt;/code&gt; compiler option, which defaults
to &lt;code&gt;-opt:l:classpath&lt;/code&gt;.  Check &lt;code&gt;-opt:help&lt;/code&gt; to see the full list of
available options for the optimizer.&lt;/p&gt;

&lt;p&gt;The following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;li&gt;Box/unbox elimination &lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Either is now right-biased&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Either&lt;/code&gt; now supports operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;,
&lt;code&gt;toOption&lt;/code&gt;, and so forth, which operate on the right-hand side.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.left&lt;/code&gt; and &lt;code&gt;.right&lt;/code&gt; are deprecated in favor of &lt;code&gt;.swap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The changes are source-compatible with old code (except in the
presence of conflicting extension methods).&lt;/p&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/soc&quot;&gt;Simon Ochsenreither&lt;/a&gt;, for this
contribution.&lt;/p&gt;

&lt;h4&gt;Futures improved&lt;/h4&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/viktorklang/blog&quot;&gt;blog post series&lt;/a&gt;
by Viktor Klang explores the diverse improvements made to
&lt;code&gt;scala.concurrent.Future&lt;/code&gt; for 2.12.&lt;/p&gt;

&lt;h4&gt;Scaladoc now supports doc comments in Java sources&lt;/h4&gt;

&lt;p&gt;Thanks, &lt;a href=&quot;https://github.com/jodersky&quot;&gt;Jakob Odersky&lt;/a&gt;, for this fix to &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-4826&quot;&gt;SI-4826&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Partial unification of type constructors (SI-2712)&lt;/h4&gt;

&lt;p&gt;Compiling with &lt;code&gt;-Ypartial-unification&lt;/code&gt; adds partial unification of type constructors, fixing the notorious &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-2712&quot;&gt;SI-2712&lt;/a&gt;, thanks to &lt;a href=&quot;https://github.com/milessabin&quot;&gt;Miles Sabin&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Breaking changes&lt;/h3&gt;

&lt;h4&gt;SAM types&lt;/h4&gt;

&lt;p&gt;As of &lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;, we treat Single Abstract Method types in the same way as our built-in FunctionN classes. This means overloading resolution has more contenders to choose from, making type inference less effective. Here&amp;#39;s an example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class C[V] {
  def sort(cmp: java.util.Comparator[V]): C[V] = ???
  def sort(cmp: (V, V) =&amp;gt; Int): C[V] = sort(
    new java.util.Comparator[V] {
      def compare(a: V, b: V): Int = cmp(a, b)
    })
}

(new C[Int]) sort (_ - _) // error
(new C[Int]) sort ((_ - _): java.util.Comparator[Int]) // ok
(new C[Int]) sort ((a: Int, b: Int) =&amp;gt; a - b)  // ok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first attempt fails because the type checker cannot infer the types for &lt;code&gt;_ - _&lt;/code&gt;&amp;#39;s arguments anymore.
Type inference in this scenario only works when we can narrow the overloads down to one before type checking the arguments the methods are applied to. When a function is passed as an argument to an overloaded method, we do this by considering the &amp;quot;shape&amp;quot; of the function (essentially, its arity). Now that &lt;code&gt;Comparator[?]&lt;/code&gt; and &lt;code&gt;(?, ?) =&amp;gt; ?&lt;/code&gt; are both considered functions of arity two, our clever scheme breaks down and the programmer must either select an overload (second application) or make the argument types explicit (last application, which resolves to the &lt;code&gt;Function2&lt;/code&gt; overload).&lt;/p&gt;

&lt;p&gt;Finally, implicit conversion of SAM types to Function types won&amp;#39;t kick in anymore, since the compiler does this conversion itself first:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;trait MySam { def apply(x: Int): String }

implicit def unused(fun: Int =&amp;gt; String): MySam
  = new MySam { def apply(x: Int) = fun(x) }

// uses sam conversion, not the `unused` implicit
val sammy: MySam = _.toString
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Inferred types for &lt;code&gt;val&lt;/code&gt; (and &lt;code&gt;lazy val&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5141&quot;&gt;#5141&lt;/a&gt; and
&lt;a href=&quot;https://github.com/scala/scala/pull/5294&quot;&gt;#5294&lt;/a&gt; align type
inference for &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;val&lt;/code&gt;, and &lt;code&gt;lazy val&lt;/code&gt;, fixing assorted
corner cases and inconsistencies.  As a result, the inferred type
of a &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;lazy val&lt;/code&gt; may change.&lt;/p&gt;

&lt;p&gt;In particular, &lt;code&gt;implicit val&lt;/code&gt;s that didn&amp;#39;t need explicitly declared
types before may need them now.  (This is always good practice
anyway.)&lt;/p&gt;

&lt;p&gt;You can get the old behavior with &lt;code&gt;-Xsource:2.11&lt;/code&gt;.  This may be
useful for testing whether these changes are responsible if your
code fails to compile.&lt;/p&gt;

&lt;h4&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h4&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Binary compatibility&lt;/h2&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestones and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies apply to 2.12 as well.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.12.0-M5..v2.12.0-RC1&lt;/code&gt;, the following contributors helped to realize this milestone: Adriaan Moors, Jason Zaugg, Lukas Rytz, Stefan Zeiger, A. P. Marki, Simon Ochsenreither, Seth Tisue, Jakob Odersky, Dale Wijnand, Dima Tkach, Janek Bogucki, Michał Pociecha, Christopher Davenport, Martin Olsson, tomjridge, Miles Sabin, Oscar Boykin, Raul Bache, Rex Kerr, Dmitriy Pogretskiy, Daniel Barclay, Antoine Gourlay, Steven Mitchell, Carsten Varming. Thank you!&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;Improvements to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;are welcome!&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-RC1.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your sbt-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-M5%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-M5 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-M5"/>
    <updated>2016-06-29T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-M5</id>
    <content type="html">&lt;p&gt;We are happy to announce the availability of Scala 2.12.0-M5!&lt;/p&gt;

&lt;p&gt;Notable changes in M5
(&lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=milestone%3A2.12.0-M5%20label%3Arelease-notes&quot;&gt;see here&lt;/a&gt;
for a more extensive list):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5251&quot;&gt;#5251&lt;/a&gt;: concrete trait methods are compiled to a
static method (in the interface classfile) containing the actual implementation, and a default
method forwards that to the static one.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5085&quot;&gt;#5085&lt;/a&gt;: classes extending traits no longer get mixin
forwarders (in most cases), the JVM picks the correct default method.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/scala/scala/pull/5102&quot;&gt;#5102&lt;/a&gt; adds partial unification of type constructors
(behind &lt;code&gt;-Ypartial-unification&lt;/code&gt;) and fixes SI-2712. Thanks @milessabin!&lt;/li&gt;
&lt;li&gt;The optimizer now listens to &lt;code&gt;-opt&lt;/code&gt; (instead of &lt;code&gt;-Yopt&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9390&quot;&gt;SI-9390&lt;/a&gt;: local methods that don&amp;#39;t capture &lt;code&gt;this&lt;/code&gt;
are emitted as static to prevent capturing the outer instance in lambdas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: #5085 introduces a performance regression, it causes the Scala compiler to run 20% slower.
Any Scala program that uses concrete trait methods might see a slowdown. The most likely
cause is that the JVM does not perform &amp;quot;class hierarchy analysis&amp;quot; (CHA) for methods
defined in interfaces, including default methods, as noted in
&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8036580&quot;&gt;JDK bug 8036580&lt;/a&gt;. This prevents the JIT from
performing certain (important) optimizations. Most likely we will have to revert the change to fix
the issue, but we are still investigating the details. The 2.12 release notes will clarify the
impact of changes to traits on binary compatibility.&lt;/p&gt;

&lt;p&gt;In total, we merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-M5&quot;&gt;96 pull requests&lt;/a&gt;, of which &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr%20is%3Amerged%20milestone%3A2.12.0-M5%20label%3Awelcome&quot;&gt;9 are by new contributors&lt;/a&gt; -- welcome!
This milestone resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%20%3D%20CLOSED%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-M5%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;49 JIRA tickets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual for milestones, 2.12.0-M5 is not binary compatible with any other Scala release, including other 2.12 milestones. Scala 2.12 requires a Java 8 runtime.&lt;/p&gt;

&lt;h2&gt;Scala 2.12&lt;/h2&gt;

&lt;p&gt;Scala 2.12 is all about making optimal use of Java 8&amp;#39;s new features. Traits (&lt;a href=&quot;https://github.com/scala/scala/pull/5003&quot;&gt;#5003&lt;/a&gt;) and functions are compiled to their Java 8 equivalents, and we treat Single Abstract Method types and Scala&amp;#39;s builtin function types uniformly from type checking to the back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;). We also use &lt;code&gt;invokedynamic&lt;/code&gt; for a more natural encoding of other language features (&lt;a href=&quot;https://github.com/scala/scala/pull/4896&quot;&gt;#4896&lt;/a&gt;). We&amp;#39;ve standardized on the GenBCode back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;) and the flat classpath implementation is now the default (&lt;a href=&quot;https://github.com/scala/scala/pull/5057&quot;&gt;#5057&lt;/a&gt;). The optimizer has been completely overhauled for 2.12.&lt;/p&gt;

&lt;p&gt;Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;Since M4, we consider 2.12.x feature complete.
For RC1, we will try to remain binary compatible with M5, and we won&amp;#39;t risk regressions except for the most critical bugs.&lt;/p&gt;

&lt;h4&gt;Trait compiles to an interface&lt;/h4&gt;

&lt;p&gt;With Java 8 allowing concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface. Before, a trait was represented as a class that held the method implementations and an interface. Note that the compiler still has quite a bit of magic to perform behind the scenes, so that care must be taken if a trait is meant to be implemented in Java. (Briefly, if a trait does any of the following its subclasses require synthetic code: defining fields, calling super, initializer statements in the body, extending a class, relying on linearization to find implementations in the right super trait.)&lt;/p&gt;

&lt;h4&gt;Java 8-style lambdas&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8, whether they target a FunctionN class from the standard library or a user-defined Single Abstract Method type. The type checker accepts a function literal as a valid expression for either kind of &amp;quot;function-like&amp;quot; type (built-in or SAM). This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body, and emits an &lt;code&gt;invokedynamic&lt;/code&gt; that will spin up a lightweight class for this closure using the JDK&amp;#39;s &lt;code&gt;LambdaMetaFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure. This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;New back end&lt;/h4&gt;

&lt;p&gt;Scala 2.12 standardizes on the &amp;quot;GenBCode&amp;quot; back end, which emits code more quickly because it directly generates ASM bytecode from Scala compiler trees, while the previous back end used an intermediate representation called &amp;quot;ICode&amp;quot;. The old back ends (GenASM and GenIcode) have been removed (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;).&lt;/p&gt;

&lt;h4&gt;New bytecode optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode back end includes a new inliner and bytecode optimizer.
The optimizer is enabled using the &lt;code&gt;-opt:l:classpath&lt;/code&gt; compiler option.
Check &lt;code&gt;-opt:help&lt;/code&gt; to see the full list of available options for the optimizer.&lt;/p&gt;

&lt;p&gt;The following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;li&gt;Box/unbox elimination &lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The work on the new optimizer is still ongoing.  You can track it in the &lt;a href=&quot;https://github.com/scala/scala-dev/labels/t%3Aoptimizer&quot;&gt;scala-dev repository issue tracker&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Breaking changes&lt;/h3&gt;

&lt;h4&gt;SAM types&lt;/h4&gt;

&lt;p&gt;As of &lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;, we treat Single Abstract Method types in the same way as our built-in FunctionN classes. This means overloading resolution has more contenders to choose from, making type inference less effective. Here&amp;#39;s an example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class C[V] {
  def sort(cmp: java.util.Comparator[V]): C[V] = ???
  def sort(cmp: (V, V) =&amp;gt; Int): C[V] = sort(
    new java.util.Comparator[V] {
      def compare(a: V, b: V): Int = cmp(a, b)
    })
}

(new C[Int]) sort (_ - _) // error
(new C[Int]) sort ((_ - _): java.util.Comparator[Int]) // ok
(new C[Int]) sort ((a: Int, b: Int) =&amp;gt; a - b)  // ok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first attempt fails because the type checker cannot infer the types for &lt;code&gt;_ - _&lt;/code&gt;&amp;#39;s arguments anymore.
Type inference in this scenario only works when we can narrow the overloads down to one before type checking the arguments the methods are applied to. When a function is passed as an argument to an overloaded method, we do this by considering the &amp;quot;shape&amp;quot; of the function (essentially, its arity). Now that &lt;code&gt;Comparator[?]&lt;/code&gt; and &lt;code&gt;(?, ?) =&amp;gt; ?&lt;/code&gt; are both considered functions of arity two, our clever scheme breaks down and the programmer must either select an overload (second application) or make the argument types explicit (last application, which resolves to the &lt;code&gt;Function2&lt;/code&gt; overload).&lt;/p&gt;

&lt;p&gt;Finally, implicit conversion of SAM types to Function types won&amp;#39;t kick in anymore, since the compiler does this conversion itself first:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;trait MySam { def apply(x: Int): String }

implicit def unused(fun: Int =&amp;gt; String): MySam
  = new MySam { def apply(x: Int) = fun(x) }

// uses sam conversion, not the `unused` implicit
val sammy: MySam = _.toString
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h4&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Binary compatibility&lt;/h2&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestone releases and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies apply to 2.12 as well.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.12.0-M4..v2.12.0-M5&lt;/code&gt;, the following contributors helped to realize this milestone: Lukas Rytz, A. P. Marki, Jason Zaugg, Sébastien Doeraene, Adriaan Moors, Performant Data LLC, Simon Ochsenreither, Janek Bogucki, Miles Sabin, Felix Mulder, Stefan Zeiger, Rui Gonçalves, Raphael Jolly, Arno den Hartog, Viktor Klang, Olli Helenius, Kenji Yoshida, Steve Robinson, Taras Boiko, af, chrisokasaki, peterz, sh0hei, Łukasz Gieroń, Antoine Gourlay, Ben Hutchison, CodingTwinky, Dale Wijnand, Iulian Dragos, Jakob Odersky, Jens, Krzysztof Romanowski, Martijn Hoekstra, Mike Pheasant, Nafer Sanabria, Nicolas Stucki, Performant Data, Ruslan Sennov, Seth Tisue, Shixiong Zhu. Thank you!&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;Improvements to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;are welcome!&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-M5.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-M5%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-M4 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-M4"/>
    <updated>2016-04-11T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-M4</id>
    <content type="html">&lt;p&gt;We are happy to announce the availability of Scala 2.12.0-M4, which marks feature completeness for 2.12!&lt;/p&gt;

&lt;p&gt;Scala 2.12 is all about making optimal use of Java 8&amp;#39;s new features. Traits (&lt;a href=&quot;https://github.com/scala/scala/pull/5003&quot;&gt;#5003&lt;/a&gt;) and functions are compiled to their Java 8 equivalents, and we treat Single Abstract Method types and Scala&amp;#39;s builtin function types uniformly from type checking to the back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;). We also use &lt;code&gt;invokedynamic&lt;/code&gt; for a more natural encoding of other language features (&lt;a href=&quot;https://github.com/scala/scala/pull/4896&quot;&gt;#4896&lt;/a&gt;). We&amp;#39;ve standardized on the GenBCode back end (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;) and the flat classpath implementation is now the default (&lt;a href=&quot;https://github.com/scala/scala/pull/5057&quot;&gt;#5057&lt;/a&gt;). The optimizer has been completely overhauled for 2.12. This milestone adds box/unbox optimization (&lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;For more details about what&amp;#39;s new in this milestone, including some breaking changes, please take a look at &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+label%3Arelease-notes+milestone%3A2.12.0-M4+is%3Amerged&quot;&gt;these 14 noteworthy PRs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In total, we merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-M4&quot;&gt;135 pull requests&lt;/a&gt;, of which &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+milestone%3A2.12.0-M4+label%3Awelcome&quot;&gt;16 are by new contributors&lt;/a&gt; -- welcome! This milestone resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%20%3D%20CLOSED%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-M4%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;49 JIRA tickets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;d especially like to thank Felix Mulder for his &lt;a href=&quot;https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr+is%3Amerged+author%3Afelixmulder++milestone%3A2.12.0-M4&quot;&gt;excellent work on the new Scaladoc interface&lt;/a&gt;! &lt;a href=&quot;http://www.scala-lang.org/files/archive/api/2.12.0-M4/&quot;&gt;Check it out!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual for milestones, 2.12.0-M4 is not binary compatible with any other Scala release, including other 2.12 milestones. Scala 2.12 requires a Java 8 runtime.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;With M4, we consider 2.12.x feature complete. Please try it out while we still have time to fix any regressions in M5! For the next milestone, we&amp;#39;ll focus on addressing any issues discovered with M4, overall robustness and polish, and some smaller improvements that are less likely to cause regressions or source incompatibilities. For RC1, we will try to remain binary compatible with M5, and we won&amp;#39;t risk regressions except for the most critical bugs.&lt;/p&gt;

&lt;h4&gt;Trait compiles to an interface&lt;/h4&gt;

&lt;p&gt;With Java 8 allowing concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface. Before, a trait was represented as a class that held the method implementations and an interface. Note that the compiler still has quite a bit of magic to perform behind the scenes, so that care must be taken if a trait is meant to be implemented in Java. (Briefly, if a trait does any of the following its subclasses require synthetic code: defining fields, calling super, initializer statements in the body, extending a class, relying on linearization to find implementations in the right super trait.)&lt;/p&gt;

&lt;h4&gt;Java 8-style lambdas&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8, whether they target a FunctionN class from the standard library or a user-defined Single Abstract Method type. The type checker accepts a function literal as a valid expression for either kind of &amp;quot;function-like&amp;quot; type (built-in or SAM). This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body, and emits an &lt;code&gt;invokedynamic&lt;/code&gt; that will spin up a lightweight class for this closure using the JDK&amp;#39;s &lt;code&gt;LambdaMetaFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure. This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;New back end&lt;/h4&gt;

&lt;p&gt;Scala 2.12 standardizes on the &amp;quot;GenBCode&amp;quot; back end, which emits code more quickly because it directly generates ASM bytecode from Scala compiler trees, while the previous back end used an intermediate representation called &amp;quot;ICode&amp;quot;. The old back ends (GenASM and GenIcode) have been removed (&lt;a href=&quot;https://github.com/scala/scala/pull/4814&quot;&gt;#4814&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4838&quot;&gt;#4838&lt;/a&gt;).&lt;/p&gt;

&lt;h4&gt;New bytecode optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode back end includes a new inliner and bytecode optimizer.
The optimizer is enabled using the &lt;code&gt;-Yopt:l:classpath&lt;/code&gt; compiler option.
Check &lt;code&gt;-Yopt:help&lt;/code&gt; to see the full list of available options for the optimizer.&lt;/p&gt;

&lt;p&gt;As of M4, the following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;li&gt;Box/unbox elimination &lt;a href=&quot;https://github.com/scala/scala/pull/4858&quot;&gt;#4858&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The work on the new optimizer is still ongoing.  You can track it in the &lt;a href=&quot;https://github.com/scala/scala-dev/labels/t%3Aoptimizer&quot;&gt;scala-dev repository issue tracker&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Breaking changes&lt;/h3&gt;

&lt;h4&gt;SAM types&lt;/h4&gt;

&lt;p&gt;As of &lt;a href=&quot;https://github.com/scala/scala/pull/4971&quot;&gt;#4971&lt;/a&gt;, we treat Single Abstract Method types in the same way as our built-in FunctionN classes. This means overloading resolution has more contenders to choose from, making type inference less effective. Here&amp;#39;s an example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class C[V] {
  def sort(cmp: java.util.Comparator[V]): C[V] = ???
  def sort(cmp: (V, V) =&amp;gt; Int): C[V] = sort(
    new java.util.Comparator[V] {
      def compare(a: V, b: V): Int = cmp(a, b)
    })
}

(new C[Int]) sort (_ - _) // error
(new C[Int]) sort ((_ - _): java.util.Comparator[Int]) // ok
(new C[Int]) sort ((a: Int, b: Int) =&amp;gt; a - b)  // ok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first attempt fails because the type checker cannot infer the types for &lt;code&gt;_ - _&lt;/code&gt;&amp;#39;s arguments anymore.
Type inference in this scenario only works when we can narrow the overloads down to one before type checking the arguments the methods are applied to. When a function is passed as an argument to an overloaded method, we do this by considering the &amp;quot;shape&amp;quot; of the function (essentially, its arity). Now that &lt;code&gt;Comparator[?]&lt;/code&gt; and &lt;code&gt;(?, ?) =&amp;gt; ?&lt;/code&gt; are both considered functions of arity two, our clever scheme breaks down and the programmer must either select an overload (second application) or make the argument types explicit (last application, which resolves to the &lt;code&gt;Function2&lt;/code&gt; overload).&lt;/p&gt;

&lt;p&gt;Finally, implicit conversion of SAM types to Function types won&amp;#39;t kick in anymore, since the compiler does this conversion itself first:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;trait MySam { def apply(x: Int): String }

implicit def unused(fun: Int =&amp;gt; String): MySam
  = new MySam { def apply(x: Int) = fun(x) }

// uses sam conversion, not the `unused` implicit
val sammy: MySam = _.toString
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h4&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Binary compatibility&lt;/h2&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestone releases and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies apply to 2.12 as well.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.12.0-M3..v2.12.0-M4&lt;/code&gt;, the following contributors helped to realize this milestone: Lukas Rytz, Adriaan Moors, Jason Zaugg, Stefan Zeiger, Janek Bogucki, Seth Tisue, Felix Mulder, A. P. Marki, Simon Ochsenreither, Performant Data LLC, wpopielarski, Kota Mizushima, Rui Gonçalves, Shane Delmore, dk14, Rex Kerr, martijnhoekstra, Kenji Yoshida, vsalvis, todesking, triggerNZ, Linas Medziunas, Dongjoon Hyun, Denys Shabalin, Pim Verkerk, Rebecca Claire Murphy, Alan Johnson, David Hoepelman, Shadow53, Casey Leask, Arnout Engelen, Sébastien Doeraene, Valerian, Viktor Klang, jvican, mathhun, peterz, Eitan Adler, Frank S. Thomas, Dmitry Petrashko, JoeRatt, Kato Kazuyoshi, Dmitry Melnichenko, Marc Prud&amp;#39;hommeaux, Mark Mynsted, Marko Elezovic, Markus Hauck, Michał Pociecha. Thank you!&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;Improvements to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;are welcome!&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-M4.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-M4%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.11.8 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.11.8"/>
    <updated>2016-03-08T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.11.8</id>
    <content type="html">&lt;p&gt;We are pleased to announce the availability of Scala 2.11.8!&lt;/p&gt;

&lt;p&gt;Significant changes since 2.11.7 include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Scala REPL now has robust and flexible tab-completion (details below)&lt;/li&gt;
&lt;li&gt;An assortment of bugs have been fixed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to 2.11.7, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.11.8%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;44 issues&lt;/a&gt;.  We merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.8&quot;&gt;175 pull requests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual for minor releases, Scala 2.11.8 is binary compatible with other releases in the Scala 2.11 series.&lt;/p&gt;

&lt;p&gt;The last planned 2.11.x release will be 2.11.9 in late 2016.&lt;/p&gt;

&lt;h3&gt;New tab-completion in the Scala REPL&lt;/h3&gt;

&lt;p&gt;The implementation of tab-completion in the Scala REPL has been rewritten and now uses the same infrastructure as for example Scala IDE and ENSIME.&lt;/p&gt;

&lt;p&gt;There are a number of improvements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reliable completion, also in partial expressions and syntactically incorrect programs: try &lt;code&gt;class C { def f(l: List[Int]) = l.&amp;lt;TAB&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CamelCase completion: try &lt;code&gt;(l: List[Int]).rro&amp;lt;TAB&amp;gt;&lt;/code&gt;, it expands to &lt;code&gt;(l: List[Int]).reduceRightOption&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Show desugarings performed by the compiler by adding &lt;code&gt;//print&lt;/code&gt;: try &lt;code&gt;for (x &amp;lt;- 1 to 10) println(x) //print&amp;lt;TAB&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Complete bean getters without typing &lt;code&gt;get&lt;/code&gt;: try &lt;code&gt;(d: java.util.Date).day&amp;lt;TAB&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Find members by typing any CamelCased part of the name: try &lt;code&gt;classOf[String].typ&amp;lt;TAB&amp;gt;&lt;/code&gt; to get &lt;code&gt;getAnnotationsByType&lt;/code&gt;, &lt;code&gt;getComponentType&lt;/code&gt; and others&lt;/li&gt;
&lt;li&gt;Complete non-qualified names, including types: try &lt;code&gt;def f(s: Str&amp;lt;TAB&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Press tab twice to see the method signature: try &lt;code&gt;List(1,2,3).part&amp;lt;TAB&amp;gt;&lt;/code&gt;, which completes to &lt;code&gt;List(1,2,3).partition&lt;/code&gt;; press tab again to display &lt;code&gt;def partition(p: Int =&amp;gt; Boolean): (List[Int], List[Int])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks to @retronym and @som-snytt for their fruitful collaboration on this work!&lt;/p&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.11.7..v2.11.8&lt;/code&gt;, 44 people contributed to this minor release: Seth Tisue, Jason Zaugg, Janek Bogucki, Lukas Rytz, Stefan Zeiger, A. P. Marki, Rex Kerr, Performant Data LLC, wpopielarski, Adriaan Moors, Vlad Ureche, Rui Gonçalves, vsalvis, martijnhoekstra, todesking, Li Yao, Frank S. Thomas, Igor Racic, Michał Pociecha, Kenji Yoshida, Tomas Janousek, dk14, jvican, stusmall, kirillkh, Alexey Romanov, Antoine Gourlay, Arnout Engelen, Eitan Adler, Felix Mulder, Gerard Basler, Jan Bessai, JoeRatt, Kirill Khazan, Linas Medziunas, Marconi Lanna, Mariot Chauvin, Michael, Parambir Singh, Paul Draper, Ryan Zhang, Simon Schäfer, Sébastien Doeraene, Tim Vergenz.&lt;/p&gt;

&lt;h3&gt;Obtaining Scala&lt;/h3&gt;

&lt;p&gt;Scala releases are available through a variety of channels, including (but not limited to):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.11.8.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.8%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Try the &lt;a href=&quot;https://www.lightbend.com/activator/template/hello-scala-2_11&quot;&gt;Hello Scala 2.11 template&lt;/a&gt; in &lt;a href=&quot;https://www.lightbend.com/activator/download&quot;&gt;Lightbend Activator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Scala 2.11 Notes&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;release notes for Scala 2.11.1&lt;/a&gt; have important information applicable to the whole 2.11 series, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Details on new features, important changes and deprecations since Scala 2.10.&lt;/li&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>2016 Scala Release Schedule update</title>
    <link href="http://www.scala-lang.org/news/2016-schedule.html"/>
    <updated>2015-12-09T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/schedule-update</id>
    <content type="html">&lt;p&gt;With 2016 rapidly approaching, it&amp;#39;s time for an update on our plans for Scala next year!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scala 2.11:&lt;/strong&gt; We expect to conclude the 2.11.x series with 2.11.8 in Q1 2016 and 2.11.9 in Q3 2016.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scala 2.12:&lt;/strong&gt; Our current focus is to have 2.12.0-RC1 out by the end of Q2. First, we&amp;#39;ll have two more 2.12 milestones:
M4 by the end of January (new trait encoding!), and M5 before Scala Days NYC (feature freeze).
Our &lt;a href=&quot;https://github.com/scala/scala/milestones&quot;&gt;GitHub milestones page&lt;/a&gt; has projected dates,
and will be updated with milestone details as they develop.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://scala-lang.org/news/2.12-roadmap&quot;&gt;Big compiler changes&lt;/a&gt; are underway, between the new encodings for
lambdas and traits that take full advantage of Java 8, and the new optimizer. Both milestones will be an excellent
opportunity to give 2.12 a spin before we cut RC1 (expected end of May). We&amp;#39;re eager to hear your experience with 2.12,
both online and in person at Scala Days NYC and Berlin!&lt;/p&gt;

&lt;h2&gt;Participation&lt;/h2&gt;

&lt;p&gt;As always, getting new Scala versions out the door is a collective effort between Typesafe, EPFL, and the Scala user community.&lt;/p&gt;

&lt;p&gt;Areas where participation is welcome include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Library authors: we encourage you to publish your libraries for 2.12.0-M3 and later milestones.
If you do publish, please &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list your library&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Library authors: if (the latest version of) your library isn&amp;#39;t included in the 2.12 community build,
we have &lt;a href=&quot;https://github.com/scala/community-builds/wiki&quot;&gt;documented&lt;/a&gt; how to add it. We’ll be happy to help,
as the community build is helping us catch more regressions than ever. As always, we&amp;#39;re counting on your help with testing
before we go into RC mode! (The &lt;a href=&quot;https://github.com/scala/community-builds/blob/2.12.x/common.conf&quot;&gt;2.12 community build config&lt;/a&gt; 
lists which version of each built project, and whether its test suite is being exercised.)&lt;/li&gt;
&lt;li&gt;Reviewing &lt;a href=&quot;https://github.com/scala/scala/pulls&quot;&gt;pull requests in the Scala repository&lt;/a&gt;, where 2.12.x is now the default branch.
Strong motivation will be needed before we merge anything but important bug fixes to the 2.11.x branch.&lt;/li&gt;
&lt;li&gt;Documentation updates and reviewing help are much appreciated at the &lt;a href=&quot;https://github.com/scala/scala-lang/pulls&quot;&gt;scala-lang&lt;/a&gt; 
and &lt;a href=&quot;https://github.com/scala/scala.github.com/pulls&quot;&gt;docs.scala-lang&lt;/a&gt; repos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can talk to us about 2.12 on the &lt;a href=&quot;https://groups.google.com/forum/%23!forum/scala-internals&quot;&gt;scala-internals mailing list&lt;/a&gt; 
and the &lt;a href=&quot;https://gitter.im/scala/contributors&quot;&gt;scala/contributors Gitter room&lt;/a&gt;.
(An &lt;a href=&quot;http://www.scala-lang.org/community/&quot;&gt;expanded community page&lt;/a&gt; on the Scala site lists these and other forums and resources.)&lt;/p&gt;

&lt;p&gt;Your feedback will inform any revisions needed to the schedule described here.
We&amp;#39;ll keep you informed as we continue to refine &lt;a href=&quot;https://github.com/scala/scala/milestones&quot;&gt;our release schedule&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Timing&lt;/h2&gt;

&lt;p&gt;Below is a recap of our timeline, future and past. The 2.12.x milestones follow 2.11.x&amp;#39;s schedule,
with about a year for development between M1 and RC1. Because 2.11.x will be the last release that supports Java 6,
we&amp;#39;ve worked extra hard to improve 2.11.x before shifting our focus to 2.12.x, with a half dozen releases in one year
(the same number of 2.10.x releases took twice as long). For a while now, 2.11.x has had to take a back seat while we
make the last push to complete 2.12.0-RC1 according to this schedule.&lt;/p&gt;

&lt;p&gt;|                   |                 |                                                                       |
|-------------------|-----------------|-----------------------------------------------------------------------|
| &lt;strong&gt;Future 2.12.x&lt;/strong&gt; |                 |                                                                       |
|                   |                 |                                                                       |
|  2.12.0-M4        | &lt;em&gt;Jan 25, 2016&lt;/em&gt;  | ca. 12 work-weeks after M3                                            |
|  2.12.0-M5        | &lt;em&gt;Apr 25, 2016&lt;/em&gt;  | one year after M1, as in 2.11.x                                       |
|  2.12.0-RC1       | &lt;em&gt;May 30, 2016&lt;/em&gt;  | one month after last milestone                                        |
|                   |                 |                                                                       |
| &lt;strong&gt;Future 2.11.x&lt;/strong&gt; |                 |                                                                       |
|                   |                 |                                                                       |
|  2.11.8           | &lt;em&gt;Feb 8, 2016&lt;/em&gt;   | between 2.12.0-M4 and M5                                              |
|  2.11.9           | &lt;em&gt;Q3, 2016&lt;/em&gt;      | last planned 2.11.x release, &amp;gt;2 years after 2.11.1                    |
|                   |                 |                                                                       |
| &lt;strong&gt;Past 2.12.x&lt;/strong&gt;   |                 |                                                                       |
|                   |                 |                                                                       |
|   2.12.0-M1       | &lt;em&gt;May 4, 2015&lt;/em&gt;   |                                                                       |
|   2.12.0-M2       | &lt;em&gt;Jul 15, 2015&lt;/em&gt;  |                                                                       |
|   2.12.0-M3       | &lt;em&gt;Oct 6, 2015&lt;/em&gt;   |                                                                       |
|                   |                 |                                                                       |
| &lt;strong&gt;Past 2.11.x&lt;/strong&gt;   |                 |                                                                       |
|                   |                 |                                                                       |
|   2.11.0-M1       | &lt;em&gt;Jan 7, 2013&lt;/em&gt;   |                                                                       |
|   2.11.0-M7       | &lt;em&gt;Nov 18, 2013&lt;/em&gt;  |                                                                       |
|   2.11.0-M8       | &lt;em&gt;Jan 21, 2014&lt;/em&gt;  | one year after M1                                                     |
|   2.11.0-RC1      | &lt;em&gt;Feb 28, 2014&lt;/em&gt;  | one month after last milestone                                        |
|   2.11.0          | &lt;em&gt;Apr 16, 2014&lt;/em&gt;  | six weeks after RC1                                                   |
|   2.11.1          | &lt;em&gt;May 20, 2014&lt;/em&gt;  |                                                                       |
|   2.11.7          | &lt;em&gt;Jun 23, 2015&lt;/em&gt;  | just 1 year after 2.11.1! (2.10.1-2.10.5 took two years)              |
|                   |                 |                                                                       |
| &lt;strong&gt;2.10.x&lt;/strong&gt;        |                 |                                                                       |
|                   |                 |                                                                       |
|   2.10.0          | &lt;em&gt;Dec 19, 2012&lt;/em&gt;  |                                                                       |
|   2.10.1          | &lt;em&gt;Mar 12, 2013&lt;/em&gt;  |                                                                       |
|   2.10.2          | &lt;em&gt;Jun 6, 2013&lt;/em&gt;   |                                                                       |
|   2.10.3          | &lt;em&gt;Sep 27, 2013&lt;/em&gt;  |                                                                       |
|   2.10.4          | &lt;em&gt;Mar 18, 2014&lt;/em&gt;  |                                                                       |
|   2.10.5          | &lt;em&gt;Mar 4, 2015&lt;/em&gt;   | EOL two years after 2.10.1                                            |
|   2.10.6          | &lt;em&gt;Sep 18, 2015&lt;/em&gt;  | resolve license incompatibility                                       |&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-M3 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-M3"/>
    <updated>2015-10-06T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-M3</id>
    <content type="html">&lt;p&gt;We are pleased to announce the availability of Scala 2.12.0-M3!&lt;/p&gt;

&lt;p&gt;Significant changes since M2 include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The REPL received a robust and flexible implementation of tab-completion (details below) - a fruitful collaboration between @som-snytt and @retronym&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;@implicitAmbiguous&lt;/code&gt; annotation allows customizing the error message when an implicit search finds multiple ambiguous values (details below) - thanks @puffnfresh!&lt;/li&gt;
&lt;li&gt;Enabling &lt;code&gt;-Ywarn-unused-import&lt;/code&gt; now correctly warns about unused imports that were considered but discarded during an implicit search - thanks @som-snytt!&lt;/li&gt;
&lt;li&gt;The optimizer now attempts to inline invocations of higher-order methods if the argument function is statically known, eliminating polymorphic callsites. (This work will be refined further in later milestones.)&lt;/li&gt;
&lt;li&gt;The standard library no longer contains a clone of Java&amp;#39;s fork/join library, but uses the one bundled in Java 8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to M2, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%20%3D%20CLOSED%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-M3%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;21 issues&lt;/a&gt;. We merged &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-M3&quot;&gt;49 pull requests&lt;/a&gt;.
&amp;lt;!-- Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.11.7%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.11.7%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.--&amp;gt;&lt;/p&gt;

&lt;p&gt;As usual for milestones, 2.12.0-M3 is not binary compatible with any other Scala release, including other 2.12 milestones.&lt;/p&gt;

&lt;h2&gt;About Scala 2.12&lt;/h2&gt;

&lt;p&gt;The Scala 2.12 series targets Java 8. Programs written in Scala 2.12 must be compiled and run on Java 8 or newer.&lt;/p&gt;

&lt;h3&gt;Source compatibility&lt;/h3&gt;

&lt;p&gt;Scala 2.12 is mostly source compatible with 2.11.  Code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Binary compatibility&lt;/h3&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestone releases and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies apply to 2.12 as well.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;Future 2.12 milestones will include additional new features. For now, M3 includes the following major changes:&lt;/p&gt;

&lt;h4&gt;New backend&lt;/h4&gt;

&lt;p&gt;Scala 2.12 enables the &amp;quot;GenBCode&amp;quot; backend by default.&lt;/p&gt;

&lt;p&gt;The new backend is more efficient than the default backend of Scala 2.11, because it directly generates ASM bytecode from Scala compiler trees, while the previous backend used an intermediate representation called &amp;quot;ICode&amp;quot;.&lt;/p&gt;

&lt;h4&gt;Java 8 style closure classes&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body.
At runtime, this method is passed as an argument to the LambdaMetaFactory provided by the JDK, which creates a closure object.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that the compiler does not generate an anonymous class for each lambda anymore.
This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;Lambda syntax for SAM types (experimental)&lt;/h4&gt;

&lt;p&gt;As of M3, this feature is not yet on by default.  You can enable it with the &lt;code&gt;-Xexperimental&lt;/code&gt; compiler option.&lt;/p&gt;

&lt;p&gt;When the option is enabled, then similar to Java 8, Scala 2.12 allows instantiating any type with one single abstract method by passing a lambda.  This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;This feature was also available in Scala 2.11, also via &lt;code&gt;-Xexperimental&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;New tab-completion in the Scala REPL&lt;/h4&gt;

&lt;p&gt;The implementation of tab-completion in the Scala REPL has been rewritten and now uses the same infrastruture as for example the Scala IDE or Ensime. Note that this feature will also be available in 2.11.8.&lt;/p&gt;

&lt;p&gt;There are a number of improvements:
* Reliable completion, also in partial expressions and syntactically incorrect programs: try &lt;code&gt;class C { def f(l: List[Int]) = l.&amp;lt;TAB&amp;gt;&lt;/code&gt;
* CamelCase completion: try &lt;code&gt;(l: List[Int]).rro&amp;lt;TAB&amp;gt;&lt;/code&gt;, it expands to &lt;code&gt;(l: List[Int]).reduceRightOption&lt;/code&gt;
* Show desugarings performed by the compiler by adding &lt;code&gt;//print&lt;/code&gt;: try &lt;code&gt;for (x &amp;lt;- 1 to 10) println(x) //print&amp;lt;TAB&amp;gt;&lt;/code&gt;
* Complete bean getters without typing &lt;code&gt;get&lt;/code&gt;: try &lt;code&gt;(d: java.util.Date).day&amp;lt;TAB&amp;gt;&lt;/code&gt;
* Find members by typing any CamelCased part of the name: try &lt;code&gt;classOf[String].typ&amp;lt;TAB&amp;gt;&lt;/code&gt; to get &lt;code&gt;getAnnotationsByType&lt;/code&gt;, &lt;code&gt;getComponentType&lt;/code&gt; and others
* Complete non-qualified names, including types: try &lt;code&gt;def f(s: Str&amp;lt;TAB&amp;gt;&lt;/code&gt;
* Press tab twice to see the method signature: try &lt;code&gt;List(1,2,3).part&amp;lt;TAB&amp;gt;&lt;/code&gt;, which completes to &lt;code&gt;List(1,2,3).partition&lt;/code&gt;; press tab again to display &lt;code&gt;def partition(p: Int =&amp;gt; Boolean): (List[Int], List[Int])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Thanks to @som-snytt for helping out with this work!&lt;/p&gt;

&lt;h4&gt;New bytecode optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode backend includes a new inliner and bytecode optimizer.
The optimizer is enabled using the &lt;code&gt;-Yopt:l:classpath&lt;/code&gt; compiler option.
Check &lt;code&gt;-Yopt:help&lt;/code&gt; to see the full list of available options for the optimizer.&lt;/p&gt;

&lt;p&gt;As of M3, the following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The work on the new optimizer is still ongoing.  You can track it in the &lt;a href=&quot;https://github.com/scala/scala-dev/labels/t%3Aoptimizer&quot;&gt;scala-dev repository issue tracker&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;The &lt;code&gt;@implicitAmbiguous&lt;/code&gt; annotation&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;@implicitAmbiguous&lt;/code&gt; annotation allows customizing the error message when an implicit search finds multiple ambiguous values. Refer to the &lt;a href=&quot;http://www.scala-lang.org/api/2.12.x/#scala.annotation.implicitAmbiguous&quot;&gt;Scaladoc of the annotation class&lt;/a&gt; for an example.&lt;/p&gt;

&lt;p&gt;Thanks to @puffnfresh for this contribution!&lt;/p&gt;

&lt;h3&gt;Unbundled features&lt;/h3&gt;

&lt;p&gt;The following modules have been removed from the Scala 2.12 distribution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scala standard library actors.
We recommend &lt;a href=&quot;http://akka.io/&quot;&gt;Akka actors&lt;/a&gt; instead.
See the &lt;a href=&quot;http://docs.scala-lang.org/overviews/core/actors-migration-guide.html&quot;&gt;Scala actors migration guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Akka actors.
The Scala distribution and the &lt;code&gt;scala-library-all&lt;/code&gt; dependency no longer include Akka actors.
To use Akka, &lt;a href=&quot;http://doc.akka.io/docs/akka/2.4.0/intro/getting-started.html&quot;&gt;add it as a dependency&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Continuations plugin.
(&lt;a href=&quot;https://github.com/scala/scala-continuations&quot;&gt;Community maintainers sought&lt;/a&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Breaking changes&lt;/h3&gt;

&lt;h4&gt;Changed syntax trees (affects macro and compiler plugin authors)&lt;/h4&gt;

&lt;p&gt;PR &lt;a href=&quot;https://github.com/scala/scala/pull/4749&quot;&gt;#4794&lt;/a&gt; changed the syntax trees for selections of statically accessible symbols. For example, a selection of &lt;code&gt;Predef&lt;/code&gt; no longer has the shape &lt;code&gt;q&amp;quot;scala.this.Predef&amp;quot;&lt;/code&gt; but simply &lt;code&gt;q&amp;quot;scala.Predef&amp;quot;&lt;/code&gt;. Macros and compiler plugins matching on the old tree shape need to be adjusted.&lt;/p&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges 2.11.x..v2.12.0-M3&lt;/code&gt;, 44 people have contributed to Scala 2.12 so far: Lukas Rytz, Jason Zaugg, A. P. Marki, Rex Kerr, Adriaan Moors, Seth Tisue, Kato Kazuyoshi, Rui Gonçalves, Simon Ochsenreither, Max Bileschi, François Garillot, qilab gamma, jxcoder, Masato Sogame, Dominik Gruntz, Simon Schäfer, Kenji Yoshida, Todd Vierling, Viktor Klang, Alexey Romanov, Evgeny Vereshchagin, rubyu, Marc Siegel, dgruntz, Aleksandar Prokopec, Antoine Gourlay, Brian McKenna, Denis Rosset, Denton Cockburn, Erlend Hamnaberg, Eugene Dzhurinsky, Janek Bogucki, Lukas Elmer, Maks Atygaev, Malte Isberner, Nicolas Stucki, Paolo Giarrusso, Roman Hargrave, Shadaj, Steven Scott, Vojin Jovanovic, cchantep, harryhuk, martijnhoekstra. Thank you!&lt;/p&gt;

&lt;p&gt;Thanks also to Miguel Garcia and James Iry for their substantial prior work on the new compiler backend.&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;You can propose edits to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;p&gt;Scala releases are available various ways, such as:&lt;/p&gt;

&lt;!-- re-add for 2.12.0 final?
* Get started with the [Hello Scala 2.12 template](https://typesafe.com/activator/template/hello-scala-2_12) in [Typesafe Activator](https://typesafe.com/platform/getstarted)
--&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-M3.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-M3%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.10.6 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.10.6"/>
    <updated>2015-09-18T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.10.6</id>
    <content type="html">&lt;p&gt;Scala 2.10.6 &lt;a href=&quot;https://github.com/scala/scala/pull/4557&quot;&gt;resolves a license incompatibility in scala.util.Sorting&lt;/a&gt;, but is otherwise identical to Scala 2.10.5. A total of &lt;a href=&quot;https://github.com/scala/scala/pulls?q=milestone%3A2.10.6+is%3Aclosed&quot;&gt;three pending backports&lt;/a&gt; were merged.&lt;/p&gt;

&lt;p&gt;We strongly encourage you to upgrade to the latest stable version of Scala 2.11.x, as the 2.10.x series is no longer actively maintained.&lt;/p&gt;

&lt;!--break--&gt;

&lt;h3&gt;Scala IDE&lt;/h3&gt;

&lt;p&gt;The current release of Scala IDE supports any 2.10.x release, and is available on the &lt;a href=&quot;http://scala-ide.org/download/sdk.html&quot;&gt;download site&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Release Notes for the Scala 2.10 Series&lt;/h3&gt;

&lt;p&gt;The release notes for the Scala 2.10 series, which also apply to the current minor release, are available in the &lt;a href=&quot;http://scala-lang.org/news/2.10.4&quot;&gt;release notes for Scala 2.10.4&lt;/a&gt;. They contain important information such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;li&gt;Details on new features, important changes and deprecations in Scala 2.10.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-M2 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-M2"/>
    <updated>2015-07-14T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-M2</id>
    <content type="html">&lt;p&gt;We are pleased to announce the availability of Scala 2.12.0-M2!&lt;/p&gt;

&lt;p&gt;We would like to highlight the following changes since M1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java 8 is now required.&lt;/li&gt;
&lt;li&gt;Lambdas are compiled to Java 8 style closures.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to M1, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20%3D%20%22Scala%202.12.0-M2%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;9 issues&lt;/a&gt;.  We &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.12.0-M2&quot;&gt;merged 29 pull requests&lt;/a&gt;.
&amp;lt;!-- Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.11.7%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.11.7%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.--&amp;gt;&lt;/p&gt;

&lt;p&gt;As usual for milestones, 2.12.0-M2 is not binary compatible with any other Scala release, including other 2.12 milestones.&lt;/p&gt;

&lt;h2&gt;About Scala 2.12&lt;/h2&gt;

&lt;p&gt;Beginning with 2.12.0-M2, the Scala 2.12 series targets Java 8. Programs written in Scala 2.12, including the Scala 2.12 compiler, can only be executed on Java 8 or newer.&lt;/p&gt;

&lt;h3&gt;Source compatibility&lt;/h3&gt;

&lt;p&gt;Scala 2.12 is mostly source compatible with 2.11.  Code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x too, unless you use experimental APIs such as reflection.  If you find incompatibilities, please &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Binary compatibility&lt;/h3&gt;

&lt;p&gt;Since Scala 2.11, minor releases of Scala are binary compatible with each other.
Scala 2.12 will continue this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Milestone releases and release candidates, however, are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;p&gt;Scala 2.12 is not and will not be binary compatible with the 2.11.x series.  This allows us to keep improving the Scala compiler and standard library.  We are working with the community to ensure that core projects in the Scala eco-system become available for 2.12.  Please refer to this growing &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;list of libraries and frameworks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;Scala 2.11.1 release notes&lt;/a&gt; explain in more detail on how binary compatibility works in Scala.  The same policies that applied to 2.11 will apply to 2.12 as well.&lt;/p&gt;

&lt;h3&gt;New features&lt;/h3&gt;

&lt;p&gt;Future 2.12 milestones will include additional new features. For now, M2 includes the following major changes:&lt;/p&gt;

&lt;h4&gt;New backend&lt;/h4&gt;

&lt;p&gt;Scala 2.12 enables the &amp;quot;GenBCode&amp;quot; backend by default.&lt;/p&gt;

&lt;p&gt;The new backend is more efficient than the default backend of Scala 2.11, because it directly generates ASM bytecode from Scala compiler trees, while the previous backend used an intermediate representation called &amp;quot;ICode&amp;quot;.&lt;/p&gt;

&lt;h4&gt;Java 8 style closure classes&lt;/h4&gt;

&lt;p&gt;Scala 2.12 emits closures in the same style as Java 8.&lt;/p&gt;

&lt;p&gt;For each lambda the compiler generates a method containing the lambda body.
At runtime, this method is passed as an argument to the LambdaMetaFactory provided by the JDK, which creates a closure object.&lt;/p&gt;

&lt;p&gt;Compared to Scala 2.11, the new scheme has the advantage that the compiler does not generate an anonymous class for each lambda anymore.
This leads to significantly smaller JAR files.&lt;/p&gt;

&lt;h4&gt;Lambda syntax for SAM types (experimental)&lt;/h4&gt;

&lt;p&gt;As of M2, this feature is not yet on by default.  You can enable it with the &lt;code&gt;-Xexperimental&lt;/code&gt; compiler option.&lt;/p&gt;

&lt;p&gt;When the option is enabled, then similar to Java 8, Scala 2.12 allows instantiating any type with one single abstract method by passing a lambda.  This improves the experience of using libraries written for Java 8 in Scala.&lt;/p&gt;

&lt;p&gt;This feature was also available in Scala 2.11, also via &lt;code&gt;-Xexperimental&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;New Bytecode Optimizer&lt;/h4&gt;

&lt;p&gt;The GenBCode backend includes a new inliner and bytecode optimizer.
The optimizer is enabled using the &lt;code&gt;-Yopt:l:classpath&lt;/code&gt; compiler option.
Check &lt;code&gt;-Yopt:help&lt;/code&gt; to see the full list of available options for the optimizer.&lt;/p&gt;

&lt;p&gt;As of M2, the following optimizations are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inlining final methods, including methods defined in objects and final methods defined in traits&lt;/li&gt;
&lt;li&gt;If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method&lt;/li&gt;
&lt;li&gt;Dead code elimination and a small number of cleanup optimizations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The work on the new optimizer is still ongoing.  You can track it in the &lt;a href=&quot;https://github.com/scala-opt/scala/issues&quot;&gt;scala-opt repository issue tracker&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Unbundled features&lt;/h3&gt;

&lt;p&gt;The following modules have been removed from the Scala 2.12 distribution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scala standard library actors.
We recommend &lt;a href=&quot;http://akka.io/&quot;&gt;Akka actors&lt;/a&gt; instead.
See the &lt;a href=&quot;http://docs.scala-lang.org/overviews/core/actors-migration-guide.html&quot;&gt;Scala actors migration guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Akka actors.
The Scala distribution and the &lt;code&gt;scala-library-all&lt;/code&gt; dependency no longer include Akka actors.
To use Akka, &lt;a href=&quot;http://doc.akka.io/docs/akka/2.3.11/intro/getting-started.html&quot;&gt;add it as a dependency&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Continuations plugin.
(&lt;a href=&quot;https://github.com/scala/scala-continuations&quot;&gt;Community maintainers sought&lt;/a&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Contributors&lt;/h2&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges 2.11.x..v2.12.0-M2&lt;/code&gt;, 40 people have contributed to Scala 2.12 so far: Lukas Rytz, Jason Zaugg, A. P. Marki, Rex Kerr, Adriaan Moors, Kato Kazuyoshi, Max Bileschi, Rui Gonçalves, jxcoder, François Garillot, rubyu, Dominik Gruntz, Evgeny Vereshchagin, Kenji Yoshida, Marc Siegel, Masato Sogame, Simon Ochsenreither, Todd Vierling, Viktor Klang, Maks Atygaev, dgruntz, harryhuk, Denton Cockburn, Paolo Giarrusso, Denis Rosset, Roman Hargrave, Antoine Gourlay, Seth Tisue, Shadaj, Alexey Romanov, Steven Scott, Tim Vergenz, martijnhoekstra, Aleksandar Prokopec, Janek Bogucki, Eugene Dzhurinsky, cchantep, Lukas Elmer, Erlend Hamnaberg, Malte Isberner. Thank you!&lt;/p&gt;

&lt;p&gt;Thanks also to Miguel Garcia and James Iry for their substantial prior work on the new compiler backend.&lt;/p&gt;

&lt;h2&gt;Release notes&lt;/h2&gt;

&lt;p&gt;You can propose edits to these release notes &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Obtaining Scala&lt;/h2&gt;

&lt;p&gt;Scala releases are available various ways, such as:&lt;/p&gt;

&lt;!-- re-add for 2.12.0 final?
* Get started with the [Hello Scala 2.12 template](https://typesafe.com/activator/template/hello-scala-2_12) in [Typesafe Activator](https://typesafe.com/platform/getstarted)
--&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-M2.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0-M2%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Bill Venners receives community award</title>
    <link href="http://www.scala-lang.org/news/2015/06/25/bagwell-award-2015.html"/>
    <updated>2015-06-25T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/2015/06/25/bagwell-award-2015</id>
    <content type="html">&lt;p&gt;We are pleased to announce that the Phil Bagwell Memorial Scala Community Award for 2015 has been awarded to &lt;a href=&quot;https://twitter.com/bvenners&quot;&gt;Bill Venners&lt;/a&gt;.  The award was presented in Amsterdam at the outset of &lt;a href=&quot;http://event.scaladays.org/scaladays-amsterdam-2015&quot;&gt;Scala Days&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bill is known to Scala users as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;creator of &lt;a href=&quot;http://scalatest.org&quot;&gt;ScalaTest&lt;/a&gt;, a popular open-source test framework first &lt;a href=&quot;http://www.artima.com/weblogs/viewpost.jsp?thread=222678&quot;&gt;released in 2008&lt;/a&gt;, as well as other tools and libraries such as &lt;a href=&quot;http://www.scalactic.org&quot;&gt;Scalactic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;co-author of the first Scala book, &lt;a href=&quot;http://www.artima.com/shop/programming_in_scala_3ed&quot;&gt;&lt;em&gt;Programming in Scala&lt;/em&gt;&lt;/a&gt; (Artima)&lt;/li&gt;
&lt;li&gt;founder of &lt;a href=&quot;http://www.artima.com/aboutartima.html&quot;&gt;Artima&lt;/a&gt;, which continues to publish &lt;a href=&quot;http://www.artima.com/shop/catalog&quot;&gt;Scala-themed books&lt;/a&gt;, and hosted Scala-themed blogs and forums which were important in spreading the news about Scala in its early years&lt;/li&gt;
&lt;li&gt;friendly and tireless conference-goer, presenter, and trainer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Bagwell Award is named in honor of Phil Bagwell, who passed away in 2012.  In a &lt;a href=&quot;https://www.typesafe.com/blog/rip-phil-bagwell&quot;&gt;2012 blog post&lt;/a&gt;, Martin Odersky remembers Phil and his special place in the Scala community.&lt;/p&gt;

&lt;p&gt;Past winners of the award:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2014: &lt;a href=&quot;https://kojoenv.wordpress.com/2014/09/27/phil-bagwell-award/&quot;&gt;Lalit Pant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013: &lt;a href=&quot;https://twitter.com/dickwall&quot;&gt;Dick Wall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.11.7 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.11.7"/>
    <updated>2015-06-23T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.11.7</id>
    <content type="html">&lt;p&gt;We are very pleased to announce the availability of Scala 2.11.7!&lt;/p&gt;

&lt;p&gt;We would like to highlight the following changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exhaustivity checking for pattern matching is now much snappier &amp;mdash; thank you @gbasler! (&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9181&quot;&gt;SI-9181&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;A 300x more embeddable Scala REPL, brought to you by a team effort with Apache Spark. Thank you @ScrapCodes, @retronym &amp;amp; co! (&lt;a href=&quot;https://github.com/scala/scala/pull/4548&quot;&gt;#4548&lt;/a&gt;, &lt;a href=&quot;https://github.com/scala/scala/pull/4563&quot;&gt;#4563&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Scala also &amp;lt;3 INDYs -- experiment with all our favorite new Java 8 features &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.11.x/experimental-backend.md&quot;&gt;as follows&lt;/a&gt; and get an exclusive sneak preview of 2.12.0-M2!&lt;/li&gt;
&lt;li&gt;Oh, and &lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.11/&quot;&gt;the spec&lt;/a&gt; is now much spiffier! Thanks, @soc!&lt;/li&gt;
&lt;/ul&gt;

&lt;!--break--&gt;

&lt;p&gt;Compared to 2.11.6, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.11.7%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;53 issues&lt;/a&gt;.  We &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.7&quot;&gt;merged 124 pull requests&lt;/a&gt; (out of 157).  Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.11.7%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.11.7%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.&lt;/p&gt;

&lt;p&gt;As usual for minor releases, Scala 2.11.7 is binary compatible with other releases in the Scala 2.11 series.&lt;/p&gt;

&lt;p&gt;The quarterly release schedule will continue for 2.11.x until the end of this year, and a few more quarters into 2016.&lt;/p&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.11.6..v2.11.7&lt;/code&gt;, 36 people contributed to this minor release: Lukas Rytz, Jason Zaugg, A. P. Marki, Grzegorz Kossakowski, Adriaan Moors, Rex Kerr, Simon Ochsenreither, Antoine Gourlay, Gérard Basler, Zhong Sheng, Kato Kazuyoshi, Michał Pociecha, Janek Bogucki, vsalvis, Prashant Sharma, Daniel Dietrich, Kenji Yoshida, YawarRaza7349, Simon Schäfer, Eugene Burmako, Guillaume Martres, Sean Riggin, Christoph Neijenhuis, Szabolcs Berecz, Bruno Bieth, dumpstate, esfandiar amirrahimi, nafg, swaldman, Alessandro Lacava, Geoffrey Knauth, Jean-Rémi Desjardins, EECOLOR, Niko Vuokko, Cody Allen, RobertZK. Thank you!&lt;/p&gt;

&lt;h3&gt;Obtaining Scala&lt;/h3&gt;

&lt;p&gt;Scala releases are available through a variety of channels, including (but not limited to):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get started with the &lt;a href=&quot;https://typesafe.com/activator/template/hello-scala-2_11&quot;&gt;Hello Scala 2.11 template&lt;/a&gt; in &lt;a href=&quot;https://typesafe.com/platform/getstarted&quot;&gt;Typesafe Activator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.11.7.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bump the &lt;code&gt;scalaVersion&lt;/code&gt; setting in your SBT-based project&lt;/li&gt;
&lt;li&gt;Obtain JARs via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.7%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Scala 2.11 Notes&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;release notes for Scala 2.11.1&lt;/a&gt; have important information applicable to the whole 2.11 series, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Details on new features, important changes and deprecations since Scala 2.10.&lt;/li&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.12.0-M1 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.12.0-M1"/>
    <updated>2015-05-05T00:00:00+01:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.12.0-M1</id>
    <content type="html">&lt;p&gt;We are very pleased to announce the release of Scala 2.12.0-M1!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.12.0-M1.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Obtain it via &lt;a href=&quot;http://search.maven.org/?search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.0%22#search%7Cga%7C1%7Cg%3Aorg.scala-lang%20AND%20v%3A2.12.0-M1&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x (we do not guarantee this for experimental APIs, such as reflection).
If not, &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;please file an issue&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We are working with the community to ensure availability of the core projects of the Scala 2.12 eco-system.
This release is &lt;em&gt;not&lt;/em&gt; binary compatible with the 2.11.x series, to allow us to keep improving the Scala standard library.&lt;/p&gt;

&lt;p&gt;The Scala 2.12 series targets Java 8.
Programs written in Scala 2.12, including the Scala 2.12 compiler, can only be executed on Java 8 or newer.
Note that the current milestone release (2.12.0-M1) still targets Java 6.&lt;/p&gt;

&lt;h3&gt;New Features in the 2.12 Series&lt;/h3&gt;

&lt;p&gt;Scala 2.12 contains all of the bug fixes and improvements made in the 2.11 series.&lt;/p&gt;

&lt;p&gt;At the current stage in the milestone cycle, Scala 2.12 is still very similar to Scala 2.11.&lt;/p&gt;

&lt;p&gt;The following changes are planned for Scala 2.12:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java 8 style closures.
The Scala compiler will emit closure classes (lambdas) in the same manner as Java 8.
The design notes for this feature are available in &lt;a href=&quot;https://gist.github.com/retronym/0178c212e4bacffed568&quot;&gt;this gist&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Lambda syntax for SAM types.
Similar to Java 8, Scala 2.12 allows instantiating any type with one single abstract method by passing a lambda.
This feature is already avalable in Scala 2.11 using the &lt;code&gt;-Xexperimental&lt;/code&gt; compiler option.
It improves the experience of using libraries written for Java 8 in Scala.&lt;/li&gt;
&lt;li&gt;New backend and optimizer.
The &amp;quot;GenBCode&amp;quot; backend, which is already available in Scala 2.11 using the &lt;code&gt;-Ybackend:GenBCode&lt;/code&gt; compiler option, will be enabled by default.
Scala 2.12 will also ship with a new inliner and bytecode optimizer.
We keep track of issues and work items for the new optimizer on the &lt;a href=&quot;https://github.com/scala-opt/scala/issues&quot;&gt;scala-opt repository issue tracker&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above list is incomplete and will be extended during the Scala 2.12 milestone cycle.&lt;/p&gt;

&lt;p&gt;Up the current milestone, the Scala team and contributors &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9200?jql=project%20%3D%20SI%20and%20fixVersion%20%3E%3D%20%222.12.0-M1%22%20and%20fixVersion%20%3C%3D%20%222.12.0%22%20and%20resolution%20%3D%20fixed&quot;&gt;fixed 47 bugs&lt;/a&gt; that are exclusive to Scala 2.12.0.
During the development cycle of Scala 2.12, we will continue to backport issues to 2.11 whenever feasible.
With the release of 2.12.0, backports to 2.11 will be dialed back.&lt;/p&gt;

&lt;!-- Notes from 2.11.0
#### Important Changes

For most cases, code that compiled under 2.10.x without deprecation warnings should not be affected. We&#39;ve verified this by [compiling](https://jenkins-dbuild.typesafe.com:8499/job/Community-2.11.x) a [sizeable number of open source projects](https://github.com/typesafehub/community-builds/blob/master/common-2.11.x.conf#L43).

Changes to the reflection API may cause breakages...

We&#39;ve decided to fix the following more obscure deviations from specified behavior without deprecating them first.

* [SI-4577](https://issues.scala-lang.org/browse/SI-4577) Compile `x match { case _ : Foo.type =&gt; }` to `Foo eq x`, as specified. It used to be `Foo == x` (without warning). If that&#39;s what you meant, write `case Foo =&gt;`.
* ...

The following changes were made after a deprecation cycle

* [SI-6809](https://issues.scala-lang.org/browse/SI-6809) Case classes without a parameter list are no longer allowed.
* ...

Finally, some notable improvements and bug fixes:

* [SI-7296](https://issues.scala-lang.org/browse/SI-7296) Case classes with &gt; 22 parameters are now allowed.
*...


#### Deprecations

The following language &quot;warts&quot; have been deprecated:
* [#3746](https://github.com/scala/scala/pull/3746) Generation of bean info classes using the `@BeanInfo` annotation.
Deprecation is closely linked to source and binary compatibility. We say two versions are source compatible when they compile the same programs with the same results. Deprecation requires qualifying this statement: &quot;assuming there are no deprecation warnings&quot;. This is what allows us to evolve the Scala platform and keep it healthy. We move slowly to guarantee smooth upgrades, but we want to keep improving as well!
--&gt;

&lt;h4&gt;Removed Modules&lt;/h4&gt;

&lt;p&gt;The following modules have been removed from the Scala 2.12 distribution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Scala actors library is no longer released with Scala 2.12.
We recommend that you use the &lt;a href=&quot;http://akka.io/&quot;&gt;Akka actors library&lt;/a&gt; instead.
To migrate your code, follow the &lt;a href=&quot;http://docs.scala-lang.org/overviews/core/actors-migration-guide.html&quot;&gt;Scala actors migration guide&lt;/a&gt; before upgrading your project to Scala 2.12.&lt;/li&gt;
&lt;li&gt;The Scala distribution archives and the &lt;code&gt;scala-library-all&lt;/code&gt; maven dependency no longer inlcude Akka actors.
To use the Akka actors library, add it to your project &lt;a href=&quot;http://doc.akka.io/docs/akka/2.3.10/intro/getting-started.html&quot;&gt;as a dependency&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The continuations plugin is no longer shipped with the Scala 2.12 distribution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Contributors&lt;/h4&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests!
You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges 2.11.x..v2.12.0-M1&lt;/code&gt;, 33 people contributed to this major release:
Jason Zaugg, Lukas Rytz, A. P. Marki, Rex Kerr, Kato Kazuyoshi, Max Bileschi, jxcoder, François Garillot, rubyu, Adriaan Moors, Dominik Gruntz, Evgeny Vereshchagin, Marc Siegel, Masato Sogame, Simon Ochsenreither, Todd Vierling, Viktor Klang, cchantep, Denton Cockburn, Paolo Giarrusso, Denis Rosset, Roman Hargrave, Rui Gonçalves, Shadaj, harryhuk, Steven Scott, Antoine Gourlay, Aleksandar Prokopec, Lukas Elmer, Erlend Hamnaberg, Maks Atygaev, Malte Isberner, dgruntz.
Thank you!&lt;/p&gt;

&lt;p&gt;These release notes are &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md&quot;&gt;hosted on GitHub&lt;/a&gt; and are continuously updated during the Scala 2.12.0 release cycle.
You are kindly invited to contribute!&lt;/p&gt;

&lt;h3&gt;Reporting Bugs&lt;/h3&gt;

&lt;p&gt;Please file any bugs you encounter on &lt;a href=&quot;https://issues.scala-lang.org&quot;&gt;our issue tracker&lt;/a&gt;.
If you&amp;#39;re unsure whether something is a bug, please contact the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/scala-user&quot;&gt;scala-user&lt;/a&gt; mailing list.
Before creating a new issue, search search the issue tracker to see if your bug has already been reported.&lt;/p&gt;

&lt;h3&gt;Scala IDE for Eclipse&lt;/h3&gt;

&lt;p&gt;A release of the Scala IDE for Eclipse for Scala 2.12 will be available together with the release.&lt;/p&gt;

&lt;p&gt;Note that for the current milestone (2.12.0-M1), the Scala IDE is not yet available.&lt;/p&gt;

&lt;!-- Notes from 2.11.0
The Scala IDE with this release built in is [available from this update site](http://download.scala-ide.org/sdk/helium/e38/scala211/stable/site/) for [Eclipse 4.2/4.3 (Juno/Kepler)](http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/keplersr2). Please have a look at the [getting started guide](http://scala-ide.org/docs/user/gettingstarted.html) for more info.
--&gt;

&lt;h3&gt;Available Projects&lt;/h3&gt;

&lt;p&gt;Please refer to the list of &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md&quot;&gt;libraries and frameworks available for Scala 2.12&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Binary Compatibility&lt;/h3&gt;

&lt;p&gt;Since Sala 2.11, minor releases of Scala are binary compatible.
Scala 2.12 continues this tradition: every 2.12.x release will be binary compatible with 2.12.0.
Note that milestone releases and release candidates are &lt;strong&gt;not&lt;/strong&gt; binary compatible with any other release.&lt;/p&gt;

&lt;h4&gt;Definition&lt;/h4&gt;

&lt;p&gt;When two versions of Scala are binary compatible, it is safe to compile your project on one Scala version and link against another Scala version at run time.
Safe run-time linkage (only!) means that the JVM does not throw a (subclass of) &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/LinkageError.html&quot;&gt;&lt;code&gt;LinkageError&lt;/code&gt;&lt;/a&gt; when executing your program in the mixed scenario, assuming that none arise when compiling and running on the same version of Scala.
Concretely, this means you may have external dependencies on your run-time classpath that use a different version of Scala than the one you&amp;#39;re compiling with, as long as they&amp;#39;re binary compatibile.
In other words, separate compilation on different binary compatible versions does not introduce problems compared to compiling and running everything on the same version of Scala.&lt;/p&gt;

&lt;p&gt;We check binary compatibility automatically with &lt;a href=&quot;https://github.com/typesafehub/migration-manager&quot;&gt;MiMa&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Forwards and Back&lt;/h4&gt;

&lt;p&gt;We distinguish forwards and backwards compatibility (think of these as properties of a sequence of versions, not of an individual version).
Maintaining backwards compatibility means code compiled on an older version will link with code compiled with newer ones.
Forwards compatibility allows you to compile on new versions and run on older ones.&lt;/p&gt;

&lt;p&gt;Thus, backwards compatibility precludes the removal of (non-private) methods, as older versions could call them, not knowing they would be removed, whereas forwards compatibility disallows adding new (non-private) methods, because newer programs may come to depend on them, which would prevent them from running on older versions (private methods are exempted here as well, as their definition and call sites must be in the same compilation unit).&lt;/p&gt;

&lt;h4&gt;Meta&lt;/h4&gt;

&lt;p&gt;Note that so far we&amp;#39;ve only talked about the jars generated by scalac for the standard library and reflection.
Our policies do not extend to the meta-issue: ensuring binary compatibility for bytecode generated from identical sources, by different version of scalac?
(The same problem exists for compiling on different JDKs.)
While we strive to achieve this, it&amp;#39;s not something we can test in general.
Notable examples where we know meta-binary compatibility is hard to achieve: specialisation and the optimizer.&lt;/p&gt;

&lt;p&gt;In short, if binary compatibility of your library is important to you, use &lt;a href=&quot;https://github.com/typesafehub/migration-manager&quot;&gt;MiMa&lt;/a&gt; to verify compatibility before releasing.
Compiling identical sources with different versions of the Scala compiler (or on different JVM versions!) could result in binary incompatible bytecode.
This is rare, and we try to avoid it, but we can&amp;#39;t guarantee it will never happen.&lt;/p&gt;

&lt;h4&gt;Concretely&lt;/h4&gt;

&lt;p&gt;We guarantee forwards and backwards compatibility of the &lt;code&gt;&amp;quot;org.scala-lang&amp;quot; % &amp;quot;scala-library&amp;quot; % &amp;quot;2.12.x&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;org.scala-lang&amp;quot; % &amp;quot;scala-reflect&amp;quot; % &amp;quot;2.12.x&amp;quot;&lt;/code&gt; artifacts, except for anything under the &lt;code&gt;scala.reflect.internal&lt;/code&gt; package, as scala-reflect is still experimental.
We also strongly discourage relying on the stability of &lt;code&gt;scala.concurrent.impl&lt;/code&gt; and &lt;code&gt;scala.reflect.runtime&lt;/code&gt;, though we will only break compatibility for severe bugs here.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Google Summer of Code 2015</title>
    <link href="http://www.scala-lang.org/news/2015/03/16/GSoC-projects.html"/>
    <updated>2015-03-16T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/2015/03/16/GSoC-projects</id>
    <content type="html">&lt;p&gt;&lt;strong&gt;This year the Scala team applied again for
&lt;a href=&quot;http://www.google-melange.com/gsoc/homepage/google/gsoc2015&quot;&gt;Google Summer of Code&lt;/a&gt;,
and we&amp;#39;re happy to announce that we have been approved to be mentoring organization!
Students can &lt;a href=&quot;http://www.google-melange.com/gsoc/homepage/google/gsoc2015&quot;&gt;apply&lt;/a&gt; for 
&lt;a href=&quot;http://scala-lang.org/gsoc/2015.html&quot;&gt;projects&lt;/a&gt; until 27th of March!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.11.6 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.11.6"/>
    <updated>2015-03-05T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.11.6</id>
    <content type="html">&lt;p&gt;We are very pleased to announce the availability of Scala 2.11.6!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get started with the &lt;a href=&quot;https://typesafe.com/activator/template/hello-scala-2_11&quot;&gt;Hello Scala 2.11 template&lt;/a&gt; in &lt;a href=&quot;https://typesafe.com/platform/getstarted&quot;&gt;Typesafe Activator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.11.6.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Obtain it via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.6%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scala 2.11.6 is a bugfix release that is binary compatible with previous releases in the Scala 2.11 series. We would like to highlight the following changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We &lt;a href=&quot;https://github.com/scala/scala/pull/4351&quot;&gt;fixed a cross-site scripting vulnerability&lt;/a&gt; in Scaladoc&amp;#39;s JavaScript. Many thanks to @todesking for discovering this, suggesting a fix, and for delaying disclosure until this release! This bug could be used to access sensitive information on sites hosted on the same domain as Scaladoc-generated documentation. All previous versions of Scaladoc are affected (Scala 2.10.5 includes the fix as well). We do recommend, as a general precaution, to host Scaladoc documentation on its own domain.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9089&quot;&gt;SI-9089&lt;/a&gt; repl is now much less crash-and-burny when calling a function (which turns out to be a common thing people do in a REPL). Also, apologies to the author of &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9022&quot;&gt;SI-9022&lt;/a&gt;, who &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9022#comment-71996&quot;&gt;reported this before the bug was discovered and you had to wait in line for like three hours on a Tuesday afternoon&lt;/a&gt;. Or, maybe, that honor should go to the enigmatic &lt;a href=&quot;http://stackoverflow.com/questions/27213616/why-specialized-annotation-doesnt-work-for-asinstanceof/27221875&quot;&gt;dk14&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8759&quot;&gt;SI-8759&lt;/a&gt; no need to enter almost half the konami code to enter a right square bracket in the REPL (via &lt;a href=&quot;https://github.com/jline/jline2/pull/175&quot;&gt;jline 2.12.1&lt;/a&gt;). Thank you for implementing the jline fix, @michael72, and kudos to @jdillon and @trptcolin for cutting a new jline release just for us!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to 2.11.5, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.11.6%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;38 issues&lt;/a&gt;. Out of 100, we &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.6&quot;&gt;merged 58 pull requests&lt;/a&gt;. Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.11.6%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.11.6%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.&lt;/p&gt;

&lt;p&gt;In 2015, 2.11 minor releases will be released quarterly, or sooner if prompted by a serious issue.&lt;/p&gt;

&lt;h3&gt;Scala IDE&lt;/h3&gt;

&lt;p&gt;The current release of Scala IDE includes Scala 2.11.6 is available on the &lt;a href=&quot;http://scala-ide.org/download/sdk.html&quot;&gt;download site&lt;/a&gt; (or as an update to version 4.0 of the plugin).&lt;/p&gt;

&lt;h3&gt;Available Libraries and Frameworks&lt;/h3&gt;

&lt;p&gt;A large number of Scala projects have been released against Scala 2.11. Please refer to the list of &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.11.x/projects-2.11.md&quot;&gt;libraries and frameworks available for Scala 2.11&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Reminder: Do Not Use Scala 2.11.3&lt;/h3&gt;

&lt;p&gt;Due to a &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8899&quot;&gt;binary incompatibility&lt;/a&gt; in Scala 2.11.3, we recommend upgrading to Scala 2.11.6, which resolves the incompatibility, as well as another &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8900&quot;&gt;blocker issue&lt;/a&gt; that was discovered in the days after the 2.11.3 release.&lt;/p&gt;

&lt;p&gt;We have &lt;a href=&quot;https://groups.google.com/d/msg/scala-internals/SSD9BNJaFbU/rACBkHrs2JEJ&quot;&gt;analyzed&lt;/a&gt; the mistakes that lead to the breakage (human error), and are taking measures to prevent this from happening again. We apologize for the inconvenience, and thank everyone who was involved in reporting and diagnosing these critical issues.&lt;/p&gt;

&lt;h3&gt;Release Notes for the Scala 2.11 Series&lt;/h3&gt;

&lt;p&gt;The release notes for the Scala 2.11 series, which also apply to the current minor release, are available in the &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;release notes for Scala 2.11.1&lt;/a&gt;. They contain important information such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;li&gt;Details on new features, important changes and deprecations in Scala 2.11.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.11.5..v2.11.6&lt;/code&gt;, 25 people contributed to this minor release:
Jason Zaugg, Adriaan Moors, Lukas Rytz, A. P. Marki, Denton Cockburn, Rex Kerr, mpociecha, Aleksandar Prokopec, Jan Bessai, Eugene Burmako, JustinPihony, Kornel Kielczewski, Krzysztof Romanowski, Eric Peters, Lyle Kopnicky, Mark Zitnik, Michael Pigg, Miles Sabin, BartekJanota, Simon Ochsenreither, Sébastien Doeraene, Viktor Klang, dickwall, jhegedus42, and Ikumi Shimizu. Thank you!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.10.5 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.10.5"/>
    <updated>2015-03-05T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.10.5</id>
    <content type="html">&lt;p&gt;With pride and a pang of nostalgia, we announce the availability of Scala 2.10.5 -- the last release in the 2.10.x series.&lt;/p&gt;

&lt;p&gt;We&amp;#39;d like to encourage you to upgrade to 2.11.6 as soon as possible. (Please note that this announcement does not affect Typesafe&amp;#39;s commercial support offering.)&lt;/p&gt;

&lt;p&gt;Scala 2.10.5 is the final maintenance release in this series, and is binary compatible with previous releases in the Scala 2.10 series. We would like to highlight the following change:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We &lt;a href=&quot;https://github.com/scala/scala/pull/4351&quot;&gt;fixed a cross-site scripting vulnerability&lt;/a&gt; in Scaladoc&amp;#39;s JavaScript. Many thanks to @todesking for discovering this, suggesting a fix, and for delaying disclosure until this release! This bug could be used to access sensitive information on sites hosted on the same domain as Scaladoc-generated documentation. All previous versions of Scaladoc are affected (Scala 2.11.6 includes the fix as well). We do recommend, as a general precaution, to host Scaladoc documentation on its own domain.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to 2.10.4, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.10.5%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;10 issues&lt;/a&gt;. Out of 23, we &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.10.5&quot;&gt;merged 18 pull requests&lt;/a&gt;. Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.10.5%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.10.5%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.&lt;/p&gt;

&lt;h3&gt;Scala IDE&lt;/h3&gt;

&lt;p&gt;The current release of Scala IDE supports any 2.10.x release, and is available on the &lt;a href=&quot;http://scala-ide.org/download/sdk.html&quot;&gt;download site&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Changes since 2.10.4&lt;/h3&gt;

&lt;h4&gt;Library&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7710&quot;&gt;SI-7710&lt;/a&gt; fix memory performance of RegexParsers in jdk7u6+  (&lt;a href=&quot;https://github.com/scala/scala/commit/fceae7084c&quot;&gt;fceae7084c&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8589&quot;&gt;SI-8589&lt;/a&gt; Performance improvement for ArrayCharSequence.toString  (&lt;a href=&quot;https://github.com/scala/scala/commit/099a426dd6&quot;&gt;099a426dd6&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8689&quot;&gt;SI-8689&lt;/a&gt; Avoid internal error in Promise after sequence of completions  (&lt;a href=&quot;https://github.com/scala/scala/commit/bf20737faa&quot;&gt;bf20737faa&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8787&quot;&gt;SI-8787&lt;/a&gt; Backport Regex doc  (&lt;a href=&quot;https://github.com/scala/scala/commit/887622759d&quot;&gt;887622759d&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;XML Support&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-4339&quot;&gt;SI-4339&lt;/a&gt; Event errors and attribute fix (&lt;a href=&quot;https://github.com/scala/scala/commit/fe7867f8a7&quot;&gt;fe7867f8a7&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9027&quot;&gt;SI-9027&lt;/a&gt; xml parser fix (&lt;a href=&quot;https://github.com/scala/scala/commit/736293ab09&quot;&gt;736293ab09&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-9060&quot;&gt;SI-9060&lt;/a&gt; Backpatch fifth-edition names (&lt;a href=&quot;https://github.com/scala/scala/commit/b4e3becbf3&quot;&gt;b4e3becbf3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Compiler&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7753&quot;&gt;SI-7753&lt;/a&gt; substitution broken for dependent types (&lt;a href=&quot;https://github.com/scala/scala/commit/2f5ff595fd&quot;&gt;2f5ff595fd&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7756&quot;&gt;SI-7756&lt;/a&gt; Uncripple refchecks in case bodies (&lt;a href=&quot;https://github.com/scala/scala/commit/0022dccfde&quot;&gt;0022dccfde&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8442&quot;&gt;SI-8442&lt;/a&gt; Ignore stub annotation symbols in &lt;code&gt;AnnotationInfo#matches&lt;/code&gt; (&lt;a href=&quot;https://github.com/scala/scala/commit/8262ed2fc6&quot;&gt;8262ed2fc6&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8596&quot;&gt;SI-8596&lt;/a&gt; Fix rangepos crasher with defaults, poly methods (&lt;a href=&quot;https://github.com/scala/scala/commit/d288790429&quot;&gt;d288790429&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Scaladoc&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8479&quot;&gt;SI-8479&lt;/a&gt; Fix constructor default args under scaladoc (&lt;a href=&quot;https://github.com/scala/scala/commit/c4561c1d49&quot;&gt;c4561c1d49&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Scaladoc js location synch more robust (&lt;a href=&quot;https://github.com/scala/scala/commit/f95b5b9b80&quot;&gt;f95b5b9b80&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Macros/Reflection&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7470&quot;&gt;SI-7470&lt;/a&gt; implements fundep materialization (&lt;a href=&quot;https://github.com/scala/scala/commit/0c5dd9e02f&quot;&gt;0c5dd9e02f&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8196&quot;&gt;SI-8196&lt;/a&gt; Runtime reflection robustness for STATIC impl details (&lt;a href=&quot;https://github.com/scala/scala/commit/7b72f95a9e&quot;&gt;7b72f95a9e&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;-Xfundep-materialization =&amp;gt; -Yfundep-materialization (&lt;a href=&quot;https://github.com/scala/scala/commit/5966a11ae1&quot;&gt;5966a11ae1&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;transformers no longer ignore UnApply.fun (&lt;a href=&quot;https://github.com/scala/scala/commit/36379cf8af&quot;&gt;36379cf8af&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;no longer warns on calls to vampire macros (&lt;a href=&quot;https://github.com/scala/scala/commit/db300d4d9e&quot;&gt;db300d4d9e&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;typecheck(q&amp;quot;class C&amp;quot;) no longer crashes (&lt;a href=&quot;https://github.com/scala/scala/commit/3314d76ceb&quot;&gt;3314d76ceb&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Release Notes for the Scala 2.10 Series&lt;/h3&gt;

&lt;p&gt;The release notes for the Scala 2.10 series, which also apply to the current minor release, are available in the &lt;a href=&quot;http://scala-lang.org/news/2.10.4&quot;&gt;release notes for Scala 2.10.4&lt;/a&gt;. They contain important information such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;li&gt;Details on new features, important changes and deprecations in Scala 2.10.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, spreading kindness in mailing lists and other public fora, and submitting and reviewing pull requests! You are all magnificent.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.10.4..v2.10.5&lt;/code&gt;, the following people contributed to this minor release:
Jason Zaugg, Eugene Burmako, A. P. Marki, Adriaan Moors, Grzegorz Kossakowski, Antoine Gourlay, Jeroen ter Voorde, Kato Kazuyoshi, Miles Sabin, and Viktor Klang. Thank you!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala.js no longer experimental</title>
    <link href="http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html"/>
    <updated>2015-02-05T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental</id>
    <content type="html">&lt;p&gt;Today, we &lt;a href=&quot;http://www.scala-js.org/news/2015/02/05/announcing-scalajs-0.6.0/&quot;&gt;announced the release of Scala.js v0.6.0&lt;/a&gt;, the Scala to JavaScript compiler, and dropped the experimental flag associated to it.
Yes, you read it right: Scala.js is no longer experimental!
After exactly 2 years of development, we finally feel comfortable calling it production-ready.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note, however, that Scala.js is not part of the Typesafe Reactive platform.
Thus, although we consider Scala.js production-ready, Typesafe does not provide any commercial support for it.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;More than a compiler, an entire ecosystem&lt;/h2&gt;

&lt;p&gt;At its core, Scala.js is a compiler from Scala to JavaScript.
It compiles &lt;code&gt;.scala&lt;/code&gt; files to a single optimized and minimized &lt;code&gt;.js&lt;/code&gt; file per application.
The resulting JavaScript code is vanilla ECMAScript 5.1, which therefore works everywhere – on any OS, any browser, or even on Node.js.
Just like regular Scala, you get all the powerful language features that you know and love: type inference, classes, traits and objects, pattern matching, the collections library, implicits, etc.
And, in the same way that Scala is fully interoperable with Java, Scala.js is fully interoperable with JavaScript. Scala.js can interoperate with JavaScript either in a statically or dynamically-typed way.&lt;/p&gt;

&lt;p&gt;While that all sounds great, a compiler would be nothing without an ecosystem of libraries and tools. Scala.js has that covered too!&lt;/p&gt;

&lt;p&gt;You can use your favorite IDE to develop in Scala.js, and from experience, we can report that IntelliJ IDEA and Eclipse both provide a flawless development experience. Other editors should also work well.
With Scala.js tooling, you get syntax highlighting, code completion (even for JavaScript libraries and the DOM!), jump-to-definition, and most other features you come to expect in a Scala tooling environment.
After all, &lt;em&gt;Scala.js is just Scala&lt;/em&gt;.
Though, your IDE won&amp;#39;t be able to run or debug Scala.js code. For that, you can use a browser, and you can even step through your Scala code because Scala.js emits &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Building Scala.js libraries and applications is easy –  there is an sbt plugin, which gives you the same comfort and development speed as with Scala on the JVM.
It can even run unit tests automatically with either Rhino, Node.js or PhantomJS, according to your needs.&lt;/p&gt;

&lt;p&gt;Scala.js also has a growing ecosystem of libraries, which you can depend on through Maven dependencies (&lt;code&gt;libraryDependencies&lt;/code&gt; in sbt).
They cover UI frameworks, statically-typed client-server communication, reactive extensions, and so on.
Several popular Scala community libraries such as Shapeless and Scalaz cross-compile with Scala.js.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;#39;re proud that Scala.js has a thriving community of nice and helpful people.
Ask questions &lt;a href=&quot;http://stackoverflow.com/questions/tagged/scala.js&quot;&gt;on StackOverflow&lt;/a&gt;, discuss &lt;a href=&quot;https://groups.google.com/forum/#!forum/scala-js&quot;&gt;on the mailing list&lt;/a&gt;, and discuss with us &lt;a href=&quot;https://gitter.im/scala-js/scala-js&quot;&gt;in the Gitter chat room&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Why Scala.js is awesome&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ve asked developers who use Scala.js daily why they think Scala.js is awesome.
Here is a distilled version of what they have answered, in decreasing order of how many people mentioned it.
You can read &lt;a href=&quot;https://groups.google.com/forum/#!topic/scala-js/_1Sfb5Nj08w&quot;&gt;the entire discussion on the mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;5 Share code between client and server&lt;/li&gt;
&lt;li&gt;4 Strong typing, including for JavaScript libraries&lt;/li&gt;
&lt;li&gt;4 Tooling: IDE support, sbt integration, dependency, unit testing, stack traces and source maps, cross-compiling projects&lt;/li&gt;
&lt;li&gt;4 Portability: bring Scala to environments powered by JavaScript, most importantly the browsers, but also others, such as the brand new &lt;a href=&quot;https://www.youtube.com/watch?v=KVZ-P-ZI6W4&quot;&gt;React Native&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3 Integration with JavaScript&lt;/li&gt;
&lt;li&gt;2 Fast compilation cycle (wrt other compile-to-JS options such as GWT)&lt;/li&gt;
&lt;li&gt;2 Statically-checked client-server RPC with Autowire&lt;/li&gt;
&lt;li&gt;2 The Scala Standard library&lt;/li&gt;
&lt;li&gt;2 It&amp;#39;s not a toy&lt;/li&gt;
&lt;li&gt;2 Great community, welcoming to new users and helpful&lt;/li&gt;
&lt;li&gt;1 Very good documentation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are also a few selected quotes from the mailing list discussion.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;#39;s mostly about the strong typing for me.
Nothing revolutionary about that idea, but it&amp;#39;s just as true on the client as on the server:
having the compiler type-check your code makes it &lt;em&gt;much&lt;/em&gt; quicker to get complex, sophisticated systems up and running.&lt;/p&gt;

&lt;p&gt;Also, having the same language, end-to-end, is fabulous.
[...]
With Scala.js, for the first time ever, I have a single solid, strongly-typed language that I can use throughout the system -- from the fiddly details of the UI, through the API definitions and the front-end web server, to the Akka middleware and the database back end.
That&amp;#39;s really kind of amazing.
It is also why I personally think Scala.js is the killer app for Scala as a language.
-- &lt;cite&gt;Justin du Cœur&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In a lot of ways, Scala.js frees your Scala code from the confines of the headless Linux server that it&amp;#39;s been running on for years.
Scala might be a nice language, but you&amp;#39;ve never been able to use it to make anything cool that a non-backend-systems person would understand.
[...]
With Scala.js, you can easily create small Scala applications and email the tiny 100kb executables (or just the link to them) to anyone, who can run them on any modern device, even smartphones.
Made a cute game? A fun visualization? An animated sequence? Now you can show the world.&lt;/p&gt;

&lt;p&gt;Scala&amp;#39;s no longer just for distributed systems people and type-theorists!
-- &lt;cite&gt;Li Haoyi&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Before Scala.js I did investigate using &lt;a href=&quot;http://opalang.org/&quot;&gt;Opa&lt;/a&gt; as another approach to get &amp;quot;End-to-End&amp;quot; type safety.
The problem I had there was that to do JavaScript interop, I had to drop down from Opa into Ocaml and write out manual bindings to the JavaScript library I wanted to use.
Scala.js&amp;#39; approach is infinitely better.
Despite how much better I think typed libraries are, that does not negate the fact that there are good and useful JS libraries out there, and the ability to &amp;quot;hack&amp;quot; it into Scala.js code effortlessly with &lt;code&gt;js.Dynamic&lt;/code&gt; or add a typed facade if desired is fantastic.
-- &lt;cite&gt;Nick Childers&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have done some work with &lt;a href=&quot;http://www.gwtproject.org/&quot;&gt;GWT&lt;/a&gt; before and compared to that the first thing you will notice is that Scala.js is FAST.
It compiles 100 times faster, yet it still outputs JavaScript that is both faster and smaller.
-- &lt;cite&gt;Baldur Norddahl&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scala.js has very good tooling and very good documentation.
If you already write JVM flavoured Scala you can be up and running in no time and write JS flavoured Scala.
-- &lt;cite&gt;Guillaume Belrose&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[...] Scala.js has one of the smartest and most responsive communities I have ever seen.
You, Li Haoyi, and many other posters here have contributed to making this platform welcoming to newcomers.
The help I&amp;#39;ve received here has encouraged me to learn Scala proper, as well as many interesting functional programming concepts.
-- &lt;cite&gt;Travis Good&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;One of the biggest awesomeness of Scala.js is the core team&amp;#39;s steady hands.
Right from the get go, Scala.js showed a mature engineering approach where each release made a meaningful difference to user projects, vetted release-to-release compatibility, communicated breaking changes well in advance, maintained useful associated libraries, and let pragmatism win over everything else.
As a result, even though this is such a new project, it doesn&amp;#39;t feel risky to use it in real projects.
-- &lt;cite&gt;Ramnivas Laddad&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scala.js is simply the best option available on browsers today, if you&amp;#39;re looking for a language with a powerful yet flexible type system.
-- &lt;cite&gt;Xavier Cho&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Why remove the experimental flag now?&lt;/h2&gt;

&lt;p&gt;Many Scala.js users would say that it has been production-ready for quite some time already.
Possibly as early as 0.5.0, which was released in June 2014.
So why do we choose to remove the experimental flag now?
What has changed?&lt;/p&gt;

&lt;p&gt;The big difference is several different aspects of &lt;em&gt;stability&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The semantics of the language are settled. They may still evolve in a backward compatible way (defining previously undefined behaviors), but will otherwise not change anymore.&lt;/li&gt;
&lt;li&gt;The standard library of Scala.js (the &lt;code&gt;scala.scalajs.js&lt;/code&gt; package) will remain backward source and binary compatible.&lt;/li&gt;
&lt;li&gt;The sbt builds will remain backward source compatible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, we must still be able to evolve the library and the builds, so things might become deprecated, and eventually removed, but will do so at a slower pace than before.&lt;/p&gt;

&lt;p&gt;All things considered, this means that the code you write today, for Scala.js 0.6.0, will continue to work throughout 0.6.x and 1.x.y unchanged.&lt;/p&gt;

&lt;p&gt;&amp;quot;So why isn&amp;#39;t it 1.0.0 already?
It seems like these properties satisfy to the requirements of a 1.0.0 version.
What are you hiding?&amp;quot;&lt;/p&gt;

&lt;p&gt;While from all user-visible points of view Scala.js is stable, there remains just one quasi-implementation detail which might have to change in future versions – the format of the intermediate files of Scala.js, the &lt;code&gt;.sjsir&lt;/code&gt; files.
These files are essentially the Scala.js equivalent of &lt;code&gt;.class&lt;/code&gt; files for the JVM.
We&amp;#39;re not yet completely certain that we&amp;#39;re settled on their format, so we&amp;#39;d like to reserve the possibility of changing it in the coming months.
Doing so means breaking binary compatibility (by definition), and therefore would require a change in major version number.
So we&amp;#39;re not yet jumping to version 1.0.0 just yet – this is so that we may give ourselves one last chance to modify the Scala.js intermediate format before we make the leap to our first major version.&lt;/p&gt;

&lt;p&gt;Though, rest assured! We&amp;#39;re confident that Scala.js is otherwise stable and ready for widespread adoption.&lt;/p&gt;

&lt;h2&gt;Getting started&lt;/h2&gt;

&lt;p&gt;There are three main ways to get started with Scala.js:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scala-js.org/doc/tutorial.html&quot;&gt;The tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The free e-book &lt;a href=&quot;http://lihaoyi.github.io/hands-on-scala-js/&quot;&gt;Hands-on Scala.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The online sandbox &lt;a href=&quot;http://www.scala-js-fiddle.com/&quot;&gt;Scala.jsFiddle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So go ahead!
Use it, love it, and build the web applications of the future!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.11.5 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.11.5"/>
    <updated>2015-01-14T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.11.5</id>
    <content type="html">&lt;p&gt;We are very pleased to announce the release of Scala 2.11.5!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get started with the &lt;a href=&quot;https://typesafe.com/activator/template/hello-scala-2_11&quot;&gt;Hello Scala 2.11 template&lt;/a&gt; in &lt;a href=&quot;https://typesafe.com/platform/getstarted&quot;&gt;Typesafe Activator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.11.5.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Obtain it via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.5%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scala 2.11.5 is a bugfix release that is binary compatible with previous releases in the Scala 2.11 series. We would like to highlight the following changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;heathermiller&amp;#39;s &lt;a href=&quot;https://github.com/scala/scala/pull/4051&quot;&gt;SI-6502 Reenables loading jars into the running REPL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mpociecha&amp;#39;s &lt;a href=&quot;https://github.com/scala/scala/pull/4176&quot;&gt;The alternative, flat representation of classpath elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gbasler&amp;#39;s &lt;a href=&quot;https://github.com/scala/scala/pull/4078&quot;&gt;Avoid the &amp;#39;CNF budget exceeded&amp;#39; exception via smarter translation into CNF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;adriaanm&amp;#39;s &lt;a href=&quot;https://github.com/scala/scala/pull/4101&quot;&gt;SAMmy: eta-expansion, overloading, existentials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A great number of documentation improvements -- thank you (and, to those appearing for the first time in our release notes, welcome!): @kanielc, @lymia, @stevegury, @vigdorchik, @gourlaysama, @ichoran, @retronym, @xuwei-k, @dickwall, @phaller.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to 2.11.4, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.11.5%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;74 issues&lt;/a&gt;. Out of 132, we &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.5&quot;&gt;merged 110 pull requests&lt;/a&gt;. Before upgrading, please also check the &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20status%3Dopen%20AND%20affectedVersion%20%3D%20%22Scala%202.11.5%22%20and%20fixVersion%20%3E%3D%20%22Scala%202.11.5%22%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;known issues&lt;/a&gt; for this release.&lt;/p&gt;

&lt;p&gt;In 2015, 2.11 minor releases will be released quarterly, or sooner if prompted by a serious issue.&lt;/p&gt;

&lt;h3&gt;Scala IDE&lt;/h3&gt;

&lt;p&gt;The current release of Scala IDE includes Scala 2.11.5 is available on the &lt;a href=&quot;http://scala-ide.org/download/sdk.html&quot;&gt;download site&lt;/a&gt; (or as an update to version 4.0 of the plugin).&lt;/p&gt;

&lt;h3&gt;Available Libraries and Frameworks&lt;/h3&gt;

&lt;p&gt;A large number of Scala projects have been released against Scala 2.11. Please refer to the list of &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.11.x/projects-2.11.md&quot;&gt;libraries and frameworks available for Scala 2.11&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Reminder: Do Not Use Scala 2.11.3&lt;/h3&gt;

&lt;p&gt;Due to a &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8899&quot;&gt;binary incompatibility&lt;/a&gt; in Scala 2.11.3, we recommend upgrading to Scala 2.11.5, which resolves the incompatibility, as well as another &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8900&quot;&gt;blocker issue&lt;/a&gt; that was discovered in the days after the 2.11.3 release.&lt;/p&gt;

&lt;p&gt;We have &lt;a href=&quot;https://groups.google.com/d/msg/scala-internals/SSD9BNJaFbU/rACBkHrs2JEJ&quot;&gt;analyzed&lt;/a&gt; the mistakes that lead to the breakage (human error), and are taking measures to prevent this from happening again. We apologize for the inconvenience, and thank everyone who was involved in reporting and diagnosing these critical issues.&lt;/p&gt;

&lt;h3&gt;Release Notes for the Scala 2.11 Series&lt;/h3&gt;

&lt;p&gt;The release notes for the Scala 2.11 series, which also apply to the current minor release, are available in the &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;release notes for Scala 2.11.1&lt;/a&gt;. They contain important information such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;li&gt;Details on new features, important changes and deprecations in Scala 2.11.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, participating in mailing lists and other public fora, and submitting and reviewing pull requests! You are all awesome.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.11.4..v2.11.5&lt;/code&gt;, 30 people contributed to this minor release:
Jason Zaugg, Lukas Rytz, Michał Pociecha, A. P. Marki, Antoine Gourlay, Heather Miller, Adriaan Moors, Rex Kerr, Simon Ochsenreither, Gerard Basler, Denton Cockburn, Kenji Yoshida, Ye Xianjin, Guy Dickinson, Jean-Remi Desjardins, Alissa Rao, Lukasz Piepiora, Maxim Valyanskiy, Paolo Giarrusso, Philipp Haller, Rafał Krzewski, Eugene Vigdorchik, Rui Gonçalves, Erik Erlandson, Steve Gury, Teemu Lehtinen, Tim Harper, Dick Wall, Guillaume Martres, Grzegorz Kossakowski.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala 2.11.4 is now available!</title>
    <link href="http://www.scala-lang.org/news/2.11.4"/>
    <updated>2014-10-30T00:00:00+00:00</updated>
    <id>http://www.scala-lang.org/news/release-notes-2.11.4</id>
    <content type="html">&lt;p&gt;We are very pleased to announce the release of Scala 2.11.4!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get started with the &lt;a href=&quot;https://typesafe.com/activator/template/hello-scala-2_11&quot;&gt;Hello Scala 2.11 template&lt;/a&gt; in &lt;a href=&quot;https://typesafe.com/platform/getstarted&quot;&gt;Typesafe Activator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download a distribution from &lt;a href=&quot;http://scala-lang.org/download/2.11.4.html&quot;&gt;scala-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Obtain it via &lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.11.4%22&quot;&gt;Maven Central&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scala 2.11.4 is a bugfix release that is binary compatible with previous releases in the Scala 2.11 series.
The changes include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scala shell (REPL) is more friendly to Ctrl+D. It leaves your terminal in a clean state and suggests using &lt;code&gt;:quit&lt;/code&gt; the next
time (see &lt;a href=&quot;https://github.com/scala/scala/pull/3902&quot;&gt;#3902&lt;/a&gt;). Kudos to &lt;a href=&quot;https://github.com/gourlaysama&quot;&gt;@gourlaysama&lt;/a&gt;!&lt;/li&gt;
&lt;li&gt;REPL uses different colors when printing references to vals and types. Pass &lt;code&gt;-Dscala.color&lt;/code&gt; to enable that behavior (see &lt;a href=&quot;https://github.com/scala/scala/pull/3993&quot;&gt;#3993&lt;/a&gt;). Thanks to &lt;a href=&quot;https://github.com/puffnfresh&quot;&gt;@puffnfresh&lt;/a&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scala-lang.org/files/archive/spec/2.11/&quot;&gt;The Scala specification&lt;/a&gt; received a fair amount of love and became much more beautiful. It has got syntax highlighting (&lt;a href=&quot;https://github.com/scala/scala/pull/3984&quot;&gt;#3984&lt;/a&gt;), linkable headers, and a side bar with TOC (&lt;a href=&quot;https://github.com/scala/scala/pull/3996&quot;&gt;#3996&lt;/a&gt;). A few final touches has been merged that fix typos and mistakes stemming from automatic Latex to Markdown conversion we&amp;#39;ve done a while ago. Thanks for attention to details &lt;a href=&quot;https://github.com/gourlaysama&quot;&gt;@gourlaysama&lt;/a&gt;, &lt;a href=&quot;https://github.com/som-snytt&quot;&gt;@som-snytt&lt;/a&gt; and &lt;a href=&quot;https://github.com/roberthoedicke&quot;&gt;roberthoedicke&lt;/a&gt;!&lt;/li&gt;
&lt;li&gt;Non-deterministic pattern matching warnings has been fixed (&lt;a href=&quot;https://issues.scala-lang.org/browse/SI-7746&quot;&gt;SI-7746&lt;/a&gt;). Many thanks to &lt;a href=&quot;https://github.com/gbasler&quot;&gt;@gbasler&lt;/a&gt; for diving deep (&lt;a href=&quot;https://github.com/scala/scala/pull/3954&quot;&gt;#3954&lt;/a&gt;) into logical formulas constructed by our pattern matcher implementation!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compared to 2.11.2, this release resolves &lt;a href=&quot;https://issues.scala-lang.org/issues/?jql=project%20%3D%20SI%20AND%20resolution%20%3D%20Fixed%20AND%20fixVersion%20in%20%28%22Scala%202.11.3%22%2C%20%22Scala%202.11.4%22%29%20ORDER%20BY%20component%20ASC%2C%20priority%20DESC&quot;&gt;54 issues&lt;/a&gt;. Out of 120, we merged 95 pull requests: &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.3&quot;&gt;90 for 2.11.3&lt;/a&gt;, and &lt;a href=&quot;https://github.com/scala/scala/pulls?q=is%3Apr+is%3Amerged+milestone%3A2.11.4&quot;&gt;5 for 2.11.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next minor Scala 2.11 release will be available before the end of the year, or sooner if prompted by a serious issue.&lt;/p&gt;

&lt;h3&gt;Known Issue in Scala 2.11.4&lt;/h3&gt;

&lt;p&gt;Serialization of anonymous functions in Scala 2.11.1 to 2.11.4 is affected by &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8960&quot;&gt;issue SI-8960&lt;/a&gt;.
Normally, all anonymous function classes generated by the compiler have a &lt;code&gt;SerialVersionUID&lt;/code&gt; field of value &lt;code&gt;0l&lt;/code&gt;.
The issue causes the &lt;code&gt;SerialVersionUID&lt;/code&gt; to be missing.
This in turn causes the JVM to compute the UID from the class signature on deserialization, which may trigger a &lt;code&gt;ClassNotFoundException&lt;/code&gt; if the outer class of the function is not on the classpath.&lt;/p&gt;

&lt;p&gt;The issue was discovered by Josh Rosen, who also wrote up a &lt;a href=&quot;https://gist.github.com/JoshRosen/3d8d5d5cc35bc245185c&quot;&gt;detailed description&lt;/a&gt;.
A &lt;a href=&quot;https://github.com/scala/scala/pull/4093&quot;&gt;fix has been committed&lt;/a&gt; and will be available in Scala 2.11.5.&lt;/p&gt;

&lt;h3&gt;Do Not Use Scala 2.11.3&lt;/h3&gt;

&lt;p&gt;Due to a &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8899&quot;&gt;binary incompatibility&lt;/a&gt; in Scala 2.11.3, we recommend upgrading to Scala 2.11.4, which resolves the incompatibility, as well as another &lt;a href=&quot;https://issues.scala-lang.org/browse/SI-8900&quot;&gt;blocker issue&lt;/a&gt; that was discovered in the days after the 2.11.3 release.&lt;/p&gt;

&lt;p&gt;We have &lt;a href=&quot;https://groups.google.com/d/msg/scala-internals/SSD9BNJaFbU/rACBkHrs2JEJ&quot;&gt;analyzed&lt;/a&gt; the mistakes that lead to the breakage (human error), and are taking measures to prevent this from happening again. We apologize for the inconvenience, and thank everyone who was involved in reporting and diagnosing these critical issues.&lt;/p&gt;

&lt;h3&gt;Available Libraries and Frameworks&lt;/h3&gt;

&lt;p&gt;A large number of Scala projects have been released against Scala 2.11. Please refer to the list of &lt;a href=&quot;https://github.com/scala/make-release-notes/blob/2.11.x/projects-2.11.md&quot;&gt;libraries and frameworks available for Scala 2.11&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A release of the Scala IDE that includes Scala 2.11.4 is available &lt;a href=&quot;http://scala-ide.org/download/milestone.html&quot;&gt;on their download site&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Release Notes for the Scala 2.11 Series&lt;/h3&gt;

&lt;p&gt;The release notes for the Scala 2.11 series, which also apply to the current minor release, are available in the &lt;a href=&quot;http://scala-lang.org/news/2.11.1&quot;&gt;release notes for Scala 2.11.1&lt;/a&gt;. They contain important information such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The specification of binary compatibility between minor releases.&lt;/li&gt;
&lt;li&gt;Details on new features, important changes and deprecations in Scala 2.11.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Contributors&lt;/h3&gt;

&lt;p&gt;A big thank you to everyone who&amp;#39;s helped improve Scala by reporting bugs, improving our documentation, participating in mailing lists and other public fora, and submitting and reviewing pull requests! You are all awesome.&lt;/p&gt;

&lt;p&gt;According to &lt;code&gt;git shortlog -sn --no-merges v2.11.2..v2.11.4&lt;/code&gt;, 35 people contributed to this minor release:
Lukas Rytz, Adriaan Moors, Antoine Gourlay, A. P. Marki, Jason Zaugg, Robert Hoedicke, Eugene Burmako, Rex Kerr, Max Bileschi, Brian McKenna, Grzegorz Kossakowski, Maks Atygaev, Evgeny Vereshchagin, Simon Ochsenreither, Dominik Gruntz, Masato Sogame, Gerard Basler, Dan Garrette, Artem Stasuk, David Turner, Iulian Dragos, Jeroen ter Voorde, Kato Kazuyoshi, Konstantin Fedorov, Krystian Nowak, Lukas Elmer, Malte Isberner, Paolo Giarrusso, Paweł Wiejacha, Robert Hoedicke, dgruntz, Roman Janusz, harryhuk, Michał Pociecha.&lt;/p&gt;
</content>
  </entry>
  
</feed>
